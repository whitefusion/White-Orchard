{"title":"Javascript: Scripting Documents","date":"2018-09-28T10:42:37.000Z","excerpt":"","slug":"js-scripting-windows","comments":true,"tags":["javascript","note"],"categories":["language core"],"updated":"2018-10-01T03:47:27.787Z","content":"<blockquote>\n<p>This is the reading note for “Chapter 15: Scripting Documents, Javascript: The definitive guide 5th edition”. <br></p>\n</blockquote>\n<p>Every Window object has a <code>document</code> property that refers to a Document object. it is the central object in a larger API, known as the <em>Document Object Model</em>, or DOM, for representing and manipulating document content. </p>\n<h2 id=\"Overview-of-the-DOM\"><a href=\"#Overview-of-the-DOM\" class=\"headerlink\" title=\"Overview of the DOM\"></a>Overview of the DOM</h2><p>The Document Object Model, or DOM, is the fundamental API for representing and manipulating the content of HTML and XML documents. <br></p>\n<p>First you should understand that the nested elements of an HTML or XML document are represented in the DOM as a tree of objects. The tree representation of an HTML document contains nodes representing HTML tags or elements, such as <code>&lt;body&gt;</code> and <code>&lt;p&gt;</code>, and nodes representing strings of text. An HTML document may also contain nodes representing HTML comments. <br></p>\n<p><img src=\"../images/tree_structure.png\" alt=\"tree_structure\"></p>\n<p>At the root of the tree is the Document node that represent the entire document. The nodes that represent HTML elements are Element nodes, and the nodes that represent text are Text nodes. Document, Element, and Text are subclasses of Node and have their own entries in the reference section. <br></p>\n<p><img src=\"../images/node_hierarchy.png\" alt=\"node_hierarchy\"></p>\n<p>Notice that there is a formal distinction between the generic Document and Element types, and the HTMLDocument and HTMLElement types. The Document type represents either an HTML or an XML document, and the Element class represents an element of such a document. The HTMLDocument and HTMLElement subclasses are specific to HTML documents and elements. </p>\n<h2 id=\"Selecting-Document-Elements\"><a href=\"#Selecting-Document-Elements\" class=\"headerlink\" title=\"Selecting Document Elements\"></a>Selecting Document Elements</h2><p>The DOM defines a number of ways to select elements; you can query a document for an elements or elements:</p>\n<ul>\n<li>with a specific <code>id</code> attribute</li>\n<li>with a specifc <code>name</code> attribute</li>\n<li>with the specified tag name</li>\n<li>with the specified CSS class or classes</li>\n<li>matching the specified CSS selector</li>\n</ul>\n<h3 id=\"Selecting-Elements-By-ID\"><a href=\"#Selecting-Elements-By-ID\" class=\"headerlink\" title=\"Selecting Elements By ID\"></a>Selecting Elements By ID</h3><p>Use <code>getElementById()</code> method.</p>\n<h3 id=\"Selecting-Elements-By-Name\"><a href=\"#Selecting-Elements-By-Name\" class=\"headerlink\" title=\"Selecting Elements By Name\"></a>Selecting Elements By Name</h3><p>The HTML <code>name</code> attribute was originally intended to assign names  to form elements, and the value of this attribute is used when form data is submitted to a server. The value of a <code>name</code> attribute does not have to be unique: multiple elements may have the same name, and this is common in the case of radio buttons and checkboxes in forms. Also unlike <code>id</code>, the <code>name</code> attribute is only valid on a handful of HTML elements, including forms, form elements, <code>&lt;iframe&gt;</code> and <code>&lt;img&gt;</code> elements. <br><br><code>getElementsByName()</code> is defined by the HTMLDocument class, not the Document class, and so it is only available for HTML documents, not XML documents. It returns NodeList object that behaves like a read-only array of Element objects. <br></p>\n<p>Setting the name attribute of certain HTML elements automatically created properties with those names on the Window object. A similar thing is true for the Document object. Setting the <code>name</code> attribute of a <code>&lt;form&gt;, &lt;img&gt;, &lt;iframe&gt;, &lt;applet&gt;, &lt;embed&gt;, &lt;object&gt;</code> creates a property of the Document object whose name is the value of the attribute. <br></p>\n<p>If there is only a single element with a given name, the value of the automatically created document property is the element itself. If there is more than one element, then the value of the property is a NodeList object that acts as an array of elements. The document properties created for named <code>&lt;iframe&gt;</code> elements are special: instead of referring to the Element object, they refer to the frame’s Window object. </p>\n<h3 id=\"Selecting-Elements-by-Type\"><a href=\"#Selecting-Elements-by-Type\" class=\"headerlink\" title=\"Selecting Elements by Type\"></a>Selecting Elements by Type</h3><p>You can select all HTML or XML elements of a specified type using the <code>getElementsByTagName()</code> method of the Document object. Like <code>getElementByName()</code>, <code>getElementByTagName()</code> returns a NodeList object. The elements of the returned NodeList are in document order, so you can select the first <code>&lt;p&gt;</code> element of a document like this:<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> firstpara = <span class=\"built_in\">document</span>.getElementsByTagName(<span class=\"string\">'p'</span>)[<span class=\"number\">0</span>];</span><br></pre></td></tr></table></figure></p>\n<p>HTML tags are case-insensitive. It only selects elements that are descendants of the element on which it is invoked. <br></p>\n<p>For historical reasons, the HTMLDocument class defines shortcut properties to access certain kinds of nodes. The <code>images</code>, <code>forms</code>, and <code>links</code> properties, for example, refer to objects that behave like read-only arrays of <code>&lt;img&gt;, &lt;form&gt;, &lt;a&gt;</code> elements (but only <code>&lt;a&gt;</code> tags that have an <code>href</code> attribute). <br></p>\n<p>HTMLDocument also defines two properties that refer to special single elements rather than element collections. <code>document.body</code> is the <code>&lt;body&gt;</code> element of an HTML document, and <code>document.head</code> is the <code>&lt;head&gt;</code> element. The <code>documentElement</code> property of the Document class refers to the root element of the document. In HTML documents, this is always an <code>&lt;html&gt;</code> element. <br></p>\n<p><code>getElementsByName()</code> and <code>getElementsByTagName()</code> return NodeList objects, and properties like <code>document.images</code> and <code>document.forms</code> are HTMLCollection objects. These objects are read-only array-like objects. You cannot invoke Array methods on NodeLists and HTMLCollections directly, but you can do so indirectly:<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> content = <span class=\"built_in\">Array</span>.prototype.map.call(<span class=\"built_in\">document</span>.getElementsByTagName(<span class=\"string\">'p'</span>), <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">e</span>) </span>&#123; <span class=\"keyword\">return</span> e.innerHTML; &#125;);</span><br></pre></td></tr></table></figure></p>\n<p>One of the most important and surprising features of NodeList and HTMLCollection is that they are not static snapshots of a historical document state but are generally <em>live</em> and the list of elements they contain can vary as the document changes. Usually, the liveness of NodeLists and HTMLCollections is quite helpful. If you will be adding or removing elements elements from the document while iterating through a NodeList, however, you may want to make a static copy of the NodeList first:<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> snapshot = <span class=\"built_in\">Array</span>.prototype.slice.call(nodelist, <span class=\"number\">0</span>);</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"Selecting-Elements-by-CSS-Class\"><a href=\"#Selecting-Elements-by-CSS-Class\" class=\"headerlink\" title=\"Selecting Elements by CSS Class\"></a>Selecting Elements by CSS Class</h3><p><code>class</code> is a reserved word in JS, so client-side JS uses the <code>className</code> property to hold the value of the HTML <code>class</code> attribute. Use <code>getElementsByClassName()</code>. <br></p>\n<p>Like <code>getElementsByTagName()</code>, <code>getElementsByClassName()</code> can be invoked on both HTML documents and HTML elements, and it returns a live NodeList containing all matching descendants of the document or element. <code>getElementsByClassName()</code> takes a single string argument, but the string may specify multiple space-separated identifiers. The order of the identifiers does not matter. Note that both the <code>class</code> attribute and the <code>getElementsByClassName()</code> methods separate class identifiers with spaces. </p>\n<h3 id=\"Selecting-Elements-with-CSS-Selectors\"><a href=\"#Selecting-Elements-with-CSS-Selectors\" class=\"headerlink\" title=\"Selecting Elements with CSS Selectors\"></a>Selecting Elements with CSS Selectors</h3><p>CSS stylesheets have a very powerful syntax, known as <em>selectors</em>.</p>\n<ul>\n<li>Elements can be described by ID, tag name, or class: <ul>\n<li>#nav</li>\n<li>div</li>\n<li>.warning</li>\n</ul>\n</li>\n<li>Elements can be selected based on attribute values:<ul>\n<li>p[lang=’fr’] </li>\n<li>*[name=’x’] // any element with a name=’x’ attribute</li>\n</ul>\n</li>\n<li>Combined<ul>\n<li>span.fatal.error </li>\n<li>span[lang=’fr’].warning</li>\n</ul>\n</li>\n<li>selectors can also specify document structure<ul>\n<li>#log span // any <span> descendant of the element with id=’log’</span></li>\n<li>#log&gt;span // any <span> child of the element with id=’log’ </span></li>\n<li>body&gt;h1:first-child // the first <h1> child of the <body></body></h1></li>\n</ul>\n</li>\n<li>selectors can be combined to select multiple elements or multiple sets of elements<ul>\n<li>div, #log // all <div> elements plus the element with id=’log’</div></li>\n</ul>\n</li>\n</ul>\n<p>Along with the standardization of CSS3 selectors, another W3C standard, known as ‘Selectors API’ defines JS methos for obtaining the elements that match a given selector. The key to this API is the Document method <code>querySelectorAll()</code>. It takes a single string argument containing a CSS selector and returns NodeList that represents all elements in the document that match the selector. Unlike previously described element selection methods, the NodeList returned by <code>querySelectorAll()</code> is not live. If the selector string is invalid, <code>querySelectorAll()</code> throws an exception. <br></p>\n<p>When invoked on an element, the specified selector is matched against the entire document, and then the result set is filtered so that it only includese descendants of the specified elements. Web applications based on jQuery use a portable, cross-browser equivalent to <code>querySelectorAll()</code> named <code>$()</code>. </p>\n<h2 id=\"Document-Structure-and-Traversal\"><a href=\"#Document-Structure-and-Traversal\" class=\"headerlink\" title=\"Document Structure and Traversal\"></a>Document Structure and Traversal</h2><p>Once you have selected an Element from a Document, you sometimes need to find structurally related portions (parent, siblings, children) of the document. A Document can be conceptualized as a tree of Node objects. The Node type defines properties for traversing such a tree. Another API allows documents to be traversed as trees of Element objects. </p>\n<h3 id=\"Documents-As-Trees-of-Nodes\"><a href=\"#Documents-As-Trees-of-Nodes\" class=\"headerlink\" title=\"Documents As Trees of Nodes\"></a>Documents As Trees of Nodes</h3><p>Node defines the following important properties:</p>\n<ul>\n<li><code>parentNode</code></li>\n<li><code>childNodes</code></li>\n<li><code>firstChild</code>, <code>lastChild</code></li>\n<li><code>nextSibling</code>, <code>previousSibling</code><ul>\n<li>The next and previous sibling node of a node. Two nodes with the same parent are siblings. Their order reflects the order in which they appear in the document. These properties connect nodes in a doubly linked list. </li>\n</ul>\n</li>\n<li><code>nodeType</code><ul>\n<li>Document nodes have the value 9. Element nodes have the value 1. Text nodes have the value 3. Comment nodes are 8 and Document Fragment nodes are 11.</li>\n</ul>\n</li>\n<li><code>nodeValue</code><ul>\n<li>The textual context of a Text or Comment node. </li>\n</ul>\n</li>\n<li><code>nodeName</code><ul>\n<li>The tag name of an Element, converted to uppercase.</li>\n</ul>\n</li>\n</ul>\n<p>Using these Node properties, the second child node of the first child of the Document can be referred to with expressions like these:<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">document</span>.childNodes[<span class=\"number\">0</span>].childNodes[<span class=\"number\">1</span>]</span><br><span class=\"line\"><span class=\"built_in\">document</span>.firstChild.firstChild.nextSibling</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"Documents-As-Trees-of-Elements\"><a href=\"#Documents-As-Trees-of-Elements\" class=\"headerlink\" title=\"Documents As Trees of Elements\"></a>Documents As Trees of Elements</h3><p>When we are primarily interested in the Elements of a document instead of the text within them (and the whitespace between them), it is helpful to use an API that allows us to treat a document as a tree of Element objects, ignoring Text and Comment nodes that are also part of the document. <br><br>The first part of this API is the <code>children</code> property of Element object. Like <code>childNodes</code>, this is a NodeList. Unlike <code>childNodes</code>, however, the <code>children</code> list contains only Element objects. <br><br>The second part of an element-based document traversal API is Element properties that are analogs to the child and sibling properties of the Node object: </p>\n<ul>\n<li><code>firstElementChild</code>, <code>lastElementChild</code>: for element child only</li>\n<li><code>nextElementSibling</code>, <code>previousElementSibling</code>: for element sibling only</li>\n<li><code>childElementCount</code></li>\n</ul>\n<p>Types like Elemnt and HTMLDocument are classes like String and Array that are popular among all different kinds of browsers. They are not constructors, but they have prototype objects and you can extend them with custome methods:<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Element.prototype.next = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.nextElementSibling) <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.nextElementSibling;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> sib = <span class=\"keyword\">this</span>.nextSibling;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(sib &amp;&amp; sib.nodeType !== <span class=\"number\">1</span> ) sib = sib.nextSibling;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> sib;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"Attributes\"><a href=\"#Attributes\" class=\"headerlink\" title=\"Attributes\"></a>Attributes</h2><p>HTML elements consist of a tag name and a set of name/value pairs known as <em>attributes</em>. The attribute values of HTML elements are available as properties of the HTMLElement objects that represent those elements. </p>\n<h3 id=\"HTML-Attributes-As-Element-Properties\"><a href=\"#HTML-Attributes-As-Element-Properties\" class=\"headerlink\" title=\"HTML Attributes As Element Properties\"></a>HTML Attributes As Element Properties</h3><p>The HTMLElement objects that represent the elements of an HTML document define read/write properties that mirror the HTML attributes of the elements. HTMLElement defines properties for the universal HTTP attributes such as <code>id, title, lang</code> and <code>dir</code>, and event handler properties like <code>onclick</code>. Element-specific subtypes define attributes specific to those elements. For example, to query the URL of an image, you can use the <code>src</code> property of the HTMLElement that represents the <code>&lt;img&gt;</code> element.<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> image = <span class=\"built_in\">document</span>.getElementsById(<span class=\"string\">'myimage'</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> imgurl = image.src;</span><br><span class=\"line\">image.id === <span class=\"string\">'myimage'</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> f = <span class=\"built_in\">document</span>.forms[<span class=\"number\">0</span>];</span><br><span class=\"line\">f.action = <span class=\"string\">'http://www.example.com/submit.php'</span>;</span><br><span class=\"line\">f.method = <span class=\"string\">'POST'</span>;</span><br></pre></td></tr></table></figure></p>\n<p>HTML attributes are not case sensitive, but JS property names are. To convert an attribute name to the JS property, write it in lower case. If the attribute is more than one word long, however, using the camel case, like <code>defaultChecked</code> and <code>tabIndex</code>. <br></p>\n<p>The HTML <code>for</code> attribute (of the <code>&lt;label&gt;</code>), for example, becomes the JS <code>htmlFor</code> property. <code>class</code> is reserved in JS, and the very important HTML <code>class</code> attribute is an exception to the rule above: it becomes <code>className</code> in JS code. <br></p>\n<p>The properties that represent HTML attributes usually have string value. When the attribute is a boolean or numeric value (the <code>defaultChecked</code> and <code>maxLength</code> attributes of an <code>&lt;input&gt;</code> element, for example) , the properties values are booleans or numbers instead of strings. Event handler attributes always have Function objects as their values. The HTML5 specifications defines a few attributes that convert element IDs to actual Element objects. Finally, the value of the <code>style</code> property of any HTML element is a CSSStyleDeclaration object rather than a string. <br></p>\n<p>Note that this property-based API for getting and setting atribute values does not define any way to remove an attribute from an element. In particular, the <code>delete</code> operator cannot be used for this purpose. </p>\n<h3 id=\"Getting-and-Setting-Non-HTML-Attributes\"><a href=\"#Getting-and-Setting-Non-HTML-Attributes\" class=\"headerlink\" title=\"Getting and Setting Non-HTML Attributes\"></a>Getting and Setting Non-HTML Attributes</h3><p>HTMLElement and its subtypes define properties that correspond to the standard attributes of HTML elements. The Element type also defines <code>getAttribute()</code> and <code>setAttribute()</code> methods that you can use to query and set non-standard HTML attributes and to query and set attributes on the elements of an XML document:<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> image = <span class=\"built_in\">document</span>.images[<span class=\"number\">0</span>];</span><br><span class=\"line\"><span class=\"keyword\">var</span> width = <span class=\"built_in\">parseInt</span>(image.getAttribute(<span class=\"string\">'WIDTH'</span>));</span><br><span class=\"line\">image.setAttribute(<span class=\"string\">'class'</span>, <span class=\"string\">'thumbnail'</span>);</span><br></pre></td></tr></table></figure></p>\n<p>The code above highlights two important differences between these methods and the property-based API described above. First, attribute values are all treated as strings. <code>getAttribute()</code> never returns a number, boolean, or object. Second, these methods use standard attribute names, even when those names are reserved words in JS. For HTML element, the attribute names are case insensitive. <br></p>\n<p>Element also defines two related methods, <code>hasAttribute()</code> and <code>removeAttribute()</code>, which check for the presence of a named attribute and remove an attribute entirely.<br></p>\n<p>If you are working with XML documents that include attributes from other namespaces, you can use the namespaced variants of these four methods: <code>getAttributeNS()</code>, <code>setAttributeNS()</code>, <code>hasAttributeNS()</code>, and <code>removeAttributeNS()</code>. Instead of taking a single attribute name string, these methods take two. The first is the URI that identifies the namespace. The seond is usually the unqualified local name of the attribute within the namespace. For <code>setAttributeNS()</code> only, however, the second argument is the qualified name of the attribute and includes the namespace prefix. </p>\n<h3 id=\"Dataset-Attributes\"><a href=\"#Dataset-Attributes\" class=\"headerlink\" title=\"Dataset Attributes\"></a>Dataset Attributes</h3><p>As noted above, we can use the <code>getAttribute()</code> and <code>setAttribute()</code> methods to read and write the values of nonstandard attributes. The price you pay, however, is that your document will not be valid HTML.  <br></p>\n<p>HTML5 provides a solution. In an HTML5 document, any attribute whose name is lowercase and begins with the prefix ‘data-‘ is considered valid. These ‘dataset attribute’ will not affect the presentation of the elements on which they appear and they define a standard way to attach additional data without compromising document validity. <br><br>HTML5 also defines a <code>dataset</code> property on Element objects. This property refers to an object, which has properties that correspond to the <code>data-</code> attributes with their prefix removed. Thus <code>dataset.x</code> would hold the value of the <code>data-x</code> attribute. Hyphenated attributes map to camel-case property names: the attribute <code>data-jquery-test</code> becomes the property <code>dataset.jqueryTest</code>.</p>\n<h3 id=\"Attributes-As-Attr-Nodes\"><a href=\"#Attributes-As-Attr-Nodes\" class=\"headerlink\" title=\"Attributes As Attr Nodes\"></a>Attributes As Attr Nodes</h3><p>There is one more way to work with the attributes of an Element. The Node type defines an <code>attributes</code> property. This property is <code>null</code> for any nodes that are not Element objects. For Element objects, <code>attributes</code> is a read-only array-like object that represents all the attributes of the element. The attributes object is live in the way NodeLists are. It can be indexed numerically, which means that you can enumerate all the attributes of an element. And it can also be indexed by attribute name:<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">document</span>.body.attributes[<span class=\"number\">0</span>];</span><br><span class=\"line\"><span class=\"built_in\">document</span>.body.attributes.bgcolor;</span><br><span class=\"line\">docmuemnt.body.attributes[<span class=\"string\">'onload'</span>];</span><br></pre></td></tr></table></figure></p>\n<p>The values obtained when you idnex the <code>attributes</code> object are Attr objects. </p>\n<h2 id=\"Element-Content\"><a href=\"#Element-Content\" class=\"headerlink\" title=\"Element Content\"></a>Element Content</h2><p>What is the ‘content’ of the <code>&lt;p&gt;</code> element? There are three ways we might answer this question: </p>\n<ul>\n<li>The content is the HTML string “This is a <i> simple </i> document.”</li>\n<li>The content is the plain-text string “This is a simple document”</li>\n<li>The content is a Text node, an Element node that has a Text node child, and another Text node. </li>\n</ul>\n<p>Each of these are valid answers, and each answer is useful in its own way. </p>\n<h3 id=\"Element-Content-As-HTML\"><a href=\"#Element-Content-As-HTML\" class=\"headerlink\" title=\"Element Content As HTML\"></a>Element Content As HTML</h3><p>Reading the <code>innerHTML</code> property of an Element returns the content of that element as a string of markup. Setting this property on an element invokes the web browser’s parser and replaces the element’s current content with a parsed representation of the new string. <br></p>\n<p>Web browsers are very good at parsing HTML and setting <code>innerHTML</code> is usually fairly efficient, even though the value you specify must be parsed. Note, however, that repeatedly appending bits of text to the <code>innerHTML</code> property with the <code>+=</code> operator is usually not efficient because it requires both a serialization step and a parsing step. <br></p>\n<p>HTML5 also standardizes a property named <code>outerHTML</code>. When you query <code>outerHTML</code>, the string of HTML or XML markup that is returned includes the opening and closing tags of the element on which you queried it. <code>outerHTML</code> is defined only for Element nodes, not Documents. <br></p>\n<p>Another feature standardized by HTML5 is the <code>insertAdjacentHTML()</code> mehtod, which allows you to insert a string of arbitrary HTML arkup ‘adjacent’ to the specified element. The markup is passed as the second argument to this method, and the precise meaning of ‘adjacent’ depends on the value of the first argument. This first argument should be a string with one of the values ‘beforebegin’, ‘afterbegin’, ‘beforeend’ or ‘afterend’. </p>\n<p><img src=\"../images/insertion_points.png\" alt=\"insertion_points\"></p>\n<h3 id=\"Element-content-as-plain-text\"><a href=\"#Element-content-as-plain-text\" class=\"headerlink\" title=\"Element content as plain text\"></a>Element content as plain text</h3><p>Sometimes you want to query the content of an element as plain text, or to insert plain text into a document (without having to escape the angle brackets and ampersands used in HTML markup). The standard way to do this is with the <code>textContent</code> property of Node. <br></p>\n<p>Inline <code>&lt;script&gt;</code> elements (those that do not have a <code>src</code> attribute ) have a <code>text</code> property that you can use to retrieve their text. The content of a <code>&lt;script&gt;</code> element is never displayed by the browser, and the HTML parser ignores angle brackets and ampersands within a script. This makes a <code>&lt;script&gt;</code> element an ideal place to embed arbitrary textual data for use by your application. Simply set the <code>type</code> attribute of the element to some value (such as ‘text/x-custom-data’) that makes it clear that the script is not executable JS code. If you do this JS interpreter will ignore the script, but element will exist in the document tree and its <code>text</code> property will return the data to you.</p>\n<h3 id=\"Element-Content-As-Text-Nodes\"><a href=\"#Element-Content-As-Text-Nodes\" class=\"headerlink\" title=\"Element Content As Text Nodes\"></a>Element Content As Text Nodes</h3><p>Another way to work with the content of an element is as a list of child nodes, each of which may have its won set of children. When thinking about element content, it is usually the Text nodes that are of interest. The example below shows a <code>textContent()</code> function that recursively traverses the children of an element and concatenates the text of all the Text node descendants. In order to understand the code, recall that the <code>nodeValue</code> property holds the content of a Text node. </p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Finding all Text node descendants of an element</span></span><br><span class=\"line\"><span class=\"comment\">// Return the plain-text content of element e, recursing into child elements</span></span><br><span class=\"line\"><span class=\"comment\">// This method works like the textContent property</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">textContent</span>(<span class=\"params\">e</span>)  </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> child,type, s= <span class=\"string\">''</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> ( child = e.firstChild; child != <span class=\"literal\">null</span>; child = child.nextSibling ) &#123;</span><br><span class=\"line\">        type = child.nodeType;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>( type === <span class=\"number\">3</span> || type === <span class=\"number\">4</span> )</span><br><span class=\"line\">            s += child.nodeValue;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> ( type === <span class=\"number\">1</span> )</span><br><span class=\"line\">            s += textContent(child);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> s;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>The <code>nodeValue</code> property is read/write and you can set it to change the content displayed by a Text or CDATASection node. Both Text and CDATASection are subtypes of CharacterData. CharacterData defines a <code>data</code> property, which is the same text as <code>nodeValue</code>.</p>\n<h2 id=\"Creating-Inserting-and-Deleting-Nodes\"><a href=\"#Creating-Inserting-and-Deleting-Nodes\" class=\"headerlink\" title=\"Creating, Inserting and Deleting Nodes\"></a>Creating, Inserting and Deleting Nodes</h2>","next":{"title":"The Window Object","slug":"js-window-object"},"link":"https://whitefusion.github.io/post/js-scripting-windows"}