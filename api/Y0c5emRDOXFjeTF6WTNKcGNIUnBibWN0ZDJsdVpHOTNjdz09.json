{"title":"js-scripting-windows","date":"2018-09-28T10:42:37.000Z","excerpt":"","slug":"js-scripting-windows","comments":true,"tags":["javascript","note"],"categories":["language core"],"updated":"2018-09-29T13:45:41.016Z","content":"<blockquote>\n<p>This is the reading note for “Chapter 15: Scripting Documents, Javascript: The definitive guide 5th edition”. <br></p>\n</blockquote>\n<p>Every Window object has a <code>document</code> property that refers to a Document object. it is the central object in a larger API, known as the <em>Document Object Model</em>, or DOM, for representing and manipulating document content. </p>\n<h2 id=\"Overview-of-the-DOM\"><a href=\"#Overview-of-the-DOM\" class=\"headerlink\" title=\"Overview of the DOM\"></a>Overview of the DOM</h2><p>The Document Object Model, or DOM, is the fundamental API for representing and manipulating the content of HTML and XML documents. <br></p>\n<p>First you should understand that the nested elements of an HTML or XML document are represented in the DOM as a tree of objects. The tree representation of an HTML document contains nodes representing HTML tags or elements, such as <code>&lt;body&gt;</code> and <code>&lt;p&gt;</code>, and nodes representing strings of text. An HTML document may also contain nodes representing HTML comments. <br></p>\n<p>At the root of the tree is the Document node that represent the entire document. The nodes that represent HTML elements are Element nodes, and the nodes that represent text are Text nodes. Document, Element, and Text are subclasses of Node and have their own entries in the reference section. <br></p>\n<p>Notice that there is a formal distinction between the generic Document and Element types, and the HTMLDocument and HTMLElement types. The Document type represents either an HTML or an XML document, and the Element class represents an element of such a document. The HTMLDocument and HTMLElement subclasses are specific to HTML documents and elements. </p>\n<h2 id=\"Selecting-Document-Elements\"><a href=\"#Selecting-Document-Elements\" class=\"headerlink\" title=\"Selecting Document Elements\"></a>Selecting Document Elements</h2><p>The DOM defines a number of ways to select elements; you can query a document for an elements or elements:</p>\n<ul>\n<li>with a specific <code>id</code> attribute</li>\n<li>with a specifc <code>name</code> attribute</li>\n<li>with the specified tag name</li>\n<li>with the specified CSS class or classes</li>\n<li>matching the specified CSS selector</li>\n</ul>\n<h3 id=\"Selecting-Elements-By-ID\"><a href=\"#Selecting-Elements-By-ID\" class=\"headerlink\" title=\"Selecting Elements By ID\"></a>Selecting Elements By ID</h3><p>Use <code>getElementById()</code> method.</p>\n<h3 id=\"Selecting-Elements-By-Name\"><a href=\"#Selecting-Elements-By-Name\" class=\"headerlink\" title=\"Selecting Elements By Name\"></a>Selecting Elements By Name</h3><p>The HTML <code>name</code> attribute was originally intended to assign names  to form elements, and the value of this attribute is used when form data is submitted to a server. The value of a <code>name</code> attribute does not have to be unique: multiple elements may have the same name, and this is common in the case of radio buttons and checkboxes in forms. Also unlike <code>id</code>, the <code>name</code> attribute is only valid on a handful of HTML elements, including forms, form elements, <code>&lt;iframe&gt;</code> and <code>&lt;img&gt;</code> elements. <br><br><code>getElementsByName()</code> is defined by the HTMLDocument class, not the Document class, and so it is only available for HTML documents, not XML documents. It returns NodeList object that behaves like a read-only array of Element objects. <br></p>\n<p>Setting the name attribute of certain HTML elements automatically created properties with those names on the Window object. A similar thing is true for the Document object. Setting the <code>name</code> attribute of a <code>&lt;form&gt;, &lt;img&gt;, &lt;iframe&gt;, &lt;applet&gt;, &lt;embed&gt;, &lt;object&gt;</code> creates a property of the Document object whose name is the value of the attribute. <br></p>\n<p>If there is only a single element with a given name, the value of the automatically created document property is the element itself. If there is more than one element, then the value of the property is a NodeList object that acts as an array of elements. The document properties created for named <code>&lt;iframe&gt;</code> elements are special: instead of referring to the Element object, they refer to the frame’s Window object. </p>\n<h3 id=\"Selecting-Elements-by-Type\"><a href=\"#Selecting-Elements-by-Type\" class=\"headerlink\" title=\"Selecting Elements by Type\"></a>Selecting Elements by Type</h3><p>You can select all HTML or XML elements of a specified type using the <code>getElementsByTagName()</code> method of the Document object. Like <code>getElementByName()</code>, <code>getElementByTagName()</code> returns a NodeList object. The elements of the returned NodeList are in document order, so you can select the first <code>&lt;p&gt;</code> element of a document like this:<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> firstpara = <span class=\"built_in\">document</span>.getElementsByTagName(<span class=\"string\">'p'</span>)[<span class=\"number\">0</span>];</span><br></pre></td></tr></table></figure></p>\n<p>HTML tags are case-insensitive. It only selects elements that are descendants of the element on which it is invoked. <br></p>\n<p>For historical reasons, the HTMLDocument class defines shortcut properties to access certain kinds of nodes. The <code>images</code>, <code>forms</code>, and <code>links</code> properties, for example, refer to objects that behave like read-only arrays of <code>&lt;img&gt;, &lt;form&gt;, &lt;a&gt;</code> elements (but only <code>&lt;a&gt;</code> tags that have an <code>href</code> attribute). <br></p>\n<p>HTMLDocument also defines two properties that refer to special single elements rather than element collections. <code>document.body</code> is the <code>&lt;body&gt;</code> element of an HTML document, and <code>document.head</code> is the <code>&lt;head&gt;</code> element. The <code>documentElement</code> property of the Document class refers to the root element of the document. In HTML documents, this is always an <code>&lt;html&gt;</code> element. <br></p>\n<p><code>getElementsByName()</code> and <code>getElementsByTagName()</code> return NodeList objects, and properties like <code>document.images</code> and <code>document.forms</code> are HTMLCollection objects. These objects are read-only array-like objects. You cannot invoke Array methods on NodeLists and HTMLCollections directly, but you can do so indirectly:<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> content = <span class=\"built_in\">Array</span>.prototype.map.call(<span class=\"built_in\">document</span>.getElementsByTagName(<span class=\"string\">'p'</span>), <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">e</span>) </span>&#123; <span class=\"keyword\">return</span> e.innerHTML; &#125;);</span><br></pre></td></tr></table></figure></p>\n<p>One of the most important and surprising features of NodeList and HTMLCollection is that they are not static snapshots of a historical document state but are generally <em>live</em> and the list of elements they contain can vary as the document changes. Usually, the liveness of NodeLists and HTMLCollections is quite helpful. If you will be adding or removing elements elements from the document while iterating through a NodeList, however, you may want to make a static copy of the NodeList first:<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> snapshot = <span class=\"built_in\">Array</span>.prototype.slice.call(nodelist, <span class=\"number\">0</span>);</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"Selecting-Elements-by-CSS-Class\"><a href=\"#Selecting-Elements-by-CSS-Class\" class=\"headerlink\" title=\"Selecting Elements by CSS Class\"></a>Selecting Elements by CSS Class</h3><p><code>class</code> is a reserved word in JS, so client-side JS uses the <code>className</code> property to hold the value of the HTML <code>class</code> attribute. Use <code>getElementsByClassName()</code>. <br></p>\n<p>Like <code>getElementsByTagName()</code>, <code>getElementsByClassName()</code> can be invoked on both HTML documents and HTML elements, and it returns a live NodeList containing all matching descendants of the document or element. <code>getElementsByClassName()</code> takes a single string argument, but the string may specify multiple space-separated identifiers. The order of the identifiers does not matter. Note that both the <code>class</code> attribute and the <code>getElementsByClassName()</code> methods separate class identifiers with spaces. </p>\n<h3 id=\"Selecting-Elements-with-CSS-Selectors\"><a href=\"#Selecting-Elements-with-CSS-Selectors\" class=\"headerlink\" title=\"Selecting Elements with CSS Selectors\"></a>Selecting Elements with CSS Selectors</h3><p>CSS stylesheets have a very powerful syntax, known as <em>selectors</em>.</p>\n<ul>\n<li>Elements can be described by ID, tag name, or class: <ul>\n<li>#nav</li>\n<li>div</li>\n<li>.warning</li>\n</ul>\n</li>\n<li>Elements can be selected based on attribute values:<ul>\n<li>p[lang=’fr’] </li>\n<li>*[name=’x’] // any element with a name=’x’ attribute</li>\n</ul>\n</li>\n<li>Combined<ul>\n<li>span.fatal.error </li>\n<li>span[lang=’fr’].warning</li>\n</ul>\n</li>\n<li>selectors can also specify document structure<ul>\n<li>#log span // any <span> descendant of the element with id=’log’</span></li>\n<li>#log&gt;span // any <span> child of the element with id=’log’ </span></li>\n<li>body&gt;h1:first-child // the first <h1> child of the <body></body></h1></li>\n</ul>\n</li>\n<li>selectors can be combined to select multiple elements or multiple sets of elements<ul>\n<li>div, #log // all <div> elements plus the element with id=’log’</div></li>\n</ul>\n</li>\n</ul>\n<p>Along with the standardization of CSS3 selectors, another W3C standard, known as ‘Selectors API’ defines JS methos for obtaining the elements that match a given selector. The key to this API is the Document method <code>querySelectorAll()</code>. It takes a single string argument containing a CSS selector and returns NodeList that represents all elements in the document that match the selector. Unlike previously described element selection methods, the NodeList returned by <code>querySelectorAll()</code> is not live. If the selector string is invalid, <code>querySelectorAll()</code> throws an exception. <br></p>\n<p>When invoked on an element, the specified selector is matched against the entire document, and then the result set is filtered so that it only includese descendants of the specified elements. Web applications based on jQuery use a portable, cross-browser equivalent to <code>querySelectorAll()</code> named <code>$()</code>. </p>\n<h2 id=\"Document-Structure-and-Traversal\"><a href=\"#Document-Structure-and-Traversal\" class=\"headerlink\" title=\"Document Structure and Traversal\"></a>Document Structure and Traversal</h2>","next":{"title":"The Window Object","slug":"js-window-object"},"link":"https://whitefusion.github.io/post/js-scripting-windows"}