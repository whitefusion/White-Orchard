{"title":"Javascript: Scripting Documents","date":"2018-09-28T10:42:37.000Z","excerpt":"","slug":"js-scripting-windows","comments":true,"tags":["note","javascript"],"categories":["language core"],"updated":"2018-11-10T03:44:31.210Z","content":"<blockquote>\n<p>This is the reading note for “Chapter 15: Scripting Documents, Javascript: The definitive guide 5th edition”. <br></p>\n</blockquote>\n<p>Every Window object has a <code>document</code> property that refers to a Document object. it is the central object in a larger API, known as the <em>Document Object Model</em>, or DOM, for representing and manipulating document content. </p>\n<h2 id=\"Overview-of-the-DOM\"><a href=\"#Overview-of-the-DOM\" class=\"headerlink\" title=\"Overview of the DOM\"></a>Overview of the DOM</h2><p>The Document Object Model, or DOM, is the fundamental API for representing and manipulating the content of HTML and XML documents. <br></p>\n<p>First you should understand that the nested elements of an HTML or XML document are represented in the DOM as a tree of objects. The tree representation of an HTML document contains nodes representing HTML tags or elements, such as <code>&lt;body&gt;</code> and <code>&lt;p&gt;</code>, and nodes representing strings of text. An HTML document may also contain nodes representing HTML comments. <br></p>\n<p><img src=\"../images/tree_structure.png\" alt=\"tree_structure\"></p>\n<p>At the root of the tree is the Document node that represent the entire document. The nodes that represent HTML elements are Element nodes, and the nodes that represent text are Text nodes. Document, Element, and Text are subclasses of Node and have their own entries in the reference section. <br></p>\n<p><img src=\"../images/node_hierarchy.png\" alt=\"node_hierarchy\"></p>\n<p>Notice that there is a formal distinction between the generic Document and Element types, and the HTMLDocument and HTMLElement types. The Document type represents either an HTML or an XML document, and the Element class represents an element of such a document. The HTMLDocument and HTMLElement subclasses are specific to HTML documents and elements. </p>\n<h2 id=\"Selecting-Document-Elements\"><a href=\"#Selecting-Document-Elements\" class=\"headerlink\" title=\"Selecting Document Elements\"></a>Selecting Document Elements</h2><p>The DOM defines a number of ways to select elements; you can query a document for an elements or elements:</p>\n<ul>\n<li>with a specific <code>id</code> attribute</li>\n<li>with a specifc <code>name</code> attribute</li>\n<li>with the specified tag name</li>\n<li>with the specified CSS class or classes</li>\n<li>matching the specified CSS selector</li>\n</ul>\n<h3 id=\"Selecting-Elements-By-ID\"><a href=\"#Selecting-Elements-By-ID\" class=\"headerlink\" title=\"Selecting Elements By ID\"></a>Selecting Elements By ID</h3><p>Use <code>getElementById()</code> method.</p>\n<h3 id=\"Selecting-Elements-By-Name\"><a href=\"#Selecting-Elements-By-Name\" class=\"headerlink\" title=\"Selecting Elements By Name\"></a>Selecting Elements By Name</h3><p>The HTML <code>name</code> attribute was originally intended to assign names  to form elements, and the value of this attribute is used when form data is submitted to a server. The value of a <code>name</code> attribute does not have to be unique: multiple elements may have the same name, and this is common in the case of radio buttons and checkboxes in forms. Also unlike <code>id</code>, the <code>name</code> attribute is only valid on a handful of HTML elements, including forms, form elements, <code>&lt;iframe&gt;</code> and <code>&lt;img&gt;</code> elements. <br><br><code>getElementsByName()</code> is defined by the HTMLDocument class, not the Document class, and so it is only available for HTML documents, not XML documents. It returns NodeList object that behaves like a read-only array of Element objects. <br></p>\n<p>Setting the name attribute of certain HTML elements automatically created properties with those names on the Window object. A similar thing is true for the Document object. Setting the <code>name</code> attribute of a <code>&lt;form&gt;, &lt;img&gt;, &lt;iframe&gt;, &lt;applet&gt;, &lt;embed&gt;, &lt;object&gt;</code> creates a property of the Document object whose name is the value of the attribute. <br></p>\n<p>If there is only a single element with a given name, the value of the automatically created document property is the element itself. If there is more than one element, then the value of the property is a NodeList object that acts as an array of elements. The document properties created for named <code>&lt;iframe&gt;</code> elements are special: instead of referring to the Element object, they refer to the frame’s Window object. </p>\n<h3 id=\"Selecting-Elements-by-Type\"><a href=\"#Selecting-Elements-by-Type\" class=\"headerlink\" title=\"Selecting Elements by Type\"></a>Selecting Elements by Type</h3><p>You can select all HTML or XML elements of a specified type using the <code>getElementsByTagName()</code> method of the Document object. Like <code>getElementByName()</code>, <code>getElementByTagName()</code> returns a NodeList object. The elements of the returned NodeList are in document order, so you can select the first <code>&lt;p&gt;</code> element of a document like this:<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> firstpara = <span class=\"built_in\">document</span>.getElementsByTagName(<span class=\"string\">'p'</span>)[<span class=\"number\">0</span>];</span><br></pre></td></tr></table></figure></p>\n<p>HTML tags are case-insensitive. It only selects elements that are descendants of the element on which it is invoked. <br></p>\n<p>For historical reasons, the HTMLDocument class defines shortcut properties to access certain kinds of nodes. The <code>images</code>, <code>forms</code>, and <code>links</code> properties, for example, refer to objects that behave like read-only arrays of <code>&lt;img&gt;, &lt;form&gt;, &lt;a&gt;</code> elements (but only <code>&lt;a&gt;</code> tags that have an <code>href</code> attribute). <br></p>\n<p>HTMLDocument also defines two properties that refer to special single elements rather than element collections. <code>document.body</code> is the <code>&lt;body&gt;</code> element of an HTML document, and <code>document.head</code> is the <code>&lt;head&gt;</code> element. The <code>documentElement</code> property of the Document class refers to the root element of the document. In HTML documents, this is always an <code>&lt;html&gt;</code> element. <br></p>\n<p><code>getElementsByName()</code> and <code>getElementsByTagName()</code> return NodeList objects, and properties like <code>document.images</code> and <code>document.forms</code> are HTMLCollection objects. These objects are read-only array-like objects. You cannot invoke Array methods on NodeLists and HTMLCollections directly, but you can do so indirectly:<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> content = <span class=\"built_in\">Array</span>.prototype.map.call(<span class=\"built_in\">document</span>.getElementsByTagName(<span class=\"string\">'p'</span>), <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">e</span>) </span>&#123; <span class=\"keyword\">return</span> e.innerHTML; &#125;);</span><br></pre></td></tr></table></figure></p>\n<p>One of the most important and surprising features of NodeList and HTMLCollection is that they are not static snapshots of a historical document state but are generally <em>live</em> and the list of elements they contain can vary as the document changes. Usually, the liveness of NodeLists and HTMLCollections is quite helpful. If you will be adding or removing elements elements from the document while iterating through a NodeList, however, you may want to make a static copy of the NodeList first:<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> snapshot = <span class=\"built_in\">Array</span>.prototype.slice.call(nodelist, <span class=\"number\">0</span>);</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"Selecting-Elements-by-CSS-Class\"><a href=\"#Selecting-Elements-by-CSS-Class\" class=\"headerlink\" title=\"Selecting Elements by CSS Class\"></a>Selecting Elements by CSS Class</h3><p><code>class</code> is a reserved word in JS, so client-side JS uses the <code>className</code> property to hold the value of the HTML <code>class</code> attribute. Use <code>getElementsByClassName()</code>. <br></p>\n<p>Like <code>getElementsByTagName()</code>, <code>getElementsByClassName()</code> can be invoked on both HTML documents and HTML elements, and it returns a live NodeList containing all matching descendants of the document or element. <code>getElementsByClassName()</code> takes a single string argument, but the string may specify multiple space-separated identifiers. The order of the identifiers does not matter. Note that both the <code>class</code> attribute and the <code>getElementsByClassName()</code> methods separate class identifiers with spaces. </p>\n<h3 id=\"Selecting-Elements-with-CSS-Selectors\"><a href=\"#Selecting-Elements-with-CSS-Selectors\" class=\"headerlink\" title=\"Selecting Elements with CSS Selectors\"></a>Selecting Elements with CSS Selectors</h3><p>CSS stylesheets have a very powerful syntax, known as <em>selectors</em>.</p>\n<ul>\n<li>Elements can be described by ID, tag name, or class: <ul>\n<li>#nav</li>\n<li>div</li>\n<li>.warning</li>\n</ul>\n</li>\n<li>Elements can be selected based on attribute values:<ul>\n<li>p[lang=’fr’] </li>\n<li>*[name=’x’] // any element with a name=’x’ attribute</li>\n</ul>\n</li>\n<li>Combined<ul>\n<li>span.fatal.error </li>\n<li>span[lang=’fr’].warning</li>\n</ul>\n</li>\n<li>selectors can also specify document structure<ul>\n<li>#log span // any <span> descendant of the element with id=’log’</span></li>\n<li>#log&gt;span // any <span> child of the element with id=’log’ </span></li>\n<li>body&gt;h1:first-child // the first <h1> child of the <body></body></h1></li>\n</ul>\n</li>\n<li>selectors can be combined to select multiple elements or multiple sets of elements<ul>\n<li>div, #log // all <div> elements plus the element with id=’log’</div></li>\n</ul>\n</li>\n</ul>\n<p>Along with the standardization of CSS3 selectors, another W3C standard, known as ‘Selectors API’ defines JS methos for obtaining the elements that match a given selector. The key to this API is the Document method <code>querySelectorAll()</code>. It takes a single string argument containing a CSS selector and returns NodeList that represents all elements in the document that match the selector. Unlike previously described element selection methods, the NodeList returned by <code>querySelectorAll()</code> is not live. If the selector string is invalid, <code>querySelectorAll()</code> throws an exception. <br></p>\n<p>When invoked on an element, the specified selector is matched against the entire document, and then the result set is filtered so that it only includese descendants of the specified elements. Web applications based on jQuery use a portable, cross-browser equivalent to <code>querySelectorAll()</code> named <code>$()</code>. </p>\n<h2 id=\"Document-Structure-and-Traversal\"><a href=\"#Document-Structure-and-Traversal\" class=\"headerlink\" title=\"Document Structure and Traversal\"></a>Document Structure and Traversal</h2><p>Once you have selected an Element from a Document, you sometimes need to find structurally related portions (parent, siblings, children) of the document. A Document can be conceptualized as a tree of Node objects. The Node type defines properties for traversing such a tree. Another API allows documents to be traversed as trees of Element objects. </p>\n<h3 id=\"Documents-As-Trees-of-Nodes\"><a href=\"#Documents-As-Trees-of-Nodes\" class=\"headerlink\" title=\"Documents As Trees of Nodes\"></a>Documents As Trees of Nodes</h3><p>Node defines the following important properties:</p>\n<ul>\n<li><code>parentNode</code></li>\n<li><code>childNodes</code></li>\n<li><code>firstChild</code>, <code>lastChild</code></li>\n<li><code>nextSibling</code>, <code>previousSibling</code><ul>\n<li>The next and previous sibling node of a node. Two nodes with the same parent are siblings. Their order reflects the order in which they appear in the document. These properties connect nodes in a doubly linked list. </li>\n</ul>\n</li>\n<li><code>nodeType</code><ul>\n<li>Document nodes have the value 9. Element nodes have the value 1. Text nodes have the value 3. Comment nodes are 8 and Document Fragment nodes are 11.</li>\n</ul>\n</li>\n<li><code>nodeValue</code><ul>\n<li>The textual context of a Text or Comment node. </li>\n</ul>\n</li>\n<li><code>nodeName</code><ul>\n<li>The tag name of an Element, converted to uppercase.</li>\n</ul>\n</li>\n</ul>\n<p>Using these Node properties, the second child node of the first child of the Document can be referred to with expressions like these:<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">document</span>.childNodes[<span class=\"number\">0</span>].childNodes[<span class=\"number\">1</span>]</span><br><span class=\"line\"><span class=\"built_in\">document</span>.firstChild.firstChild.nextSibling</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"Documents-As-Trees-of-Elements\"><a href=\"#Documents-As-Trees-of-Elements\" class=\"headerlink\" title=\"Documents As Trees of Elements\"></a>Documents As Trees of Elements</h3><p>When we are primarily interested in the Elements of a document instead of the text within them (and the whitespace between them), it is helpful to use an API that allows us to treat a document as a tree of Element objects, ignoring Text and Comment nodes that are also part of the document. <br><br>The first part of this API is the <code>children</code> property of Element object. Like <code>childNodes</code>, this is a NodeList. Unlike <code>childNodes</code>, however, the <code>children</code> list contains only Element objects. <br><br>The second part of an element-based document traversal API is Element properties that are analogs to the child and sibling properties of the Node object: </p>\n<ul>\n<li><code>firstElementChild</code>, <code>lastElementChild</code>: for element child only</li>\n<li><code>nextElementSibling</code>, <code>previousElementSibling</code>: for element sibling only</li>\n<li><code>childElementCount</code></li>\n</ul>\n<p>Types like Elemnt and HTMLDocument are classes like String and Array that are popular among all different kinds of browsers. They are not constructors, but they have prototype objects and you can extend them with custome methods:<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Element.prototype.next = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.nextElementSibling) <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.nextElementSibling;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> sib = <span class=\"keyword\">this</span>.nextSibling;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(sib &amp;&amp; sib.nodeType !== <span class=\"number\">1</span> ) sib = sib.nextSibling;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> sib;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"Attributes\"><a href=\"#Attributes\" class=\"headerlink\" title=\"Attributes\"></a>Attributes</h2><p>HTML elements consist of a tag name and a set of name/value pairs known as <em>attributes</em>. The attribute values of HTML elements are available as properties of the HTMLElement objects that represent those elements. </p>\n<h3 id=\"HTML-Attributes-As-Element-Properties\"><a href=\"#HTML-Attributes-As-Element-Properties\" class=\"headerlink\" title=\"HTML Attributes As Element Properties\"></a>HTML Attributes As Element Properties</h3><p>The HTMLElement objects that represent the elements of an HTML document define read/write properties that mirror the HTML attributes of the elements. HTMLElement defines properties for the universal HTTP attributes such as <code>id, title, lang</code> and <code>dir</code>, and event handler properties like <code>onclick</code>. Element-specific subtypes define attributes specific to those elements. For example, to query the URL of an image, you can use the <code>src</code> property of the HTMLElement that represents the <code>&lt;img&gt;</code> element.<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> image = <span class=\"built_in\">document</span>.getElementsById(<span class=\"string\">'myimage'</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> imgurl = image.src;</span><br><span class=\"line\">image.id === <span class=\"string\">'myimage'</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> f = <span class=\"built_in\">document</span>.forms[<span class=\"number\">0</span>];</span><br><span class=\"line\">f.action = <span class=\"string\">'http://www.example.com/submit.php'</span>;</span><br><span class=\"line\">f.method = <span class=\"string\">'POST'</span>;</span><br></pre></td></tr></table></figure></p>\n<p>HTML attributes are not case sensitive, but JS property names are. To convert an attribute name to the JS property, write it in lower case. If the attribute is more than one word long, however, using the camel case, like <code>defaultChecked</code> and <code>tabIndex</code>. <br></p>\n<p>The HTML <code>for</code> attribute (of the <code>&lt;label&gt;</code>), for example, becomes the JS <code>htmlFor</code> property. <code>class</code> is reserved in JS, and the very important HTML <code>class</code> attribute is an exception to the rule above: it becomes <code>className</code> in JS code. <br></p>\n<p>The properties that represent HTML attributes usually have string value. When the attribute is a boolean or numeric value (the <code>defaultChecked</code> and <code>maxLength</code> attributes of an <code>&lt;input&gt;</code> element, for example) , the properties values are booleans or numbers instead of strings. Event handler attributes always have Function objects as their values. The HTML5 specifications defines a few attributes that convert element IDs to actual Element objects. Finally, the value of the <code>style</code> property of any HTML element is a CSSStyleDeclaration object rather than a string. <br></p>\n<p>Note that this property-based API for getting and setting atribute values does not define any way to remove an attribute from an element. In particular, the <code>delete</code> operator cannot be used for this purpose. </p>\n<h3 id=\"Getting-and-Setting-Non-HTML-Attributes\"><a href=\"#Getting-and-Setting-Non-HTML-Attributes\" class=\"headerlink\" title=\"Getting and Setting Non-HTML Attributes\"></a>Getting and Setting Non-HTML Attributes</h3><p>HTMLElement and its subtypes define properties that correspond to the standard attributes of HTML elements. The Element type also defines <code>getAttribute()</code> and <code>setAttribute()</code> methods that you can use to query and set non-standard HTML attributes and to query and set attributes on the elements of an XML document:<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> image = <span class=\"built_in\">document</span>.images[<span class=\"number\">0</span>];</span><br><span class=\"line\"><span class=\"keyword\">var</span> width = <span class=\"built_in\">parseInt</span>(image.getAttribute(<span class=\"string\">'WIDTH'</span>));</span><br><span class=\"line\">image.setAttribute(<span class=\"string\">'class'</span>, <span class=\"string\">'thumbnail'</span>);</span><br></pre></td></tr></table></figure></p>\n<p>The code above highlights two important differences between these methods and the property-based API described above. First, attribute values are all treated as strings. <code>getAttribute()</code> never returns a number, boolean, or object. Second, these methods use standard attribute names, even when those names are reserved words in JS. For HTML element, the attribute names are case insensitive. <br></p>\n<p>Element also defines two related methods, <code>hasAttribute()</code> and <code>removeAttribute()</code>, which check for the presence of a named attribute and remove an attribute entirely.<br></p>\n<p>If you are working with XML documents that include attributes from other namespaces, you can use the namespaced variants of these four methods: <code>getAttributeNS()</code>, <code>setAttributeNS()</code>, <code>hasAttributeNS()</code>, and <code>removeAttributeNS()</code>. Instead of taking a single attribute name string, these methods take two. The first is the URI that identifies the namespace. The seond is usually the unqualified local name of the attribute within the namespace. For <code>setAttributeNS()</code> only, however, the second argument is the qualified name of the attribute and includes the namespace prefix. </p>\n<h3 id=\"Dataset-Attributes\"><a href=\"#Dataset-Attributes\" class=\"headerlink\" title=\"Dataset Attributes\"></a>Dataset Attributes</h3><p>As noted above, we can use the <code>getAttribute()</code> and <code>setAttribute()</code> methods to read and write the values of nonstandard attributes. The price you pay, however, is that your document will not be valid HTML.  <br></p>\n<p>HTML5 provides a solution. In an HTML5 document, any attribute whose name is lowercase and begins with the prefix ‘data-‘ is considered valid. These ‘dataset attribute’ will not affect the presentation of the elements on which they appear and they define a standard way to attach additional data without compromising document validity. <br><br>HTML5 also defines a <code>dataset</code> property on Element objects. This property refers to an object, which has properties that correspond to the <code>data-</code> attributes with their prefix removed. Thus <code>dataset.x</code> would hold the value of the <code>data-x</code> attribute. Hyphenated attributes map to camel-case property names: the attribute <code>data-jquery-test</code> becomes the property <code>dataset.jqueryTest</code>.</p>\n<h3 id=\"Attributes-As-Attr-Nodes\"><a href=\"#Attributes-As-Attr-Nodes\" class=\"headerlink\" title=\"Attributes As Attr Nodes\"></a>Attributes As Attr Nodes</h3><p>There is one more way to work with the attributes of an Element. The Node type defines an <code>attributes</code> property. This property is <code>null</code> for any nodes that are not Element objects. For Element objects, <code>attributes</code> is a read-only array-like object that represents all the attributes of the element. The attributes object is live in the way NodeLists are. It can be indexed numerically, which means that you can enumerate all the attributes of an element. And it can also be indexed by attribute name:<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">document</span>.body.attributes[<span class=\"number\">0</span>];</span><br><span class=\"line\"><span class=\"built_in\">document</span>.body.attributes.bgcolor;</span><br><span class=\"line\">docmuemnt.body.attributes[<span class=\"string\">'onload'</span>];</span><br></pre></td></tr></table></figure></p>\n<p>The values obtained when you idnex the <code>attributes</code> object are Attr objects. </p>\n<h2 id=\"Element-Content\"><a href=\"#Element-Content\" class=\"headerlink\" title=\"Element Content\"></a>Element Content</h2><p>What is the ‘content’ of the <code>&lt;p&gt;</code> element? There are three ways we might answer this question: </p>\n<ul>\n<li>The content is the HTML string “This is a <i> simple </i> document.”</li>\n<li>The content is the plain-text string “This is a simple document”</li>\n<li>The content is a Text node, an Element node that has a Text node child, and another Text node. </li>\n</ul>\n<p>Each of these are valid answers, and each answer is useful in its own way. </p>\n<h3 id=\"Element-Content-As-HTML\"><a href=\"#Element-Content-As-HTML\" class=\"headerlink\" title=\"Element Content As HTML\"></a>Element Content As HTML</h3><p>Reading the <code>innerHTML</code> property of an Element returns the content of that element as a string of markup. Setting this property on an element invokes the web browser’s parser and replaces the element’s current content with a parsed representation of the new string. <br></p>\n<p>Web browsers are very good at parsing HTML and setting <code>innerHTML</code> is usually fairly efficient, even though the value you specify must be parsed. Note, however, that repeatedly appending bits of text to the <code>innerHTML</code> property with the <code>+=</code> operator is usually not efficient because it requires both a serialization step and a parsing step. <br></p>\n<p>HTML5 also standardizes a property named <code>outerHTML</code>. When you query <code>outerHTML</code>, the string of HTML or XML markup that is returned includes the opening and closing tags of the element on which you queried it. <code>outerHTML</code> is defined only for Element nodes, not Documents. <br></p>\n<p>Another feature standardized by HTML5 is the <code>insertAdjacentHTML()</code> mehtod, which allows you to insert a string of arbitrary HTML arkup ‘adjacent’ to the specified element. The markup is passed as the second argument to this method, and the precise meaning of ‘adjacent’ depends on the value of the first argument. This first argument should be a string with one of the values ‘beforebegin’, ‘afterbegin’, ‘beforeend’ or ‘afterend’. </p>\n<p><img src=\"../images/insertion_points.png\" alt=\"insertion_points\"></p>\n<h3 id=\"Element-content-as-plain-text\"><a href=\"#Element-content-as-plain-text\" class=\"headerlink\" title=\"Element content as plain text\"></a>Element content as plain text</h3><p>Sometimes you want to query the content of an element as plain text, or to insert plain text into a document (without having to escape the angle brackets and ampersands used in HTML markup). The standard way to do this is with the <code>textContent</code> property of Node. <br></p>\n<p>Inline <code>&lt;script&gt;</code> elements (those that do not have a <code>src</code> attribute ) have a <code>text</code> property that you can use to retrieve their text. The content of a <code>&lt;script&gt;</code> element is never displayed by the browser, and the HTML parser ignores angle brackets and ampersands within a script. This makes a <code>&lt;script&gt;</code> element an ideal place to embed arbitrary textual data for use by your application. Simply set the <code>type</code> attribute of the element to some value (such as ‘text/x-custom-data’) that makes it clear that the script is not executable JS code. If you do this JS interpreter will ignore the script, but element will exist in the document tree and its <code>text</code> property will return the data to you.</p>\n<h3 id=\"Element-Content-As-Text-Nodes\"><a href=\"#Element-Content-As-Text-Nodes\" class=\"headerlink\" title=\"Element Content As Text Nodes\"></a>Element Content As Text Nodes</h3><p>Another way to work with the content of an element is as a list of child nodes, each of which may have its won set of children. When thinking about element content, it is usually the Text nodes that are of interest. The example below shows a <code>textContent()</code> function that recursively traverses the children of an element and concatenates the text of all the Text node descendants. In order to understand the code, recall that the <code>nodeValue</code> property holds the content of a Text node. </p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Finding all Text node descendants of an element</span></span><br><span class=\"line\"><span class=\"comment\">// Return the plain-text content of element e, recursing into child elements</span></span><br><span class=\"line\"><span class=\"comment\">// This method works like the textContent property</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">textContent</span>(<span class=\"params\">e</span>)  </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> child,type, s= <span class=\"string\">''</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> ( child = e.firstChild; child != <span class=\"literal\">null</span>; child = child.nextSibling ) &#123;</span><br><span class=\"line\">        type = child.nodeType;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>( type === <span class=\"number\">3</span> || type === <span class=\"number\">4</span> )</span><br><span class=\"line\">            s += child.nodeValue;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> ( type === <span class=\"number\">1</span> )</span><br><span class=\"line\">            s += textContent(child);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> s;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>The <code>nodeValue</code> property is read/write and you can set it to change the content displayed by a Text or CDATASection node. Both Text and CDATASection are subtypes of CharacterData. CharacterData defines a <code>data</code> property, which is the same text as <code>nodeValue</code>.</p>\n<h2 id=\"Creating-Inserting-and-Deleting-Nodes\"><a href=\"#Creating-Inserting-and-Deleting-Nodes\" class=\"headerlink\" title=\"Creating, Inserting and Deleting Nodes\"></a>Creating, Inserting and Deleting Nodes</h2><p>The Document type defines methods for creating Element and Text objects, and the Node type defines methods for inserting, deleting, and replacing nodes in the tree.  <br></p>\n<h3 id=\"Creating-Nodes\"><a href=\"#Creating-Nodes\" class=\"headerlink\" title=\"Creating Nodes\"></a>Creating Nodes</h3><p>You can create new Element nodes with the <code>createElement()</code> method of the Document object. Pass the tag name of the element as the method argument: this name is case-insensitive for HTML documents and case-sensitive for XML documents.<br><br>Text nodes are created with a similar method:<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> newnode = <span class=\"built_in\">document</span>.createTextNode(<span class=\"string\">\"text node content\"</span>);</span><br></pre></td></tr></table></figure></p>\n<p>When working with documents that use XML namespaces, you can use <code>createElementNS()</code> to specify both the namespace URI and the tag name of the Element to be created. <br></p>\n<p>Everynode has a <code>cloneNode()</code> method that returns new copy of the node. Pass <code>true</code> to recursively copy all descendants as well, or <code>false</code> to only make a shallow copy. In browsers other than IE, the Document object also defines a similar method named <code>importNode()</code>. If you pass it a node from another document, it returns a copy suitable for insertion into this document. Pass <code>true</code> as the second argument to recursively import all descendants. </p>\n<h3 id=\"Inserting-Nodes\"><a href=\"#Inserting-Nodes\" class=\"headerlink\" title=\"Inserting Nodes\"></a>Inserting Nodes</h3><p>Once you have a new node, you can insert it into the document with the Node methods <code>appendChild()</code> or <code>insertBefore()</code>. <code>appendChild()</code> is invoked on the Element node that you want to insert into, and it inserts the specified node so that it becomes the <code>lastChild</code> of the node. <br></p>\n<p><code>insertBefore()</code> is like <code>appendChild()</code>, but it takes two arguments. The first argument is the node to be inserted. the second argument is the node before which that node is to be inserted. this methods is invoked on the node that will be the parent of the new node, and the second argument must be a child of that parent node. If you pass <code>null</code> as that second argument, the <code>insertBefore()</code> behaves like <code>appendChild()</code> and inserts at the end. <br></p>\n<p>If you call <code>appendChild()</code> or <code>insertBefore()</code> to insert a node that is already in the document, that node will automatically be removed from its current position and reinserted as its new position: there is no need to explicitly remove the node. </p>\n<h3 id=\"Removing-and-Replacing-nodes\"><a href=\"#Removing-and-Replacing-nodes\" class=\"headerlink\" title=\"Removing and Replacing nodes\"></a>Removing and Replacing nodes</h3><p>The <code>removeChild()</code> method removes a node from the document tree. Be careful, however: this method isn’t invoked on the node to be removed but on the parent of that node. Invoke the method on the parent node and pass the child node that is to be remoevd as the method argument. To remove the node <code>n</code> from the document, you’d write:<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">n.parentNode.removeChild(n);</span><br></pre></td></tr></table></figure></p>\n<p><code>replaceChild()</code> removes one child node and replaces it with a new one. Invoke this method on the parent node, passing the new node as the first argument and the node to be replaced as the second argument. </p>\n<h3 id=\"Using-DocumentFragments\"><a href=\"#Using-DocumentFragments\" class=\"headerlink\" title=\"Using DocumentFragments\"></a>Using DocumentFragments</h3><p>A DocumentFragment is a special kind of Node that serves as a temporary container for other nodes. Create a DocumentFragment like this:<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> frag = <span class=\"built_in\">document</span>.createDocumentFragment();</span><br></pre></td></tr></table></figure></p>\n<p>Like a Document node, a DocumentFragment stands alone and is not part of any other document. Its <code>parentNode</code> is always <code>null</code>. Like an Element, however, a DocumentFragment can have any number of children, which you can manipulate with <code>appendChild()</code>, <code>insertBefore()</code>  and so on. <br></p>\n<p>The special thing about DocumentFragment is that it allows a set of nodes to be treated as a single node: if you pass a DocumentFragment to <code>appendChild()</code>, <code>insertBefore()</code>, or <code>replaceChild()</code>, it is the children of the fragment that are inserted into the document, not the fragment itself. (The children are moved from the fragment into the document, and the fragment becomes empty and ready for reuse.)</p>\n<h2 id=\"Document-and-Element-Geometry-and-Scrolling\"><a href=\"#Document-and-Element-Geometry-and-Scrolling\" class=\"headerlink\" title=\"Document and Element Geometry and Scrolling\"></a>Document and Element Geometry and Scrolling</h2><p>When a browser renders a document within a window, it creates a visual representation of the document in which each element has a position and a size. </p>\n<h3 id=\"Document-Coordinates-and-Viewport-Coordinates\"><a href=\"#Document-Coordinates-and-Viewport-Coordinates\" class=\"headerlink\" title=\"Document Coordinates and Viewport Coordinates\"></a>Document Coordinates and Viewport Coordinates</h3><p>The position of an element is measured in pixels, with the X coordinate increasing to the right and the Y coordinate increasing as we go down. There are two different points we wcan use as teh coordinate system origin, however: the X and Y coordinates of an element ca nbe relative to the top-left corner of the document or relative to the top-left corner of the <strong>viewport</strong> in which the document is displayed. In top-level windows and tabs, the “viewport” is the portion of the browser that actually displays document content: it excludes browser “chrome” such as menus, toolbars, and tabs. For documents displayed in frames, the viewport is the <code>&lt;iframe&gt;</code> element that defines the frame. In either case, when we talk about the position of an element, we must be clear whether we are using document coordinates or viewport coordinates. (Note that viewport coordinates are sometimes called window coordinates.) <br></p>\n<p>If the document is smaller than the viewport, or if it has not been scrolled, the upper-left corner of the document is in the upper-left corner of the viewport and the document and viewport coordinates systems are the same. In general, however, to convert between the two coordinate systems, we must add or subtract the <strong>scroll offsets</strong>. If an element has a Y coordinate of 200 pixels in document coordinates, for example, and if the user has scrolled the browser down by 75 pixels, then that element has a Y coordinate of 125 pixels in viewport coordinates. Similarly, if an element has an X coordinate of 400 in viewport coordinates and the use has scrolled the viewport 200 pixels horizontally, the element’s X coordinate in document coordinates is 600. <br></p>\n<p>Document coordinates are more fundamental than viewport coordinates, and they do not change when the user scrolls. We use document coordinates when we specify an element position using CSS. But the simplest way of querying the position of an element returns the position in viewport coordiantes. When we register handler functions for mouse events, the coordinates of the mouse pointer are reported in viewport coordinates. <br></p>\n<p>In order to convert between coordiante systems, we need to be able to determine the scrollbar positions for the browser window. The <code>pageXOffset</code> and <code>pageYOffset</code> properties of the Window object porvide these values. IE and all modern browsers also make the scrollbar positions available through <code>scrollLeft</code> and <code>scrollTop</code> properties. </p>\n<h3 id=\"Querying-the-Geometry-of-an-Element\"><a href=\"#Querying-the-Geometry-of-an-Element\" class=\"headerlink\" title=\"Querying the Geometry of an Element\"></a>Querying the Geometry of an Element</h3><p>The easiest way to determine the size and position of an element is to call its <code>getBoundingClientRect()</code> method. It expects no arguments and returns an object with properties <code>left</code>, <code>right</code>, <code>top</code>, and <code>bottom</code>. The <code>left</code> and <code>top</code> properties give the X and Y coordinates of the upper-left corner of the element and the <code>right</code> and <code>bottom</code> properties give the coordinates of the low-right corner. <br></p>\n<p>To convert to document coordinate that remain valid event if the user scroll the browser window, add the scroll offsets:<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> box = e.getBoundingClientRect();</span><br><span class=\"line\"><span class=\"keyword\">var</span> offsets = getScrollOffsets();</span><br><span class=\"line\"><span class=\"keyword\">var</span> x = box.left + offsets.x;</span><br><span class=\"line\"><span class=\"keyword\">var</span> y = box.top + offsets.y;</span><br></pre></td></tr></table></figure></p>\n<p>The content of an element is surrounded by an optional blank area known as padding. The padding is surrounded by an optional border, and the border is surrounded by optional margins. The coordinates returned by <code>getBoudningClientRect()</code> include the border and the padding of the element but do not include the element margins. <br></p>\n<p>If the word <code>Cilent</code> is the method <code>getBoundingClientRect()</code> specifies the coordinate system of the return rectangle, what explains the word ‘bounding’ in the method name? Block elements, such as images, paragraphs, and <code>&lt;div&gt;</code> elements are always rectangular when laid out by the browser. Inline elemetns, such as <code>&lt;span&gt;</code>, <code>&lt;code&gt;</code>, and <code>&lt;b&gt;</code> elements, however, may span multiple lines and may therefore consist of multiple rectangles. Imagine, for example, some italicized text that is broken across two lines. Its rectangles consist of the right-hand portion of the first line and the left-hand portion of the second line. If you call <code>getBoundingClientRect()</code> on the inline element, it returns the “bounding rectangle” of the individual rectangles. For <code>&lt;i&gt;</code> element described above, the bounding rectangle would include the entire width of both lines. <br></p>\n<p>If you want to query the individual rectangles of inline elements, call the <code>getClientRects()</code> method to obtain a read-only array-like objects like those returned by <code>getBoundingClientRect()</code>. <br></p>\n<p>The rectangle objects (and rectangle object lists) returned by <code>getBoundingClientRect()</code> and <code>getClientRects()</code> are not live. They are static snapshots of the visual state of document when the method are called. They are not updated  when the user scrolls or resizes the browser window. <br></p>\n<h3 id=\"Determining-the-Element-at-a-Point\"><a href=\"#Determining-the-Element-at-a-Point\" class=\"headerlink\" title=\"Determining the Element at a Point\"></a>Determining the Element at a Point</h3><p>Sometimes we want to go in the other direction and determine which element is at a given location in the viewport. You can use <code>elementFromPoint()</code>. Pass X and Y coordinates (using viewport coordinates, not document coordinates) and this method returns an Element object that is at the specified position. The intent of this method is that it returns the innermost and uppermost element at that point. if you specify a point that is outside of the viewport, <code>elementFromPoint()</code> will return <code>null</code> even if that point would be perfectly valid when converted to document coordinates. </p>\n<h3 id=\"Scrolling\"><a href=\"#Scrolling\" class=\"headerlink\" title=\"Scrolling\"></a>Scrolling</h3><p>The <code>scrollTo()</code> method of the Window object(and its synonym <code>scroll()</code>) takes the X and Y coordinates of a point and sets these as the scrollbar offsets. That is, it scrolls the window so that the specified point is in the upper left corner of the viewport. If you specify a point that is too close to the bottom or too close to the right edge of the document, the browser will move it as close as possible to the upper left corner but won’t be able to get it all the way there. To see the bottom-most page of the document:<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// get the height of the document and viewport. </span></span><br><span class=\"line\"><span class=\"keyword\">var</span> documentHeight = <span class=\"built_in\">document</span>.documentElement.offsetHeight;</span><br><span class=\"line\"><span class=\"keyword\">var</span> viewportHeight = <span class=\"built_in\">window</span>.innerHeight; <span class=\"comment\">// or use getViewportSize()</span></span><br><span class=\"line\"><span class=\"built_in\">window</span>.scrollTo(<span class=\"number\">0</span>, documentHeight - viewportHeight);</span><br></pre></td></tr></table></figure></p>\n<p>Often, instead of scrolling to a numeric location in document, we just want to scroll so that a certain element in the document is visible. It is easier to just call the <code>scrollIntoView()</code> method on the desired HTML element. this method ensures that the element on which it is invoked is visible in the viewport. By default, it tries to put the top edge of the element at or near the top of the viewport. If you pass <code>false</code> as the only argument, it will try to put the bottom edge of the element at the bottom of the viewport. <br></p>\n<p>The behavior of <code>scrollIntoView()</code> is similar to what the browser does when you set <code>window.location.hash</code> to the name of a named anchor <code>&lt;a name=&quot;&quot;&gt;</code> element</p>\n<h3 id=\"More-on-Element-Size-Position-and-Overflow\"><a href=\"#More-on-Element-Size-Position-and-Overflow\" class=\"headerlink\" title=\"More on Element Size, Position and Overflow\"></a>More on Element Size, Position and Overflow</h3><p>All HTML elements have <code>offsetLeft</code> and <code>offsetTop</code> properties that return the X and Y coordinates of the element. For many elements, these values are document coordinates and directly specify the position of the element. But for descendants of positioned elements and for some other elements, such as table cells, these properties return coordinates that are relative to an ancestor element rather than the document. The <code>offsetParent</code> property specifies which element the properties are relative to. If <code>offsetParent</code> is null, the properties are document coordiantes. In general, therefore, computing the position of an element <code>e</code> using <code>offsetLeft</code> and <code>offsetTop</code> requires a loop.<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getElementPosition</span>(<span class=\"params\">e</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> x = <span class=\"number\">0</span>, y = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(e != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">        x += e.offsetLeft;</span><br><span class=\"line\">        y += e.offsetTop;</span><br><span class=\"line\">        e = e.offsetPrent;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> &#123; x, y &#125;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>By looping through the <code>offsetParent</code> chain and accumulating offsets, this function computes the document coordinates of the specified element. <br><br>In addtion to the set of <code>offset</code> properties, all document elements define two other sets of properties, one whose names begin with <code>client</code> and one whose names begin with <code>scroll</code>. <br><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">offsetWidth, -Height, -Left, -Top</span><br><span class=\"line\">scrollWidth, -Height, -Left, -Top</span><br><span class=\"line\">clientWidth, -Height, -Left, -Top</span><br></pre></td></tr></table></figure></p>\n<p>In order to understand the <code>client</code> and <code>scroll</code>, you need to know that the content of an HTML element may be larger than the content box allocated to hold that content, and that therefore individual elements may have scrollbars. The content area is a viewport, like the browser window is, and when the content is larger than the viewport, we need to take an element’s scroll bar position into account. <br></p>\n<p><code>clientWidth</code> and <code>clientHeight</code> are like <code>offsetWidth</code> and <code>offsetHeight</code> except that they do not include the border size, only the content area and its padding. Also, if the browser has added scrollbars between the padding and the borser, <code>clientWidth</code> and <code>clientHeight</code> do not include the scrollbar in their returned value. Note that <code>clientWidth</code> and <code>clientHeight</code> always return 0 for inline elements like <code>&lt;i&gt;</code>, <code>&lt;code&gt;</code> and <code>&lt;span&gt;</code>. <br></p>\n<p>The <code>clientLeft</code> and <code>clientTop</code> properties are not very useful: they return the horizontal and vertical distance between the outside of an element’s padding and the outside of its border. Usually these values are just the width of the left and top borders. If an element has scrollbars, however, and if the browser places those scrollbars on the left or top, <code>clientLeft</code> and <code>clientTop</code> also include the scrollbar width. For inline elements, <code>clientLeft</code> and <code>clientTop</code> are always 0. <br></p>\n<p><code>scrollWidth</code> and <code>scrollHeight</code> are the size of the element’s content area plus its padding plus any overflowing content. When the content fits within the content area without overflow, these properties are the same as <code>clientWidth</code> and <code>clientHeight</code>. But when there is overflow, they include the overflowing content and return values larger than <code>clientWidth</code> and <code>clientHeight</code>. <br></p>\n<p>Finally, <code>scrollLeft</code> and <code>scrollTop</code> give the scrollbar positions of an element. Note that <code>scrollLeft</code> and <code>scrollTop</code> are writable properties and you can set them to scroll the content within an element. <br></p>\n<p>When a document contains scrollable elements with overflowing content, the <code>getElementPosition()</code> method defined aboved does not work correctly since it does not take scrollbar position into account. <br></p>\n<h2 id=\"HTML-Forms\"><a href=\"#HTML-Forms\" class=\"headerlink\" title=\"HTML Forms\"></a>HTML Forms</h2><p>The HTML <code>&lt;form&gt;</code> element, and the various form input elements, such as <code>&lt;input&gt;</code>, <code>&lt;select&gt;</code> and <code>&lt;button&gt;</code>, have an important place in client-side programming. HTML forms are the mechanism behind the first generation of web applications, which required no JS at all. User input is gathered in form elements; form submission sends that input to the server; the server processes the input and generates a new HTML page (usually with new form elements) for display by the client. <br></p>\n<p>Server-side programs are based on form submissions - they process data in form-sized chunks - and this limits their interactivity. Client-side programs are event based - they can respond to events on individual form elements. Or it might respond to a click on a checkbox by enabling a set of options that are only meaningful when that box is checked.<br><img src=\"../images/form_elements1.png\" alt=\"form_elements1\"><br><img src=\"../images/form_elements2.png\" alt=\"form_elements2\"></p>\n<h3 id=\"Selecting-Forms-and-Form-Elements\"><a href=\"#Selecting-Forms-and-Form-Elements\" class=\"headerlink\" title=\"Selecting Forms and Form Elements\"></a>Selecting Forms and Form Elements</h3><p>Forms and the elements they contain can be selected from a document using standard methods like <code>getElementById()</code> and <code>getElementByTagName()</code>:<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> fields = <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">'address'</span>).getElementByTagName(<span class=\"string\">'input'</span>);</span><br></pre></td></tr></table></figure></p>\n<p>This can also be done using <code>querySelectorAll()</code>. <br><br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">document</span>.querySelectorAll(<span class=\"string\">`#shipping input[type='radio']`</span>);</span><br><span class=\"line\"><span class=\"built_in\">document</span>.querySelectorAll(<span class=\"string\">`#shipping input[type='radio'][name='method']`</span>);</span><br></pre></td></tr></table></figure></p>\n<p>However, a <code>&lt;form&gt;</code> with a <code>name</code> or <code>id</code> attribute can be selected in a number of other ways. A <code>&lt;form&gt;</code> with a <code>name=&#39;address&#39;</code> attribute can be selected in any of these ways.<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">window</span>.address</span><br><span class=\"line\"><span class=\"built_in\">document</span>.address</span><br><span class=\"line\"><span class=\"built_in\">document</span>.forms.address</span><br><span class=\"line\"><span class=\"built_in\">document</span>.forms[n]</span><br></pre></td></tr></table></figure></p>\n<p><code>document.forms</code> is an HTMLCollection object that allows form elements to be selected by numerical order, by <code>id</code> or by <code>name</code>. Form objects themselves act like HTMLCollections of form elements and can be indexed by name or number. If a from with name <code>address</code> has a first element with the name <code>street</code>, you can refer to that form elements with any of these expressions:<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">document</span>.forms.address[<span class=\"number\">0</span>]</span><br><span class=\"line\"><span class=\"built_in\">document</span>.forms.address.street</span><br><span class=\"line\"><span class=\"built_in\">document</span>.address.street</span><br></pre></td></tr></table></figure></p>\n<p>If you want to be explicit about selecting a form element, you can index the <code>elements</code> property of the form object instead:<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">document</span>.forms.address.elements[<span class=\"number\">0</span>]</span><br><span class=\"line\"><span class=\"built_in\">document</span>.forms.address.elements.street</span><br></pre></td></tr></table></figure></p>\n<p>The <code>id</code> attribute is generally preferred way to name specific document elements. The <code>name</code> attribute, however, has a special purpose for HTML form submission, and is much more commonly used with forms than with other elements. It is typical for groups of related checkboxes and mandatory for mutually exclusive groups of radioboxes to share a value of the <code>name</code> attribute. Remember that when you index an HTMLCollection with a name and more than one element shares that name, the returned value is an array-like object that contains all matching elements. <br></p>\n<p>Note that <code>&lt;form&gt;</code> elements have an HTML attribute and corresponding JS property named <code>method</code>, so in this case, we must use the <code>elements</code> property of the form instead of directly accessing the <code>method</code> property. </p>\n<h3 id=\"Form-and-Element-Properties\"><a href=\"#Form-and-Element-Properties\" class=\"headerlink\" title=\"Form and Element Properties\"></a>Form and Element Properties</h3><p>The <code>elements[]</code> array described above is the most interesting property of a Form object. The <code>action</code>, <code>encoding</code>, <code>method</code>, and <code>target</code> properties correspond directly to the <code>action</code>, <code>encoding</code>, <code>method</code> and <code>target</code> attributes of the <code>&lt;form&gt;</code> element. These properties and a ttributes are all used to control how form data is submitted to the web server and where the results are displayed. <br></p>\n<p>The JS form object supports two methods, <code>submit()</code> and <code>reset()</code>. All form elements also have the following properties in common. Some elements have other special-purpose properties that are described later when various types of form elements are considered individually:<br><strong>type</strong>: For form elements that are defined by an <code>&lt;input&gt;</code> tag, this is simply the value of the <code>type</code> attribute. Other form elements define a <code>type</code> property so that they can easily be idetified by the same test that distinguishes between <code>&lt;input&gt;</code> elements.<br><strong>form</strong>: a read only reference to the Form object in which the element is contained or <code>null</code> if the element is not contained within a <code>&lt;form&gt;</code> element.<br><strong>name</strong>: HTML <code>name</code> attribute.<br><strong>value</strong>: This is the string that is sent to the web server when the form is submitted, and it is only sometimes of interest to JS programs. For Text and Textarea elements, this property contains the text that the user entered. For button elements created with an <code>&lt;input&gt;</code> tag this property specifies the text displayed within the button. For radio and checkbox elements, however, the <code>value</code> property is not edited or displayed to the user in any way. It is intended for use in form submission, but it can be a useful way to associate extra data with a form element. </p>\n<h3 id=\"Form-and-Element-Event-Handlers\"><a href=\"#Form-and-Element-Event-Handlers\" class=\"headerlink\" title=\"Form and Element Event Handlers\"></a>Form and Element Event Handlers</h3><p>Each form element has an <code>onsubmit</code> event handler to detect form submission and an <code>onreset</code> event handler to detect form resets. The <code>onsubmit</code> event handler is invoked just before the form is submitted; it can cancel the submission by returning false. This provides an opportunity for a JS program to check the user’s input for errors in order to avoid submitting incomplete or invalid data over the network to a server-side program. Note that the <code>onsubmit</code> handler is triggered only by a genuine click on a Submit button. Calling the <code>submit()</code> method of a form does not trigger the <code>onsubmit</code> handler. <br><br>The <code>onreset</code> event handler is invoked just before the form is reset, and it can prevent the form elements from being reset by returning <code>false</code>. Reset buttons are rarely necessary in forms.</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">form</span> <span class=\"attr\">...</span> <span class=\"attr\">onrest</span> =<span class=\"string\">\"return confirm('Really erase ALL input and start over?')\"</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">button</span> <span class=\"attr\">type</span>=<span class=\"string\">'reset'</span>&gt;</span>Clear and Start over <span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">form</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>Like the <code>onsubmit</code> handler, <code>onreset</code> is triggered only by a genuie Reset button. Calling the <code>reset</code> method of a form does not trigger <code>onreset</code>.</p>\n<p>Form elements typically fire a click or change event when the user interacts with them, and you can handle these events by defining an <code>onclick</code> or <code>onchange</code> event handler. In general form elements that are buttons fire a click event when activated. Other form elements fire a change event when the user changes the value represented by the element. This happens when the user enters text in a text field or selects an option from a drop-down list. Note that this event is not fired every time the user types a key in a text field. It is fired only when the user changes the value of an element and then moves the input focus to some other form element. That is, the invocation of this event handler indicates a completed change. Radio buttons and checkboxes are buttons that have a state, and they fire both click and change events; the <code>change</code> event is the more useful of the two. <br></p>\n<p>Form elements also fire a <code>focus</code> event when they receive keyboard focus and a <code>blur</code> event when they lose it. <br></p>\n<p>An important thing to know about event handlers is that within the code of an event handler, the <code>this</code> keyword refers to the document element that triggered the event. Since elements within a <code>form</code> element have a <code>form</code> property that refers to the containing form, the event handlers of these elements can always refer to the Form object as <code>this.form</code>. This means that an event handler for one form element can refer to a sibling form element named <code>x</code> as <code>this.form.x</code>.</p>\n<h3 id=\"Push-Buttons\"><a href=\"#Push-Buttons\" class=\"headerlink\" title=\"Push Buttons\"></a>Push Buttons</h3><p>Submit and reset elements are just like button elements, but they have default actions (submitting and resetting a form) associated with them. <br></p>\n<h3 id=\"Toggle-Buttons\"><a href=\"#Toggle-Buttons\" class=\"headerlink\" title=\"Toggle Buttons\"></a>Toggle Buttons</h3><p>The checkbox and radio elements are toggle buttons, or buttons that have two visually distinct states: they can be checked or unchecked. Radio elements are designed to be used in groups of related elements, all of which have the same value for the HTML <code>name</code> attribute. Radio elements created in this way are mutually exclusive: when you check one, the one that was previously checked becomes unchecked. Checkboxes are also often used in groups that share a <code>name</code> attribute, and when you select these elements using the name as a form property you must remember that you get an array-like object rather than a single element. <br></p>\n<p>Radio and checkbox elements both define a <code>checked</code> property. This read/write boolean value specifies whether the element is currently checked. The <code>defaultChecked</code> property is a boolean that has the value of the HTML <code>checked</code> attribute; it specifies whether the element is checked when the page is first loaded. <br></p>\n<p>Radio and checkbox elements do not display any text themselves and are typically displayed with adjacent HTML text (or with an associated <code>&lt;label&gt;</code> element.) This means that setting the <code>value</code> property of a checkbox or radio element does not alter the visual appearance of the element. You can set <code>value</code>, but this changes only the string that is sent to the web server when the form is submitted. <br></p>\n<p>When the user clicks on a toggle button, the radio or checkbox element triggers its <code>onclick</code> handlers. If the toggle button changes state as the result of the click, it also triggers the <code>onchange</code> event handlers. ( Note, however, the radio buttons that change state when the user clicks on a different radio button do not fire an <code>onchange</code> handler. )</p>\n<h3 id=\"Text-Fields\"><a href=\"#Text-Fields\" class=\"headerlink\" title=\"Text Fields\"></a>Text Fields</h3><p>The <code>value</code> property represents the text the user has entered. You can set this property to specify explicitly the text that should be displayed in the field. <br></p>\n<p>The <code>placeholder</code> attribute specifies a propmpt to be displayed within the field before the user enters anything. <br></p>\n<p>A text field’s <code>onchange</code> event handler is triggered when the user enters new text or edits existing text and then indicates that he is finished by moving input focus out of the text field. <br></p>\n<p>You can use the <code>value</code> property and <code>onchange</code> event handler of a Textarea element just as you can for a Text element. <br></p>\n<p>An <code>&lt;input type=&quot;password&quot;&gt;</code> element is a modified input field that displays asterisks as the user types into it. <br></p>\n<p>Finally, an <code>&lt;input type=&quot;file&quot;&gt;</code> element allows the user to enter the name of a file to be uploaded to the web server. </p>\n<h3 id=\"Select-and-Option-elements\"><a href=\"#Select-and-Option-elements\" class=\"headerlink\" title=\"Select and Option elements\"></a>Select and Option elements</h3><p>The Select element represents a set of options (represented by Option elements) from which the user can select. Browsers typically render Select elements in drop-down menus, but if you specify a <code>size</code> attribute with a value greater than 1, they will display the options in a (possibly scrollable) list instead. If the <code>&lt;select&gt;</code> element has the <code>multiple</code> attribute, the user is allowed to select multiple options, and the <code>type</code> property of the Select object is ‘select-multiple’. <br></p>\n<p>In some ways, a select-multiple element is like a set of checkbox elements, and a select-one element is like a set of radio elements. The options displayed by a Select element are not toggle buttons, however: they are defined by <code>&lt;option&gt;</code> elements instead. <br></p>\n<p>When the user selects or deselects an option, the Select element triggers its <code>onchange</code> event handler. For select-one Select elements, the read/write <code>selectedIndex</code> property specifies which one of the options is currently selected. To determine which options are selected, you must loop through the elements of the <code>options[]</code> array and check the value of the <code>selected</code> property for each Option object. <br></p>\n<p>In addition to its <code>selected</code> property, each Option object has a <code>text</code> property that specifies the string of plain text that appears in the Select element for that option. The <code>value</code> property is also a read/write string that specifies the text to be sent to the web server when the form is submitted. Note that Option element do not have form-related event handlers: use the <code>onchange</code> handler of hte containing Select element instead. <br></p>\n<p>You can truncate the array of Option elements by setting <code>options.length</code> to the desired number of options, and you can remove all Option objects by setting <code>options.length</code> to 0. You can remove an individual Option object from the Select element by setting its spot in the <code>options[]</code> array to <code>null</code>. This deletes the Option object, and any higher elements in the <code>options[]</code> array automatically get moved down to fill the empty spot. <br></p>\n<p>To add new options to a Select element, create an Option object with the <code>Option()</code> constructor and append it to the <code>options[]</code> property with code like this.<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> zaire = <span class=\"keyword\">new</span> Option(<span class=\"string\">'Zaire'</span>,  <span class=\"comment\">// text property</span></span><br><span class=\"line\">                       <span class=\"string\">'zaire'</span>,  <span class=\"comment\">// value property</span></span><br><span class=\"line\">                        <span class=\"literal\">false</span>, <span class=\"comment\">// defaultSelected property</span></span><br><span class=\"line\">                        <span class=\"literal\">false</span>); <span class=\"comment\">// selected property</span></span><br></pre></td></tr></table></figure></p>\n<h2 id=\"Other-Document-Features\"><a href=\"#Other-Document-Features\" class=\"headerlink\" title=\"Other Document Features\"></a>Other Document Features</h2><h3 id=\"Document-Properties\"><a href=\"#Document-Properties\" class=\"headerlink\" title=\"Document Properties\"></a>Document Properties</h3><ul>\n<li><code>cookie</code></li>\n<li><code>domain</code>: A property that allows mutually trusted web servers within the same Internet domain to collaboratively relax same-origin policy security restrictions on interactions between their web pages. </li>\n<li><code>lastModified</code>: A string that contains the modification date of the document.</li>\n<li><code>location</code>: This property refers to the same Location object as the <code>location</code> property of the Window object.</li>\n<li><code>referrer</code>: The URL of the document containing the link, if any, that brought the browser to the current document. This property has the same content as the HTTP <code>Referer</code> header, but it is spelled with a double r.</li>\n<li><code>title</code>: The text between the <code>&lt;title&gt;</code> and <code>&lt;title&gt;</code> tags for this document.</li>\n<li><code>URL</code>: The URL of the document as a read-only String rather than as a Location object. The value of this proeprty is te same as the initial value of <code>location.href</code>, but it is not dynamic like the Location object is. If the user navigates to a new fragment identifier within the document, for example, <code>location.href</code> will change, but <code>document.URL</code> will not. </li>\n</ul>\n<p><code>referrer</code> is one of the most intersting of these properties: it contains the URL of the document from which the user linked to the current document. </p>\n<h3 id=\"The-document-write-Method\"><a href=\"#The-document-write-Method\" class=\"headerlink\" title=\"The document.write() Method\"></a>The document.write() Method</h3><p><code>document.write()</code> concatenates its string arguments and inserts the resulting string into the document at the location of the script element that invoked it.<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\">    <span class=\"built_in\">document</span>.write(<span class=\"string\">\"&lt;br&gt; URL: \"</span> + <span class=\"built_in\">document</span>.URL);</span><br><span class=\"line\">    <span class=\"built_in\">document</span>.write(<span class=\"string\">\"Referred by: \"</span> + <span class=\"built_in\">document</span>.referrer);</span><br><span class=\"line\">&lt;<span class=\"regexp\">/script&gt;</span></span><br></pre></td></tr></table></figure></p>\n<p>It is important to understand that you can use the <code>write()</code> method to output HTML to the current document only while that document is being parsed. That is, you can call <code>document.write()</code><br>from within top-level code in <code>&lt;script&gt;</code> elements only because these scripts are executed as part of the document parsing process. If you place a <code>document.write()</code> call within a function definition and then call that function from an event handler, it will not work as you expect - in fact, it will erase the current document and the script it contains. For similar reasons, you should not use <code>document.write()</code> in scripts that have the <code>defer</code> or <code>async</code> attributes set. <br></p>\n<p>You can also use <code>write()</code> method to create entirely new documents in other windows of frames. Your first call to the <code>write()</code> method of another document will erase all content in that document. <br></p>\n<p>It is worth noting that the Document object also supports a <code>writeln()</code> method, which is identical to the <code>write()</code> method in every way except that it appends a newline after outputting it arguments. This can be useful it you are outputting preformatted text within a <code>&lt;pre&gt;</code> element. </p>\n<h3 id=\"Querying-Selected-Text\"><a href=\"#Querying-Selected-Text\" class=\"headerlink\" title=\"Querying Selected Text\"></a>Querying Selected Text</h3><p>It is sometimes useful to be able to determine what text the user has selected within a document.<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getSelectedText</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"built_in\">window</span>.getSelection)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">window</span>.getSelection().toString();</span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (<span class=\"built_in\">document</span>.selection)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">document</span>.selection.createRange().text;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>The standard <code>window.getSelection()</code> method returns a Selection object that describes the current selection as a sequence of one or more Range objects.<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;a href=<span class=\"string\">'javascript: var q; if(window.getSelection) q=window.getSelection().toString(); else if (document.selection.createRange().text; void window.open(\"http://en.wikipedia.org/wiki/\"+q);'</span>&gt;</span><br><span class=\"line\">Look Up Selected Text In Wikipeida</span><br><span class=\"line\">&lt;<span class=\"regexp\">/a&gt;</span></span><br></pre></td></tr></table></figure></p>\n<p>The <code>getSelection()</code> method of the Window object does not return selected text if it is within an <code>&lt;input&gt;</code> or <code>&lt;textarea&gt;</code> form element: it only returns text selected from the body of the document itself. To obtain the selected text from a text input field, use this code:<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">elt.value.substring(elt.selectionStart, ele.selectionEnd);</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"Editable-Content\"><a href=\"#Editable-Content\" class=\"headerlink\" title=\"Editable Content\"></a>Editable Content</h3><p>There are two ways to enable this editing functionality. Set the <code>contenteditable</code> HTML attribute of any tag or set the <code>contenteditable</code> JS property on the corresponding Element to make the content of that element editable.  <br><br>Add the <code>spellcheck</code> attribute to explicitly turn checking on in browsers that support it. And use <code>spellcheck=false</code> to explicitly disable checking. <br><br>You can also make an entire document editable by setting the <code>designMode</code> property of the Document to the string “on”. You might make the document within an <code>&lt;iframe&gt;</code> editable like this:<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">iframe</span> <span class=\"attr\">id</span>=<span class=\"string\">\"editor\"</span> <span class=\"attr\">src</span>=<span class=\"string\">\"about:blank\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">iframe</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span>&gt;</span><span class=\"undefined\"></span></span><br><span class=\"line\"><span class=\"javascript\">onLoad(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span></span><br><span class=\"line\"><span class=\"javascript\">    <span class=\"keyword\">var</span> editor= <span class=\"built_in\">document</span>.getElementeById(<span class=\"string\">\"editor\"</span>);</span></span><br><span class=\"line\"><span class=\"javascript\">    editor.contentDocument.designMode = <span class=\"string\">\"on\"</span>;</span></span><br><span class=\"line\"><span class=\"undefined\">&#125;);</span></span><br><span class=\"line\"><span class=\"undefined\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br></pre></td></tr></table></figure></p>\n<p>Browsers define a number of text-editing commands, most of which do not have key-board shortcuts to apply on selected text. To execute these commands, you instead use the <code>execCommand()</code> method of the Document object. Commands executed by <code>execCommand()</code> are named by strings such as<br>‘bold’, ‘subscript’, ‘justifycenter’ or ‘insertimage’. The command name is the first argument to <code>execCommand()</code>. Some commands require a value argument - ‘createlink’, for example, requires the hyperlink URL. In theory, if the second argument to <code>execCommand()</code> is <code>true</code>, the browser will automatically prompty the user for whatever value is required.<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">bold</span>(<span class=\"params\"></span>) </span>&#123; <span class=\"built_in\">document</span>.execCommand(<span class=\"string\">\"bold\"</span>, <span class=\"literal\">false</span>, <span class=\"literal\">null</span>); &#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">link</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> url = prompt(<span class=\"string\">\"enter link destination\"</span>);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (url) <span class=\"built_in\">document</span>.execCommand(<span class=\"string\">\"createLink\"</span>, <span class=\"literal\">false</span>, url);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>The commands supported by <code>execCommand()</code> are typically triggered by buttons in a toolbar. A good UI will disable buttons when the command they trigger is not available. Pass a command name to <code>document.queryCommandSupported()</code> to find out if it is supported by the browser. Call <code>document.queryCommandEnabled()</code> to find out if the command can currently be used. Use <code>document.queryCommandState()</code> to determine the current state of  a command that has a state such as ‘bold’. Finally, some commands, such as ‘fontname’, have an associated value. Query this value with <code>document.queryCommandValue()</code>.<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">bold              insertLineBreak          selectAll</span><br><span class=\"line\">createLink        insertOrderedList        subscript</span><br><span class=\"line\"><span class=\"keyword\">delete</span>            insertUnorderedList      superscript</span><br><span class=\"line\">formatBlock       insertParagraph          undo</span><br><span class=\"line\">forwardDelete     insertText               unlink</span><br><span class=\"line\">insertImage       italic                   unselect</span><br><span class=\"line\">insertHTML        redo</span><br></pre></td></tr></table></figure></p>\n<p>If you need rich-text editing functionality, you probably want to adopt a prebuilt solution that addresses the various differences between browsers. </p>\n","prev":{"title":"HTML notes","slug":"html-note"},"next":{"title":"Javascript: The Window Object","slug":"js-window-object"},"link":"https://whitefusion.github.io/post/js-scripting-windows"}