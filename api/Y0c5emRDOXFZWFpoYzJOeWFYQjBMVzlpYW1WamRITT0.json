{"title":"Javascript: Objects","date":"2018-07-27T14:31:56.000Z","excerpt":"","slug":"javascript-objects","comments":true,"tags":["javascript","note"],"categories":["language core"],"updated":"2018-07-28T05:46:05.215Z","content":"<blockquote>\n<p>This is the reading note for “Chapter 6: Objects, values and variables, Javascript: The definitive guide 5th edition”. <br></p>\n</blockquote>\n<p>Objects map strings to values. In addition to maintaining its own set of properties, a JS object also inherits the properties of another projects, known as its ‘prototype’. Objects can also be used (by ignoring the value part of the string-to-value mapping) to represent sets of strings. Any value in JS that is not a string, a number, boolean, <code>null</code> or <code>undefined</code> is an object. Even though strings, numbers and booleans are not objects, they behave like immutable objects. <br></p>\n<p>Objects are immutable and are manipulated by reference rather than by value. The most common things to do with objects are create them and to set, query, delete, test and enumerate their properties. <br></p>\n<p>A <em>property</em> has a name and a value. A property name may be any string, including the empty string, but no object may have two properties with the same name. The value simply evaluates to the last value if there are multiple properties with the same name defined. In addition to its name and value, each property has associated values that we’ll call <em>property attributes</em>:</p>\n<ul>\n<li>The <em>writable</em> attribute specifies whether the value of the property can be set.</li>\n<li>The <em>enumerable</em> attribute specifies whether the property name is returned by a <code>for/in</code> loop.</li>\n<li>The <em>configurable</em> attribute specifies whether the property can be deleted and whether its attributes can be altered.</li>\n</ul>\n<p>In addition to its properties, every object has three associated <em>object attributes</em> :</p>\n<ul>\n<li>An object’s <em>prototype</em> is a reference to another object from which properties are inherited. </li>\n<li>An object’s <em>class</em> is a string that categorizes the type of an object. </li>\n<li>An object’s <em>extensible</em> flag specifies whether new properties may be added to the object. </li>\n</ul>\n<p>Few terms:</p>\n<ul>\n<li>A <em>native object</em> is an object or class of objects defined by the ECMAScript specification. </li>\n<li>A <em>host object</em> is an object defined by the host environment (such as web browsere) within which the HS interpreter is embeded. The HTMLElement objects that represents the structure of a web page in client-side JS are host objects. Host objects may also be native object, as when the host environment defines methods that are normal JS Functions objects. </li>\n<li>A <em>user-defined</em> object is any object created by the execution of JS code.</li>\n<li>An <em>own property</em> is a property defined directly on an object. </li>\n<li>An <em>inherited property</em> is a property defined by an object’s prototype object. </li>\n</ul>\n<h2 id=\"Creating-Objects\"><a href=\"#Creating-Objects\" class=\"headerlink\" title=\"Creating Objects\"></a>Creating Objects</h2><p>Objects can be created with object literals, with the <code>new</code> keyword, and with the <code>Object.create()</code> function.<br>A property name is a JS identifier or a string literal. A property value is any JS expression ; the value of the expression becomes the value of the property. <br></p>\n<p>The <code>new</code> operator creates and initializes a new object. The <code>new</code> keyword must be followed by a function invocation. A function used in this way is called a <em>constructor</em> and serves to initialize a newly created object. Every JS object has a second JS object associated with it. The second object is known as a prototype, and the first object inherits properties from the prototype.  <br></p>\n<p>All objects created by object literals have the same prototype object, and we can refer to this prototype object in JS code as <code>Object.prototype</code>. Objects created using the <code>new</code> keyword and a constructor invocation use the value of the <code>prototype</code> property of the constructor function as their prototype. So the object created by new Object() inherits from <code>Object.prototype</code> just as the object created by <code>{}</code> does. Similarly, the object created by <code>new Array()</code> uses Array.prototype as its prototype, and the object created by <code>new Date()</code> uses <code>Date.prototype</code> as its prototype. <br></p>\n<p><code>Object.prototype</code> is one of the rare objects that has no prototype. All of the built-in constructors have a prototype that inherits from <code>Object.prototype</code>. <br></p>\n<p>You can pass <code>null</code> to create a new object that does not have a prototype, but if you do this, the newly created object will not inherit anything, not even basic methods like <code>toString()</code> (which means it won’t work with the <code>+</code> operator). If you want to create an ordinary empty object (like the object returned by <code>{}</code> or <code>new Object()</code>), pass <code>Object.prototype</code>:<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> o = <span class=\"built_in\">Object</span>.create(<span class=\"built_in\">Object</span>.prototype);</span><br><span class=\"line\"></span><br><span class=\"line\">/ ** Creating a <span class=\"keyword\">new</span> object that inherits <span class=\"keyword\">from</span> a prototype ** <span class=\"regexp\">/</span></span><br><span class=\"line\"><span class=\"regexp\"></span></span><br><span class=\"line\"><span class=\"regexp\">/</span><span class=\"regexp\">/ inherit() returns a newly created object  that inherits properties from the</span></span><br><span class=\"line\"><span class=\"regexp\">/</span><span class=\"regexp\">/ prototype object p. It uses the ECMAScript 5 function Object.create() if </span></span><br><span class=\"line\"><span class=\"regexp\">/</span><span class=\"regexp\">/ it is defined, and otherwise falls back to an older technique.</span></span><br><span class=\"line\"><span class=\"regexp\"></span></span><br><span class=\"line\"><span class=\"regexp\">function inherit(p) &#123;</span></span><br><span class=\"line\"><span class=\"regexp\">    if (p == null) throw TypeError(); /</span><span class=\"regexp\">/ p must be a non-null object</span></span><br><span class=\"line\"><span class=\"regexp\"></span></span><br><span class=\"line\"><span class=\"regexp\">    if(Object.create)</span></span><br><span class=\"line\"><span class=\"regexp\">        return Object.create(p);</span></span><br><span class=\"line\"><span class=\"regexp\">    var t = typeof p; </span></span><br><span class=\"line\"><span class=\"regexp\">    if (t !== 'object' &amp;&amp; t !== 'function') throw TypeError();</span></span><br><span class=\"line\"><span class=\"regexp\"></span></span><br><span class=\"line\"><span class=\"regexp\">    function f() &#123;&#125;; /</span><span class=\"regexp\">/ define a dummy constructor function</span></span><br><span class=\"line\"><span class=\"regexp\">    f.prototype = p;</span></span><br><span class=\"line\"><span class=\"regexp\">    return new f();</span></span><br><span class=\"line\"><span class=\"regexp\">&#125;</span></span><br></pre></td></tr></table></figure></p>\n<p>One use for our <code>inherit()</code> function is when you want to guard against unintended modification of an object by a library function that you don’t have control over. Instead of passing the object directly to the function, you can pass an heir.<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> o = &#123; <span class=\"attr\">x</span>: <span class=\"string\">\"don't change\"</span> &#125;;</span><br><span class=\"line\">library_function(inherit(o)); <span class=\"comment\">// guard against accidental modifications of o.</span></span><br></pre></td></tr></table></figure></p>\n<h2 id=\"Querying-and-Setting-Properties\"><a href=\"#Querying-and-Setting-Properties\" class=\"headerlink\" title=\"Querying and Setting Properties\"></a>Querying and Setting Properties</h2><p>The left-hand side should be an expression whose value is an object. If using the dot operator, the right-hand must be a simple identifier that names the property. If using square brackets, the value within the brackets must be an expression that evaluates to a string that contains the desired property name. A more precise statement is that the expression must evaluate to a string or a value that can be converted to a string. An identifier is static and must be hardcoded in the program. <br></p>\n<p>JS objects have a set of ‘own properties’, and they also inherit a set of properties from their prototype object. Suppose you assign to the property <code>x</code> of the object <code>o</code>. If <code>o</code> previously inherited the property <code>x</code>, that inherited property is now hidden by the newly created own property with the same name. The fact that inheritance occurs when querying properties but not when setting them is a key feature of JS because it allows us to selectively override inherited properties. If <code>o</code> inherits the property <code>x</code>, and that property is an accessor property with a setter method, then that setter method is called rather than creating a new property <code>x</code> in <code>o</code>. Note, however, that the setter method is called on the object <code>o</code>, not on the prototype object that defines the property, so if the setter method defines any properties, it do so on <code>o</code>, and it will again leave the prototype chain unmodified. <br><br>An attempt to set a property <code>p</code> of an object <code>o</code> fails in these circusmstances, curiously, these attemplts fail silently.</p>\n<ul>\n<li><code>o</code> has an own property <code>p</code> that is read-only.</li>\n<li><code>o</code> has an inherited property <code>p</code> that is read-only. </li>\n</ul>\n<h2 id=\"Deleting-Properties\"><a href=\"#Deleting-Properties\" class=\"headerlink\" title=\"Deleting Properties\"></a>Deleting Properties</h2><p>Surprisingly, <code>delete</code> does not operate on the value of the property but on the property itself (both name and value). The <code>delete</code> operator only deletes own properties, not inherited ones. A <code>delete</code> expression evaluates to <code>true</code> if the delete succeeded or if the delete had no effect (such as deleting a nonexist property). <code>delete</code> also evaluates to <code>true</code> when used (meaninglessly) with an expression that is not a property access expression:<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">o = &#123;<span class=\"attr\">x</span>:<span class=\"number\">1</span>&#125;; </span><br><span class=\"line\"><span class=\"keyword\">delete</span> o.x; <span class=\"comment\">// delete x, return true.</span></span><br><span class=\"line\"><span class=\"keyword\">delete</span> o.x; <span class=\"comment\">// delete nothing, and return true</span></span><br><span class=\"line\"><span class=\"keyword\">delete</span> o.toString(); <span class=\"comment\">// not its own property, do nothing</span></span><br><span class=\"line\"><span class=\"keyword\">delete</span> <span class=\"number\">1</span>; <span class=\"comment\">// nonsense, but evaluates to true</span></span><br></pre></td></tr></table></figure></p>\n<p><code>delete</code> does not remove properties that have a <code>configurable</code> attribute of false. (Though itv will remove configurable properties of nonextensible objects.) Certain properties of built-in objects are nonconfigurable, as are properties of the global object created by variable declaration and function declaration.<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">delete</span> <span class=\"built_in\">Object</span>.prototype <span class=\"comment\">// can't delete, property is non-configurable</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> x = <span class=\"number\">1</span>; <span class=\"comment\">// declare a global variable</span></span><br><span class=\"line\"><span class=\"keyword\">delete</span> <span class=\"keyword\">this</span>.x <span class=\"comment\">// can't delete this property</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f</span>(<span class=\"params\"></span>) </span>&#123;&#125; <span class=\"comment\">// declare a global function</span></span><br><span class=\"line\"><span class=\"keyword\">delete</span> <span class=\"keyword\">this</span>.f; <span class=\"comment\">// can't delete this property either</span></span><br></pre></td></tr></table></figure></p>\n<h2 id=\"Testing-properties\"><a href=\"#Testing-properties\" class=\"headerlink\" title=\"Testing properties\"></a>Testing properties</h2><p>You can do this with the <code>in</code> operator, with the <code>hasOwnProperty()e</code> and <code>propertyIsEnumerable()</code> methods, or simply by querying the property.</p>\n<p>The <code>in</code> operator expects a property name ( as a string ) on its left side and an object on its right. It returns <code>true</code> if the object has an own property or an inherited property by that name.<br>The <code>hasOwnProperty()</code> method of an object has an own property with the given name. It returns <code>false</code> for inherited properties. The <code>propertyIsEnumerable()</code> refines the <code>hasOwnProperty()</code>. It returns <code>true</code> only if the named property is an own property and its <code>enumerable</code> attribute is <code>true</code>. <br></p>\n<p>Instead of using the <code>in</code> operator it is often sufficient to simply query the property and use <code>!==</code> to make sure it is not <code>undefined</code>.<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> o = &#123; <span class=\"attr\">x</span>:<span class=\"number\">1</span> &#125;</span><br><span class=\"line\">o.x !== <span class=\"literal\">undefined</span>; <span class=\"comment\">// true</span></span><br><span class=\"line\">o.y !== <span class=\"literal\">undefined</span>; <span class=\"comment\">// false</span></span><br><span class=\"line\">o.toString != <span class=\"literal\">undefined</span>; <span class=\"comment\">// true: o inherits toString</span></span><br></pre></td></tr></table></figure></p>\n<p>However, <code>in</code> can distinguish between properties that do not exist and properties that exist but have been set to <code>undefined</code>.<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> o = &#123; <span class=\"attr\">x</span>: <span class=\"literal\">undefined</span> &#125;   <span class=\"comment\">// Property is explicitly set to undefined</span></span><br><span class=\"line\">o.x !== <span class=\"literal\">undefined</span>          <span class=\"comment\">// false: property exists but is undefined</span></span><br><span class=\"line\"><span class=\"string\">\"x\"</span> <span class=\"keyword\">in</span> o                   <span class=\"comment\">// true: the property exists</span></span><br><span class=\"line\"><span class=\"keyword\">delete</span> o.x;                <span class=\"comment\">// Delete the property x</span></span><br><span class=\"line\"><span class=\"string\">\"x\"</span> <span class=\"keyword\">in</span> o                   <span class=\"comment\">// false: it doesn't exist anymore</span></span><br></pre></td></tr></table></figure></p>\n<h2 id=\"Enumerating-Properties\"><a href=\"#Enumerating-Properties\" class=\"headerlink\" title=\"Enumerating Properties\"></a>Enumerating Properties</h2><p>The <code>for/in</code> runs the body of the loop once for each enumerable property (own or inherited) of the specified object. Built-in methods that objects inherit are not enumerable, but the properties that your code adds to the objects are enumerable.<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* object utility functions that enumerable properties */</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// copy the enumerable properties of p to o </span></span><br><span class=\"line\"><span class=\"comment\">// if o and p have a property by the same name, o's property is overwritten.</span></span><br><span class=\"line\"><span class=\"comment\">// this function does not handle getters and setters or copy attributes. </span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">extend</span>(<span class=\"params\">o, p</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (prop <span class=\"keyword\">in</span> p) &#123;</span><br><span class=\"line\">        o[prop] = p[prop];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> o;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// copy enumerable properties and won't overridden owned property</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">merge</span>(<span class=\"params\">o, p</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(prop <span class=\"keyword\">in</span> p) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (o.hasOwnProperty(prop)) <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">        o[prop] = p[prop];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> o;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// remove properties from o if there is not a property with the same name in p</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">restrict</span>(<span class=\"params\">o, p</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (prop <span class=\"keyword\">in</span> o) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!(prop <span class=\"keyword\">in</span> p)) <span class=\"keyword\">delete</span> o[prop];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> o;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// for each property of p, delete the property with the same name from o</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">substract</span>(<span class=\"params\">o, p</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (prop <span class=\"keyword\">in</span> p)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">delete</span> o[prop];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> o;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// union properties</span></span><br><span class=\"line\"><span class=\"comment\">// property from o are preserved</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">union</span> (<span class=\"params\">o, p</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> extend(extend(&#123;&#125;, o), p);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// properties from p are discarded. </span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">intersection</span>(<span class=\"params\">o, p</span>) </span>&#123;<span class=\"keyword\">return</span> restrict(extend(&#123;&#125;, o), p); &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// return an array that holds the names of the enumerable own properties of o</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">keys</span>(<span class=\"params\">o</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> o !== <span class=\"string\">'object'</span>) <span class=\"keyword\">throw</span> <span class=\"built_in\">TypeError</span>();</span><br><span class=\"line\">    <span class=\"keyword\">var</span> result = [];</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> prop <span class=\"keyword\">in</span> o) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (o.hasOwnProperty(prop))</span><br><span class=\"line\">            result.push(prop);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>ECMAScript 5 defines two functions that enumerates property names. The first is <code>Object.keys()</code>, which returns an array of the names of the enumerable own properties of an object. Another is <code>Object.getOwnPropertyNames()</code>. It returns the names of all the own properties of the specified object, not just the enumerable properties. </p>\n<h2 id=\"Property-Getters-and-Setters\"><a href=\"#Property-Getters-and-Setters\" class=\"headerlink\" title=\"Property Getters and Setters\"></a>Property Getters and Setters</h2><p>It is said that an object property is a name, a value, and a set of attributes. The value may be replaced by one or two methods, known as getter and a setter. Properties defined by getters and setters are sometimes known as <em>accessor properties</em> to distinguish them from data properties that have a simple value.<br><br>When a program queries the value of an accessor property, JS invokes the getter method(passing no arguments). The return value of this method becomes the value of the property access expression. When a program sets the value of an accessor property, JS invokes the setter method, passing the value of the right-hand side of the assignment. This method is responsible for ‘setting’, in some sense, the property value. The return value of the setter method is ignored. <br></p>\n<p>Accessor properties do not have a <em>writable</em> attribute as data properties do. If a property has both a getter and a setter method, it is a read/write property. If it has only a getter method, it is a read-only property. And if it has only a setter method, it is a write-only property (something that is not possible with data propertiese) and attempts to read it alwasys evaluates to <code>undefined</code>. <br></p>\n<p>Accessor properties are defined as one or two functions whose name is the same as the property name, and with the <code>function</code> keyword replaced with <code>get</code> and <code>set</code>.<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> p = &#123;</span><br><span class=\"line\">    x : <span class=\"number\">1.0</span>,</span><br><span class=\"line\">    y: <span class=\"number\">1.0</span>,</span><br><span class=\"line\">    get r() &#123; <span class=\"keyword\">return</span> <span class=\"built_in\">Math</span>.sqrt(<span class=\"keyword\">this</span>.x*<span class=\"keyword\">this</span>.x + <span class=\"keyword\">this</span>.y*<span class=\"keyword\">this</span>.y); &#125;,</span><br><span class=\"line\">    set r(newvalue) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> oldvalue = <span class=\"built_in\">Math</span>.sqrt(<span class=\"keyword\">this</span>.x*<span class=\"keyword\">this</span>.x + <span class=\"keyword\">this</span>.y*<span class=\"keyword\">this</span>.y);</span><br><span class=\"line\">        <span class=\"keyword\">var</span> ratio = newvalue/oldvalue;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.x*= ratio;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.y*=ratio;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    get theta() &#123;<span class=\"keyword\">return</span> <span class=\"built_in\">Math</span>.atan2(<span class=\"keyword\">this</span>.y, <span class=\"keyword\">this</span>.x);&#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<p>Note the use of the keyword <code>this</code> in the getters and setter above. JS invokes these functions as methods of the object on which they are defined, which means that within the body of the function <code>this</code> refers to the point object.  Accessor properties are inherited, just as data properties are, so you can use the object <code>p</code> defined above as a prototype for other points.<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> q = inherit(p);  <span class=\"comment\">// create a new object that inherits getters and setters</span></span><br><span class=\"line\">q.x = <span class=\"number\">0</span>, q.y = <span class=\"number\">0</span>;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(q.r); </span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(q.theta);</span><br></pre></td></tr></table></figure></p>\n<p>The code above uses accessor properties to define an API. Other reasons to use accessor properties include sanity checking of property writes and returning different values on each property read:<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> serialnum = &#123;</span><br><span class=\"line\">    <span class=\"comment\">// THe data property holds the next serial number</span></span><br><span class=\"line\">    <span class=\"comment\">// The $ in the property name hints that it is a private property</span></span><br><span class=\"line\">    $n: <span class=\"number\">0</span>,</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Return the current value and increment it</span></span><br><span class=\"line\">    get next() &#123;<span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.$n++&#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Set a new value of n, but only if it is larger than current</span></span><br><span class=\"line\">    set next(n) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> ( n &gt;= <span class=\"keyword\">this</span>.$n ) <span class=\"keyword\">this</span>.$n = n;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">throw</span> <span class=\"string\">\"serial number can only be set to a larger value\"</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"Property-Attributes\"><a href=\"#Property-Attributes\" class=\"headerlink\" title=\"Property Attributes\"></a>Property Attributes</h2><p>In addition to a name and value, properties have attributes that specify whether they can be written, enumerated, and configured. <br></p>\n<p>We are going to consider getter and setter methods of an accessor property to be property attributes. Following this logic, we’ll even say that the value of a data property is an attribute as well. Following this logic, we say that the value of a data property is an attribute as well. Thus, we can say that a property has a name and four attributes. The four attributes of a data property are <em>value, writable, enumerable, and configurable</em>. Accessor properties don’t have a <em>value</em> attribute or a <em>writable</em>: their writability is determined by the presence or absence of a setter. So the four attributes of an accessor property are <em>get, set, enumerable, and confiugrable</em>. <br></p>\n<p>The ECMAScript 5 methods for querying and setting the attributes of a property use an object called a <em>property descriptor</em> to represent the set of four attributes. Thus, the property descriptor object of a data property has properties named <code>value, writable, enumerable</code> and <code>configurable</code>. And the descriptor for an accessor property has <code>get</code> and <code>set</code> properties instead of <code>value</code> and <code>writable</code>. The <code>writable, enumerable</code> and <code>configurable</code> properties are boolean values, and the <code>get</code> and <code>set</code> properties are function values, of course. To obtain descriptor, ew can call <code>Object.getOwnPropertyDescriptor():</code><br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Returns &#123;value: 1, writable:true, enumerable:true, configurable:true&#125;</span></span><br><span class=\"line\"><span class=\"built_in\">Object</span>.getOwnPropertyDescriptor(&#123;<span class=\"attr\">x</span>:<span class=\"number\">1</span>&#125;, <span class=\"string\">\"x\"</span>);</span><br><span class=\"line\"><span class=\"comment\">// Now query the octet property of the random object defined above.</span></span><br><span class=\"line\"><span class=\"comment\">// Returns &#123; get: /*func*/, set:undefined, enumerable:true, configurable:true&#125;</span></span><br><span class=\"line\"><span class=\"built_in\">Object</span>.getOwnPropertyDescriptor(random, <span class=\"string\">\"octet\"</span>);</span><br><span class=\"line\"><span class=\"comment\">// Returns undefined for inherited properties and properties that don't exist.</span></span><br><span class=\"line\"><span class=\"built_in\">Object</span>.getOwnPropertyDescriptor(&#123;&#125;, <span class=\"string\">\"x\"</span>);         <span class=\"comment\">// undefined, no such prop</span></span><br><span class=\"line\"><span class=\"built_in\">Object</span>.getOwnPropertyDescriptor(&#123;&#125;, <span class=\"string\">\"toString\"</span>);  <span class=\"comment\">// undefined, inherited</span></span><br></pre></td></tr></table></figure></p>\n<p>As its name implies, <code>Object.getOwnPropertyDescriptor()</code> works only for own properties. To query the attributes of inherited properties, you must explicitly traverse the prototype chain. To set the attribute of a property, or to create a new property with the specified attributes, call <code>Object.defineProperty()</code>.<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> o = &#123;&#125;;  <span class=\"comment\">// Start with no properties at all</span></span><br><span class=\"line\"><span class=\"comment\">// Add a nonenumerable data property x with value 1.</span></span><br><span class=\"line\"><span class=\"built_in\">Object</span>.defineProperty(o, <span class=\"string\">\"x\"</span>, &#123; <span class=\"attr\">value</span> : <span class=\"number\">1</span>,</span><br><span class=\"line\">                                writable: <span class=\"literal\">true</span>,</span><br><span class=\"line\">                                enumerable: <span class=\"literal\">false</span>,</span><br><span class=\"line\">                                configurable: <span class=\"literal\">true</span>&#125;);</span><br><span class=\"line\"><span class=\"comment\">// Check that the property is there but is nonenumerable</span></span><br><span class=\"line\">o.x;           <span class=\"comment\">// =&gt; 1</span></span><br><span class=\"line\"><span class=\"built_in\">Object</span>.keys(o) <span class=\"comment\">// =&gt; []</span></span><br><span class=\"line\"><span class=\"comment\">// Now modify the property x so that it is read-only</span></span><br><span class=\"line\"><span class=\"built_in\">Object</span>.defineProperty(o, <span class=\"string\">\"x\"</span>, &#123; <span class=\"attr\">writable</span>: <span class=\"literal\">false</span> &#125;);</span><br><span class=\"line\"><span class=\"comment\">// Try to change the value of the property</span></span><br><span class=\"line\">o.x = <span class=\"number\">2</span>;      <span class=\"comment\">// Fails silently or throws TypeError in strict mode</span></span><br><span class=\"line\">o.x           <span class=\"comment\">// =&gt; 1</span></span><br><span class=\"line\"><span class=\"comment\">// The property is still configurable, so we can change its value like this:</span></span><br><span class=\"line\"><span class=\"built_in\">Object</span>.defineProperty(o, <span class=\"string\">\"x\"</span>, &#123; <span class=\"attr\">value</span>: <span class=\"number\">2</span> &#125;);</span><br><span class=\"line\">o.x           <span class=\"comment\">// =&gt; 2</span></span><br><span class=\"line\"><span class=\"comment\">// Now change x from a data property to an accessor property</span></span><br><span class=\"line\"><span class=\"built_in\">Object</span>.defineProperty(o, <span class=\"string\">\"x\"</span>, &#123; <span class=\"attr\">get</span>: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123; <span class=\"keyword\">return</span> <span class=\"number\">0</span>; &#125; &#125;);</span><br><span class=\"line\">o.x           <span class=\"comment\">// =&gt; 0</span></span><br></pre></td></tr></table></figure></p>\n<p>If you’are creating a new property, then omitted attributes are taken to be <code>false</code> or <code>undefined</code>. if you’re modifying an existing property, then the attributes you omit are simply left unchanged. Note that this method alters an existing own property or creates a new own property, but it will not alter an inherited property. <br><br>If you want to create or modify more than one property at a time, use <code>Object.defineProperties()</code>.<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// this code starts with an empty object, then adds two data properties and one read-only accessor property to it. </span></span><br><span class=\"line\"><span class=\"keyword\">var</span> p = <span class=\"built_in\">Object</span>.defineProperties(&#123;&#125;, &#123;</span><br><span class=\"line\">    x: &#123; <span class=\"attr\">value</span>: <span class=\"number\">1</span>, <span class=\"attr\">writable</span>: <span class=\"literal\">true</span>, <span class=\"attr\">enumerable</span>:<span class=\"literal\">true</span>, <span class=\"attr\">configurable</span>:<span class=\"literal\">true</span> &#125;, </span><br><span class=\"line\">    y: &#123; <span class=\"attr\">value</span>: <span class=\"number\">1</span>, <span class=\"attr\">writable</span>: <span class=\"literal\">true</span>, <span class=\"attr\">enumerable</span>:<span class=\"literal\">true</span>, <span class=\"attr\">configurable</span>:<span class=\"literal\">true</span> &#125;,</span><br><span class=\"line\">    r: &#123;</span><br><span class=\"line\">        get: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123; <span class=\"keyword\">return</span> <span class=\"built_in\">Math</span>.sqrt(<span class=\"keyword\">this</span>.x*<span class=\"keyword\">this</span>.x + <span class=\"keyword\">this</span>.y*<span class=\"keyword\">this</span>.y) &#125;,</span><br><span class=\"line\">        enumerable:<span class=\"literal\">true</span>,</span><br><span class=\"line\">        configurable:<span class=\"literal\">true</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure></p>\n<p>If you pass a set of property descriptors to the second argument of <code>Object.create()</code>, then they are used to add properties to the newly created object. The <em>writable</em> attribute governs attempts to change the <em>value</em> attribute. And the <em>configurable</em> attribute governs attempts to change the other attributes (and also specifies whether a property can be deleted).</p>\n<ul>\n<li>If an object is not extensible, you can edit its existing own properties, but you cannot add new properties to it. </li>\n<li>If a property is not configurable, you cannot change its configurable or enumerable attributes. </li>\n<li>If an accessor property is not configurable, you cannot change its getter or setter method, and you cannot change it to a data property.</li>\n<li>If a data property is not configurable, you cannot change it to an accessor property.</li>\n<li>If a data property is not configurable, you cannot change its <em>writable</em> attribute from <code>false</code> to <code>true</code>, but you can change it from <code>true</code> to <code>false</code>.</li>\n<li>If a data property is not configurable and not writable, you cannot change its value. You can change the value of a property that is configurable but nonwritable, however ( because that would be the same as making it writable, then changing the value, then converting it back to nonwritable ). <figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\"> * Add a nonenumerable extend() method to Object.prototype.</span></span><br><span class=\"line\"><span class=\"comment\"> * This method extends the object on which it is called by copying properties</span></span><br><span class=\"line\"><span class=\"comment\"> * from the object passed as its argument.  All property attributes are</span></span><br><span class=\"line\"><span class=\"comment\"> * copied, not just the property value.  All own properties (even non</span></span><br><span class=\"line\"><span class=\"comment\">* enumerable ones) of the argument object are copied unless a property</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\">* with the same name already exists in the target object.</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"built_in\">Object</span>.defineProperty(<span class=\"built_in\">Object</span>.prototype,</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"string\">\"extend\"</span>,                  <span class=\"comment\">// Define Object.prototype.extend</span></span><br><span class=\"line\"></span><br><span class=\"line\">   &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">       writable: <span class=\"literal\">true</span>,</span><br><span class=\"line\"></span><br><span class=\"line\">       enumerable: <span class=\"literal\">false</span>,     <span class=\"comment\">// Make it nonenumerable</span></span><br><span class=\"line\"></span><br><span class=\"line\">       configurable: <span class=\"literal\">true</span>,</span><br><span class=\"line\"></span><br><span class=\"line\">       value: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">o</span>) </span>&#123;   <span class=\"comment\">// Its value is this function</span></span><br><span class=\"line\"></span><br><span class=\"line\">           <span class=\"comment\">// Get all own props, even nonenumerable ones</span></span><br><span class=\"line\"></span><br><span class=\"line\">           <span class=\"keyword\">var</span> names = <span class=\"built_in\">Object</span>.getOwnPropertyNames(o);</span><br><span class=\"line\"></span><br><span class=\"line\">           <span class=\"comment\">// Loop through them</span></span><br><span class=\"line\"></span><br><span class=\"line\">           <span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt; names.length; i++) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">               <span class=\"comment\">// Skip props already in this object</span></span><br><span class=\"line\"></span><br><span class=\"line\">               <span class=\"keyword\">if</span> (names[i] <span class=\"keyword\">in</span> <span class=\"keyword\">this</span>) <span class=\"keyword\">continue</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">               <span class=\"comment\">// Get property description from o</span></span><br><span class=\"line\"></span><br><span class=\"line\">               <span class=\"keyword\">var</span> desc = <span class=\"built_in\">Object</span>.getOwnPropertyDescriptor(o,names[i]);</span><br><span class=\"line\"></span><br><span class=\"line\">               <span class=\"comment\">// Use it to create property on this</span></span><br><span class=\"line\"></span><br><span class=\"line\">               <span class=\"built_in\">Object</span>.defineProperty(<span class=\"keyword\">this</span>, names[i], desc);</span><br><span class=\"line\"></span><br><span class=\"line\">           &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">       &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">   &#125;);</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h2 id=\"Objec-Attributes\"><a href=\"#Objec-Attributes\" class=\"headerlink\" title=\"Objec Attributes\"></a>Objec Attributes</h2><p>An object’s prototype attribute specifies the object from which it inherits properties. Objects created from object literals use <code>Object.prototype</code> as their prototype. Object created with <code>new</code> use the value of the <code>prototype</code> property of their constructor function as their prototype. And objects created with <code>Object.create()</code> use the first argument to that function as their prototype.  You can query the prototype of any object by passing that object to <code>Object.getPrototypeOf()</code>. Objects created by object literals or by <code>Object.create()</code> have a <code>constructor</code> prototype that refers to the <code>Object()</code> constructor. To determine whether one object is the prototype of another object, use the <code>isPrototype()</code> method.<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> p = &#123;<span class=\"attr\">x</span>:<span class=\"number\">1</span>&#125;;                    <span class=\"comment\">// Define a prototype object.</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> o = <span class=\"built_in\">Object</span>.create(p);         <span class=\"comment\">// Create an object with that prototype.</span></span><br><span class=\"line\">p.isPrototypeOf(o)                <span class=\"comment\">// =&gt; true: o inherits from p</span></span><br><span class=\"line\"><span class=\"built_in\">Object</span>.prototype.isPrototypeOf(o) <span class=\"comment\">// =&gt; true: p inherits from Object.prototype</span></span><br></pre></td></tr></table></figure></p>\n<p>The prototype is exposed through the specially named <code>__proto__</code> property.  <br></p>\n<p>An object’s <code>class</code> attribute is a string that provides information about the type of the object. The default <code>toString()</code> method (inherited from <code>Object.prototype</code> ) returns a string of the form: <code>[object class]</code>.<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// the tricky part is that may objects inherit other, more useful toString() methods,</span></span><br><span class=\"line\"><span class=\"comment\">// and to invoke the correct version of toString(), we must use Function.call() method.</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">classof</span>(<span class=\"params\">o</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (o === <span class=\"literal\">null</span>) <span class=\"keyword\">return</span> <span class=\"string\">'Null'</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (o === <span class=\"literal\">undefined</span>) <span class=\"keyword\">return</span> <span class=\"string\">`Undefined`</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">Object</span>.prototype.toString.call(o).slice(<span class=\"number\">8</span>,<span class=\"number\">-1</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>If you define your own constructor function, any objects you create with it will have a class attribute of “Object”: there is not way to specify the <em>class</em> attribute for you own classes of objects. <br></p>\n<p>The <em>extensible</em> attribute of an object specifies whether new properties can be added to the object or not.<br>ECMAScript5 defines functions for querying and setting the extensibility of an object. To determine whether an object is extensible, pass it to <code>Object.isExtensible()</code>. To make an object nonextensible, pass it to <code>Object.preventExtensions()</code>. Calling <code>preventExtensions()</code> only affects the extensibility of the object itself. If new properties are added to the prototype of a nonextensible object, the nonextensible object will inherit those new properties. <br><br>The purpose of the <em>extensible</em> attribute to be able to ‘lock down’ objects into a known state and prevent outside tampering. </p>\n<ul>\n<li><code>Object.seal()</code> works like <code>Object.preventExtensions()</code>, but in ddition to making the object nonextensible, it also make all of the own properties of that object nonconfigurable. This means that new properties cannot be added to the object, and existing properties cannot be deleted or configured. Existing properties that are writable can still be set. There is not way to unseal a sealed object. </li>\n<li><code>Object.freeze()</code> locks objects down even more tightly. In addition to making the object nonextensible and its properties nonconfigurable, it also makes all of the object’s own data properties read-only. But the setter method left unaffected. </li>\n</ul>\n<p>Both methods won’t affect on the prototype of the passed object.<br><code>Object.preventExtensions()</code>, <code>Object.seal()</code> and <code>Object.freeze()</code> all return the object that they are passed, which means that you can use them in nested function invocations:<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> o = <span class=\"built_in\">Object</span>.seal(<span class=\"built_in\">Object</span>.create(<span class=\"built_in\">Object</span>.freeze(&#123;<span class=\"attr\">x</span>:<span class=\"number\">1</span>&#125;),</span><br><span class=\"line\">                     &#123;<span class=\"attr\">y</span>: &#123;<span class=\"attr\">value</span>: <span class=\"number\">2</span>, <span class=\"attr\">writable</span>:<span class=\"literal\">true</span>&#125;&#125;));</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"Serializing-Objects\"><a href=\"#Serializing-Objects\" class=\"headerlink\" title=\"Serializing Objects\"></a>Serializing Objects</h2><p>Object <em>serialization</em> is the process of converting an object’s state to a string from which it can be restored. ECMA5 provides native functions <code>JSON.stringify()</code> and <code>JSON.parse()</code> to serialize and restore JS objects. <br><br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">o = &#123;<span class=\"attr\">x</span>:<span class=\"number\">1</span>, <span class=\"attr\">y</span>:&#123;<span class=\"attr\">z</span>:[<span class=\"literal\">false</span>,<span class=\"literal\">null</span>,<span class=\"string\">\"\"</span>]&#125;&#125;; <span class=\"comment\">// Define a test object</span></span><br><span class=\"line\">s = <span class=\"built_in\">JSON</span>.stringify(o);            <span class=\"comment\">// s is '&#123;\"x\":1,\"y\":&#123;\"z\":[false,null,\"\"]&#125;&#125;'</span></span><br><span class=\"line\">p = <span class=\"built_in\">JSON</span>.parse(s);                <span class=\"comment\">// p is a deep copy of o</span></span><br></pre></td></tr></table></figure></p>\n<p><code>NaN, Infinity</code> and <code>-Infinity</code> are serialized to null. Date objects are serialized to ISO-formatted date strings. but <code>JSON.parse()</code> leaves these in string form and does not restore the original Date object. Function, RegExp, adn Error objects and the <code>undefined</code> value cannot be serialized or restored. <code>JSON.stringify()</code> serializes only the enumerable own properties of an object. </p>\n<h2 id=\"Object-methods\"><a href=\"#Object-methods\" class=\"headerlink\" title=\"Object methods\"></a>Object methods</h2><p>In addition to the basic <code>toString()</code> method, objects all have a <code>toLocalString()</code>. The Data and Number classes define customized versions of <code>toLocaleString()</code> that attempts to format numbers, dates and times according to local conventions. <br></p>\n<p><code>Object.prototype</code> does not actually define a <code>toJSON()</code> method, but the <code>JSON.stringify()</code> method looks for a <code>toJSON()</code> method on any object it is asked to serialize. <br></p>\n<p>The <code>valueOf()</code> method is much like the <code>toString()</code> method, but it is called when JS needs to convert an object to some primitive type other than a string – typically, a number. </p>\n","prev":{"title":"Javascript: Array","slug":"JS-array"},"next":{"title":"Javascript: Statements","slug":"JS-statements"},"link":"https://whitefusion.github.io/post/javascript-objects"}