{"title":"js-scripted-http","date":"2019-01-05T15:06:09.000Z","excerpt":"","slug":"js-scripted-http","comments":true,"tags":["javascript","note"],"categories":["language core"],"updated":"2019-01-12T12:21:05.049Z","content":"<blockquote>\n<p>This is the reading note for “Chapter 18: Scripted Http, Javascript: The definitive guide 5th edition”. <br></p>\n</blockquote>\n<p>HTTP requests are initiated when a script sets the <code>location</code> property of a window object or calls the <code>submit()</code> method of a form object. <br></p>\n<p>The key features of an Ajax application is that it uses scripted HTTP to initiate data exchange with a web server without causing pages to reload. A web application might use Ajax technologies to log user interaction data to the server or to improve its start-up time by displaying only a simple page at first and then downloading additional data and page components on an as-needed basis.<br></p>\n<p>In a sense, Comet is the reverse of Ajax: in Comet, it is the web server that initiates the communication, asynchronously sending messages to the client. If the web application needs to respond to these messages sent by the server, it can then use Ajax techniques to send or request data. In Ajax, the client “pulls” data from the server. With Comet, the server “pushes” data to the client. Other names for Comet include “Server Push”, “Ajax Push”, and “Http Streaming”.<br></p>\n<p>There are a number of ways to implement Ajax and Comet, fand these underlying implementations are sometimes known as <code>transports</code>. The <code>&lt;img&gt;</code> element, for example, has a <code>src</code> property. When a script sets the property to a URL, an HTTP GET request is initiated to download an image from that URL. A script can therefore pass information to a web server by encoding that information into the query-string portion of the URL of an image and setting the <code>src</code> property of an <code>&lt;img&gt;</code> element. The web server must actually retrun some images as a result of this request, but it can be invisible: a transparent 1 pixel by 1 pixel image, for instance. <br></p>\n<p>Event the <code>&lt;script&gt;</code> element has a <code>src</code> property that can be set to initiate an HTTP GET request. Doing HTTP scripting with <code>&lt;script&gt;</code> elements is particularly attractive because they are not subject to the same-origin policy and can be used for cross-domain communication. Usually, with a <code>&lt;script&gt;</code> based Ajax transport, the server’s response takes the form of JSON-encoded data that is automatically “decoded” when the script is executed by teh JS interpreter. Because of its use of the JSON data format, this Ajax transport is known as “JSONP”.</p>\n<h3 id=\"The-XML-is-Optional\"><a href=\"#The-XML-is-Optional\" class=\"headerlink\" title=\"The XML is Optional\"></a>The XML is Optional</h3><p>The ‘X’ in ‘Ajax’ stands for XML, the primary client-side API for HTTP features XML in its name, and we’ll see later that one of the properties of the XMLHttpRequest object is named <code>responseXML</code>. It would seem that XML is an important part of scripted HTTP. But it’s not: these naems are the historical legacy of the days when XML was a powerful buzzword. Ajax techniques work with XML documents, of course, but the use of XML is purely optional and has actually become relatively rare. <br></p>\n<p>First, the XMLHttpRequest object supports any text based format, including XML. Second, it can be used to make requests over both HTTP and HTTPS. Finally, it supports “requests” in a broad sense of the term as it pertains to HTTP; namely all activity involved with HTTP requests or responses for the defined HTTP methods.</p>\n<h2 id=\"Using-XMLHttpRequest\"><a href=\"#Using-XMLHttpRequest\" class=\"headerlink\" title=\"Using XMLHttpRequest\"></a>Using XMLHttpRequest</h2><p>Browsers define their HTTP API on an XMLHttpRequest class. Each instance of this class represents a single request/response pair, and the properties and methods of the object allow you to specify request details and extract response data.<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> request = <span class=\"keyword\">new</span> XMLHttpRequest();</span><br></pre></td></tr></table></figure></p>\n<p>An HTTP request consists of four parts:</p>\n<ul>\n<li>the HTTP request methods for “verb”</li>\n<li>the URL being requested</li>\n<li>an optinal set of request headers, which may include authentication information </li>\n<li>an optional request body</li>\n</ul>\n<p>An HTTP response sent by a server has three parts:</p>\n<ul>\n<li>a numeric and textual status code that indicates the success or failure of the request</li>\n<li>a set of response headers</li>\n<li>the response body</li>\n</ul>\n<p>XMLHttpRequest is not a protocol-level HTTP API but instead a browser-level API. The browser takes care of cookies, redirects, caching, and proxies and your code need worry only about requests and responses. <br></p>\n<p>If you load a web page from a local file, the scripts in that page will not be able to use XMLHttpRequest with relative URLs, since those URLs will be relative to a <code>file://</code> URL rather than an <code>http://</code> URLs. <br></p>\n<h3 id=\"Specifying-the-Request\"><a href=\"#Specifying-the-Request\" class=\"headerlink\" title=\"Specifying the Request\"></a>Specifying the Request</h3><p>The next step in making an HTTP request is to call the <code>open()</code> method of you XMLHttpRequest object to specify the two required parts of the request, the method and the URL. <br><br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">request.open(<span class=\"string\">\"GET\"</span>, <span class=\"string\">\"data.csv\"</span>);</span><br></pre></td></tr></table></figure></p>\n<p>The first argument to <code>open()</code> specifies the HTTP method or verb. This is a case-insensitive string, but uppercase letters are typically used to match the HTTP protocol. “GET” is used for most “regular” requests, and it is appropriate when the URL completely specifies the requested resource, when the request has no side effects on the server, and when the server’s response is cacheable. The “POST” method is what is typically used by HTML forms. It includes additional data in the request body and that data is often stored in a database on the server. Repeated POSTs to the same URL may result in different responses from the server, and requests that use this method should not be cached. <br></p>\n<p>In addition to “GET” and “POST”, the XMLHttpRequest specification also allows “DELETE”, “HEAD”, “OPTIONS”, and “PUT” as the first arguement to <code>open()</code>. <br></p>\n<p>The second argument to <code>open()</code> is the URL that is the subject of the request. This is relative to the URL of the document that contains the script that is calling <code>open()</code>. If you sepcify an absolute URL, the protocal, host and port must generally match those of the containing document: cross-origin HTTP requests normally cause an error. <br></p>\n<p>The next step in the request process is to set the request headers, if any. POST requests, for example, need a “Content Type” header to specify the MIME type of the request body:<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">request.setRequestHeader(<span class=\"string\">\"Content-Type\"</span>, <span class=\"string\">\"text/plain\"</span>);</span><br></pre></td></tr></table></figure></p>\n<p>If you call <code>setRequestHeader()</code> multiple times for the same header, the new value does not replace the previously specified value: instead , the HTTP request will include multiple copies of the header or the header will specify multiple values. <br></p>\n<p>You cannot specify the “Content-Length”, “Date”, “Referer”, “User-Agent”  headers yourself: XMLHttpRequest will add those automatically for you and will not allow you to spoof them. Similarly, XMLHttpRequest object automatically handles cookies, and connection lifetime, charset, and encoding negotiations, so you’re not allowed to pass any of these headers to <code>setRequestHeaders()</code>:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Accept-Charset       Content-Transfer-Encoding    TE</span><br><span class=\"line\">Accept-Encoding      Date                         Trailer</span><br><span class=\"line\">Connection           Expect                       Transfer-Encoding</span><br><span class=\"line\">Content-Length       Host                         Upgrade</span><br><span class=\"line\">Cookie               Keep-Alive                   User-Agent</span><br><span class=\"line\">Cookie2              Referer                      Via</span><br></pre></td></tr></table></figure></p>\n<p>The final step in making an HTTP request with XMLHttpRequest is to specify the optional request body and send it off to the server. Do this with the <code>send()</code> method:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">request.send(null);</span><br></pre></td></tr></table></figure></p>\n<p>GET requests never have a body, so you should pass <code>null</code> or omit the argument. POST request do generally have a body, and ti should match the “Content-Type” header you specified with <code>setRequestHeader()</code>. </p>\n<h3 id=\"Order-Matters\"><a href=\"#Order-Matters\" class=\"headerlink\" title=\"Order Matters\"></a>Order Matters</h3><p>The parts of an HTTP request have a specific order: the request method and URL must come first, then the request headers, and finally the request body. XMLHttpRequest implementations generally do not initiate any networking until the <code>send()</code> method is called. This means that the XMLHttpRequest method must be called in an order that matches the structure of an HTTP request.<code>setRequestHeader()</code>, for example, must be called after you call <code>open()</code> and before you call <code>send()</code> or it will throw an exception. </p>\n","next":{"title":"CSS Specificity and Cascade","slug":"css-specificity"},"link":"https://whitefusion.github.io/post/js-scripted-http"}