{"title":"Javascript: Scripted Http","date":"2019-01-05T15:06:09.000Z","excerpt":"","slug":"js-scripted-http","comments":true,"tags":["note","javascript"],"categories":["language core"],"updated":"2019-03-02T04:05:26.437Z","content":"<blockquote>\n<p>This is the reading note for “Chapter 18: Scripted Http, Javascript: The definitive guide 5th edition”. <br></p>\n</blockquote>\n<p>HTTP requests are initiated when a script sets the <code>location</code> property of a window object or calls the <code>submit()</code> method of a form object. <br></p>\n<p>The key features of an Ajax application is that it uses scripted HTTP to initiate data exchange with a web server without causing pages to reload. A web application might use Ajax technologies to log user interaction data to the server or to improve its start-up time by displaying only a simple page at first and then downloading additional data and page components on an as-needed basis.<br></p>\n<p>In a sense, Comet is the reverse of Ajax: in Comet, it is the web server that initiates the communication, asynchronously sending messages to the client. If the web application needs to respond to these messages sent by the server, it can then use Ajax techniques to send or request data. In Ajax, the client “pulls” data from the server. With Comet, the server “pushes” data to the client. Other names for Comet include “Server Push”, “Ajax Push”, and “Http Streaming”.<br></p>\n<p>There are a number of ways to implement Ajax and Comet, fand these underlying implementations are sometimes known as <code>transports</code>. The <code>&lt;img&gt;</code> element, for example, has a <code>src</code> property. When a script sets the property to a URL, an HTTP GET request is initiated to download an image from that URL. A script can therefore pass information to a web server by encoding that information into the query-string portion of the URL of an image and setting the <code>src</code> property of an <code>&lt;img&gt;</code> element. The web server must actually retrun some images as a result of this request, but it can be invisible: a transparent 1 pixel by 1 pixel image, for instance. <br></p>\n<p>Event the <code>&lt;script&gt;</code> element has a <code>src</code> property that can be set to initiate an HTTP GET request. Doing HTTP scripting with <code>&lt;script&gt;</code> elements is particularly attractive because they are not subject to the same-origin policy and can be used for cross-domain communication. Usually, with a <code>&lt;script&gt;</code> based Ajax transport, the server’s response takes the form of JSON-encoded data that is automatically “decoded” when the script is executed by teh JS interpreter. Because of its use of the JSON data format, this Ajax transport is known as “JSONP”.</p>\n<h3 id=\"The-XML-is-Optional\"><a href=\"#The-XML-is-Optional\" class=\"headerlink\" title=\"The XML is Optional\"></a>The XML is Optional</h3><p>The ‘X’ in ‘Ajax’ stands for XML, the primary client-side API for HTTP features XML in its name, and we’ll see later that one of the properties of the XMLHttpRequest object is named <code>responseXML</code>. It would seem that XML is an important part of scripted HTTP. But it’s not: these naems are the historical legacy of the days when XML was a powerful buzzword. Ajax techniques work with XML documents, of course, but the use of XML is purely optional and has actually become relatively rare. <br></p>\n<p>First, the XMLHttpRequest object supports any text based format, including XML. Second, it can be used to make requests over both HTTP and HTTPS. Finally, it supports “requests” in a broad sense of the term as it pertains to HTTP; namely all activity involved with HTTP requests or responses for the defined HTTP methods.</p>\n<h2 id=\"Using-XMLHttpRequest\"><a href=\"#Using-XMLHttpRequest\" class=\"headerlink\" title=\"Using XMLHttpRequest\"></a>Using XMLHttpRequest</h2><p>Browsers define their HTTP API on an XMLHttpRequest class. Each instance of this class represents a single request/response pair, and the properties and methods of the object allow you to specify request details and extract response data.<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> request = <span class=\"keyword\">new</span> XMLHttpRequest();</span><br></pre></td></tr></table></figure></p>\n<p>An HTTP request consists of four parts:</p>\n<ul>\n<li>the HTTP request methods for “verb”</li>\n<li>the URL being requested</li>\n<li>an optinal set of request headers, which may include authentication information </li>\n<li>an optional request body</li>\n</ul>\n<p>An HTTP response sent by a server has three parts:</p>\n<ul>\n<li>a numeric and textual status code that indicates the success or failure of the request</li>\n<li>a set of response headers</li>\n<li>the response body</li>\n</ul>\n<p>XMLHttpRequest is not a protocol-level HTTP API but instead a browser-level API. The browser takes care of cookies, redirects, caching, and proxies and your code need worry only about requests and responses. <br></p>\n<p>If you load a web page from a local file, the scripts in that page will not be able to use XMLHttpRequest with relative URLs, since those URLs will be relative to a <code>file://</code> URL rather than an <code>http://</code> URLs. <br></p>\n<h3 id=\"Specifying-the-Request\"><a href=\"#Specifying-the-Request\" class=\"headerlink\" title=\"Specifying the Request\"></a>Specifying the Request</h3><p>The next step in making an HTTP request is to call the <code>open()</code> method of you XMLHttpRequest object to specify the two required parts of the request, the method and the URL. <br><br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">request.open(<span class=\"string\">\"GET\"</span>, <span class=\"string\">\"data.csv\"</span>);</span><br></pre></td></tr></table></figure></p>\n<p>The first argument to <code>open()</code> specifies the HTTP method or verb. This is a case-insensitive string, but uppercase letters are typically used to match the HTTP protocol. “GET” is used for most “regular” requests, and it is appropriate when the URL completely specifies the requested resource, when the request has no side effects on the server, and when the server’s response is cacheable. The “POST” method is what is typically used by HTML forms. It includes additional data in the request body and that data is often stored in a database on the server. Repeated POSTs to the same URL may result in different responses from the server, and requests that use this method should not be cached. <br></p>\n<p>In addition to “GET” and “POST”, the XMLHttpRequest specification also allows “DELETE”, “HEAD”, “OPTIONS”, and “PUT” as the first arguement to <code>open()</code>. <br></p>\n<p>The second argument to <code>open()</code> is the URL that is the subject of the request. This is relative to the URL of the document that contains the script that is calling <code>open()</code>. If you sepcify an absolute URL, the protocal, host and port must generally match those of the containing document: cross-origin HTTP requests normally cause an error. <br></p>\n<p>The next step in the request process is to set the request headers, if any. POST requests, for example, need a “Content Type” header to specify the MIME type of the request body:<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">request.setRequestHeader(<span class=\"string\">\"Content-Type\"</span>, <span class=\"string\">\"text/plain\"</span>);</span><br></pre></td></tr></table></figure></p>\n<p>If you call <code>setRequestHeader()</code> multiple times for the same header, the new value does not replace the previously specified value: instead , the HTTP request will include multiple copies of the header or the header will specify multiple values. <br></p>\n<p>You cannot specify the “Content-Length”, “Date”, “Referer”, “User-Agent”  headers yourself: XMLHttpRequest will add those automatically for you and will not allow you to spoof them. Similarly, XMLHttpRequest object automatically handles cookies, and connection lifetime, charset, and encoding negotiations, so you’re not allowed to pass any of these headers to <code>setRequestHeaders()</code>:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Accept-Charset       Content-Transfer-Encoding    TE</span><br><span class=\"line\">Accept-Encoding      Date                         Trailer</span><br><span class=\"line\">Connection           Expect                       Transfer-Encoding</span><br><span class=\"line\">Content-Length       Host                         Upgrade</span><br><span class=\"line\">Cookie               Keep-Alive                   User-Agent</span><br><span class=\"line\">Cookie2              Referer                      Via</span><br></pre></td></tr></table></figure></p>\n<p>The final step in making an HTTP request with XMLHttpRequest is to specify the optional request body and send it off to the server. Do this with the <code>send()</code> method:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">request.send(null);</span><br></pre></td></tr></table></figure></p>\n<p>GET requests never have a body, so you should pass <code>null</code> or omit the argument. POST request do generally have a body, and ti should match the “Content-Type” header you specified with <code>setRequestHeader()</code>. </p>\n<h3 id=\"Order-Matters\"><a href=\"#Order-Matters\" class=\"headerlink\" title=\"Order Matters\"></a>Order Matters</h3><p>The parts of an HTTP request have a specific order: the request method and URL must come first, then the request headers, and finally the request body. XMLHttpRequest implementations generally do not initiate any networking until the <code>send()</code> method is called. This means that the XMLHttpRequest method must be called in an order that matches the structure of an HTTP request.<code>setRequestHeader()</code>, for example, must be called after you call <code>open()</code> and before you call <code>send()</code> or it will throw an exception. </p>\n<h3 id=\"Retrieving-the-Response\"><a href=\"#Retrieving-the-Response\" class=\"headerlink\" title=\"Retrieving the Response\"></a>Retrieving the Response</h3><p>A complete HTTP response consists of a status code , a set of response headers, and a response body. </p>\n<ul>\n<li>The <code>status</code> and <code>statusText</code> properties return the HTTP status in numeric and textual forms. These properties hold standard HTTP values like 200 and “OK” for successful requests and 404 and “NOT FOUND” for URLs that don’t match any resource on the server.</li>\n<li>The response headers can be queried with <code>getResponseHeader()</code> and <code>getAllResponseHeaders()</code>. XMLHttpRequest handles cookies automatically: it filters cookie headers out of the set returned by <code>getAllResponseHeaders()</code> and returns <code>null</code> if you pass “Set-Cookie” or “Set-Cookie2” to <code>getResponseHeader()</code>.</li>\n<li>The response body is available in textual form from the <code>responseText</code> property or in Document form from the <code>responseXML</code> property. <br></li>\n</ul>\n<p>The XMLHTTPRequest object is usually used asynchronously: the <code>send()</code> method returns immediately after sending the request, and the response methods and properties listed above aren’t valid until the response is received. To be notified when the response is ready, you must listen for readystatechange events.  <br></p>\n<p><code>readyState</code> is an integer that specifies the status of an HTTP request, and its possible values are enumerated. </p>\n<p><img src=\"../images/readyState_values.png\" alt=\"readyState_values\"></p>\n<p>The readystatechange event is triggered every time the <code>readyState</code> property changes. In practice, the event may not be fired when <code>readyState</code> changes to 0 or 1. It is often fired when <code>send()</code> is called, even though <code>readyState</code> remains at <code>OPENED</code> when that happens. Some browsers fire the event multiple times during the <code>LOADING</code> state to give progress feedback. All browsers do fire the readystatechange event when <code>readyState</code> has changed to the value 4 and the server’s response is complete. Because the event is also fired before the response is complete, however, event handlers should always test the <code>readyState</code> value. <br></p>\n<p>To listen for readystatechange events, set the <code>onreadystatechange</code> property of the XMLHttpRequest object to your event handler function. </p>\n<h4 id=\"Synchronous-response\"><a href=\"#Synchronous-response\" class=\"headerlink\" title=\"Synchronous response\"></a>Synchronous response</h4><p>If you pass <code>false</code> as the third argument to <code>open()</code>, the <code>send()</code> method will block until the request completes. In this case, there is no need to use an event handler: once <code>send()</code> returns, you can just check the <code>status</code> and <code>responseText</code> properties of the XMLHttpRequest object. <br></p>\n<p>Synchronously requests are tempting, but they should be avoided. Client-side JS is single-threaded and when the <code>send()</code> method blocks, it typically freezes the entire browser UI. </p>\n<h4 id=\"Decoding-the-response\"><a href=\"#Decoding-the-response\" class=\"headerlink\" title=\"Decoding the response\"></a>Decoding the response</h4><p>We assume that the server has sent a textual response, with a MIME type like “text/plain”, “text/html”, or “text/css”, and we retrieve it with the <code>responseText</code> property of the XMLHttpRequest object. <br></p>\n<p>If the server sends an XML or XHTML document as its response, you can retrieve a parsed representation of the XML document through the responseXML property. The value of this property is a Document object, and you can search traverse it. <br></p>\n<p>if the server wants to send structured data, such as an object or array, as it response, it might transmit that data as a JSON-concoded string. When you receive it, you would then pass the <code>responseText</code> property to <code>JSON.parse()</code>. <br><br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Issue an HTTP GET request for the contents of the specified URL.</span></span><br><span class=\"line\"><span class=\"comment\">// When the response arrives, pass it to the callback function as a</span></span><br><span class=\"line\"><span class=\"comment\">// parsed XML Document object, a JSON-parsed object, or a string.</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">get</span>(<span class=\"params\">url, callback</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> request = <span class=\"keyword\">new</span> XMLHttpRequest();         <span class=\"comment\">// Create new request</span></span><br><span class=\"line\">    request.open(<span class=\"string\">\"GET\"</span>, url);                   <span class=\"comment\">// Specify URL to fetch</span></span><br><span class=\"line\">    request.onreadystatechange = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;   <span class=\"comment\">// Define event listener</span></span><br><span class=\"line\">        <span class=\"comment\">// If the request is compete and was successful</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (request.readyState === <span class=\"number\">4</span> &amp;&amp; request.status === <span class=\"number\">200</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// Get the type of the response</span></span><br><span class=\"line\">            <span class=\"keyword\">var</span> type = request.getResponseHeader(<span class=\"string\">\"Content-Type\"</span>);</span><br><span class=\"line\">            <span class=\"comment\">// Check type so we don't get HTML documents in the future</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (type.indexOf(<span class=\"string\">\"xml\"</span>) !== <span class=\"number\">-1</span> &amp;&amp; request.responseXML)</span><br><span class=\"line\">                callback(request.responseXML);              <span class=\"comment\">// Document response</span></span><br><span class=\"line\">            <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (type === <span class=\"string\">\"application/json\"</span>)</span><br><span class=\"line\">                callback(<span class=\"built_in\">JSON</span>.parse(request.responseText)); <span class=\"comment\">// JSON response</span></span><br><span class=\"line\">            <span class=\"keyword\">else</span></span><br><span class=\"line\">                callback(request.responseText);             <span class=\"comment\">// String response</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    request.send(<span class=\"literal\">null</span>);                         <span class=\"comment\">// Send the request now</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>Another response type that you might want to “decode” specially is “application/javascript” or “text/javascript”. You can use an XMLHttpRequest to request a Javascript script, and then use a global <code>eval()</code> to execute that script. Using an XMLHttpRequest object is unnecessary in this case, however, since the HTTP scripting capabilities of the <code>&lt;script&gt;</code> element itself are sufficient to download and execute a script. Keep in mind that the <code>&lt;script&gt;</code> element can make cross-origin HTTP requests that are prohibited to the XMLHttpRequest API. </p>\n<h3 id=\"Encoding-the-Request-Body\"><a href=\"#Encoding-the-Request-Body\" class=\"headerlink\" title=\"Encoding the Request Body\"></a>Encoding the Request Body</h3><h4 id=\"Form-encoded-requests\"><a href=\"#Form-encoded-requests\" class=\"headerlink\" title=\"Form-encoded requests\"></a>Form-encoded requests</h4><p>The encoding scheme used for form data is relatively simple: perform normal URI encoding (replacing special characters with hexadecimal escape codes) on the name and value of each form element, separate the encoded name and value with an equals sign, and separate these name/value paris with ampersands. The encoding of a simple form might look like this:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">find=pizza&amp;zipcode=02134&amp;radius=1km</span><br></pre></td></tr></table></figure></p>\n<p>This form data encoding format has a formal MIME type: <code>application/x-www-form-urlencoded</code>.<br>You must set the <code>Content-Type</code> request header to this value when POSTing form data of this sort.</p>\n<h4 id=\"JSON-encoded-requests\"><a href=\"#JSON-encoded-requests\" class=\"headerlink\" title=\"JSON-encoded requests\"></a>JSON-encoded requests</h4><p>Making an HTTP POST request with a JSON-encoded body<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">postJSON</span>(<span class=\"params\">url, data, callback</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> request = <span class=\"keyword\">new</span> XMLHttpRequest();</span><br><span class=\"line\">    request.open(<span class=\"string\">\"POST\"</span>, url);</span><br><span class=\"line\">    request.onreadystatechange = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (request.readyState === <span class=\"number\">4</span> &amp; callback)</span><br><span class=\"line\">            callback(request);</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    request.setRequestHeader(<span class=\"string\">\"Content-Type\"</span>, <span class=\"string\">\"application/json\"</span>);</span><br><span class=\"line\">    request.send(<span class=\"built_in\">JSON</span>.stringify(data));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"Uploading-a-file\"><a href=\"#Uploading-a-file\" class=\"headerlink\" title=\"Uploading a file\"></a>Uploading a file</h4><p>One of the features of HTML forms is that when the user selects a file through an <code>&lt;input type=&quot;file&quot;&gt;</code> element, the form will send the content of that file in the body of the POST request it generates. <br></p>\n<p>There is no <code>File()</code> object constructor: scripts can only obtain File objects that represent files the user has selected. In browsers that support File objects, every <code>&lt;input type=&quot;file&quot;&gt;</code> element has a <code>files</code> property that is an array-like object of File objects. The drag-and-drop API also allows access to files that the user “drops” over an element, through the <code>dataTransfer.files</code> property of the drop event. <br></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// File Upload with an HTTP POST request</span></span><br><span class=\"line\"></span><br><span class=\"line\">whenReady(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> elts = <span class=\"built_in\">document</span>.getElementsByTagName(<span class=\"string\">\"Input\"</span>);</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt; elts.length; i++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> input = elts[i];</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (input.type !== <span class=\"string\">\"file\"</span>) <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> url = input.getAttribute(<span class=\"string\">\"data-uploadto\"</span>);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!url) <span class=\"keyword\">continue</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        input.addEventListener(<span class=\"string\">\"change\"</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">var</span> file = <span class=\"keyword\">this</span>.files[<span class=\"number\">0</span>];</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!file) <span class=\"keyword\">return</span>;</span><br><span class=\"line\">            <span class=\"keyword\">var</span> xhr = <span class=\"keyword\">new</span> XMLHttpRequest();</span><br><span class=\"line\">            xhr.open(<span class=\"string\">\"POST\"</span>, url);</span><br><span class=\"line\">            xhr.send(file);</span><br><span class=\"line\">        &#125;, <span class=\"literal\">false</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>The File type is a subtype of the more general Blob type.</p>\n<h4 id=\"multipart-form-data-requests\"><a href=\"#multipart-form-data-requests\" class=\"headerlink\" title=\"multipart/form-data requests\"></a>multipart/form-data requests</h4><p>When HTML forms include file upload elements and other elements as well, the browser cannot use ordinary form encoding and must POST the form using a special content-type known as “multipart/form-data”. This encoding involves the use of long “bounary” strings to separate the body of the request into multiple parts. <br></p>\n<p>XHR2 defines a new FormData API that makes multiplart request bodies simple. First, create a FormData object with the <code>FormData()</code> constructor and then call the <code>append()</code> method of that object as many times as necessary to add the individual “parts” to the request. Fianlly, pass the FormData object to the <code>send()</code> method. The <code>send()</code> method will define an appropriate boundary string and set the “Content-type” header for the request. </p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">postFormData</span>(<span class=\"params\">url, data, callback</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> FormData === <span class=\"string\">\"undefined\"</span>)</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(<span class=\"string\">\"FormData is not implemented\"</span>);</span><br><span class=\"line\">    <span class=\"keyword\">var</span> request = <span class=\"keyword\">new</span> XMLHttpRequest();            <span class=\"comment\">// New HTTP request</span></span><br><span class=\"line\">    request.open(<span class=\"string\">\"POST\"</span>, url);                     <span class=\"comment\">// POST to the specified url</span></span><br><span class=\"line\">    request.onreadystatechange = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;      <span class=\"comment\">// A simple event handler.</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (request.readyState === <span class=\"number\">4</span> &amp;&amp; callback)  <span class=\"comment\">// When response is complete</span></span><br><span class=\"line\">            callback(request);                     <span class=\"comment\">// ...call the callback.</span></span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> formdata = <span class=\"keyword\">new</span> FormData();</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> name <span class=\"keyword\">in</span> data) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!data.hasOwnProperty(name)) <span class=\"keyword\">continue</span>;  <span class=\"comment\">// Skip inherited properties</span></span><br><span class=\"line\">        <span class=\"keyword\">var</span> value = data[name];</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> value === <span class=\"string\">\"function\"</span>) <span class=\"keyword\">continue</span>; <span class=\"comment\">// Skip methods</span></span><br><span class=\"line\">        <span class=\"comment\">// Each property becomes one \"part\" of the request.</span></span><br><span class=\"line\">        <span class=\"comment\">// File objects are allowed here</span></span><br><span class=\"line\">        formdata.append(name, value);              <span class=\"comment\">// Add name/value as one part</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// Send the name/value pairs in a multipart/form-data request body. Each</span></span><br><span class=\"line\">    <span class=\"comment\">// pair is one part of the request. Note that send automatically sets</span></span><br><span class=\"line\">    <span class=\"comment\">// the Content-Type header when you pass it a FormData object</span></span><br><span class=\"line\">    request.send(formdata); </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"HTTP-Progress-Events\"><a href=\"#HTTP-Progress-Events\" class=\"headerlink\" title=\"HTTP Progress Events\"></a>HTTP Progress Events</h3><p>The XMLHttpRequest object triggers different types of events at different phases of the request so that it is no longer necessary to check the <code>readyState</code> property. <br></p>\n<p>In browsers that support them, these new events triggered as follows. When the <code>send()</code> method is called, a single loadstart event is fired. While the server’s response is being downloaded, the XMLHttpRequest object fires progress events, typically every 50 ms or so, and you can use these events to give the user feedback about the progress of the request. <br></p>\n<p>A complete request is not necessarily a successful request, and your handler for the load event should check the <code>status</code> code of the XMLHttpRequest object to ensure that you received a HTTP “200 OK” response rather than a “404 Not Found” response, for example. <br></p>\n<p>There are three ways that an HTTP request can fail to complete, and three corresponding events. If a request times out, the timeout event is triggered. If a request is aborted, the abort event is triggered. Finally, other network errors, such as too many redirects, can prevent the completion of a request, and the error event is trggered when this happens. <br></p>\n<p>You can call the <code>addEventListener()</code> method of the XMLHttpRequest object register handlers for each of these progress events. If you have only one handler for each kind of events, it is generally easier to just set the corresponding handler property, such as <code>onprogress</code> and <code>onload</code>. <br></p>\n<p>The event object associated with these progress events has three useful properties in addition to the normal Event object properties like <code>type</code> and <code>timestamp</code>. The <code>loaded</code> property is the number of bytes that have been transferred so far. The <code>total</code> property is the total length (in bytes) of the data to be transferred, from the “Content-Length” header, or 0 if the content length is not known. Finally, the <code>lengthComputable</code> property is <code>true</code> if the content length is known and is <code>false</code> otherwise. Obviously, the <code>total</code> and <code>loaded</code> properties are particularly useful in progress event handlers:<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">request.onprogress = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">e</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (e.lengthComputable) </span><br><span class=\"line\">        progress.innerHTML = <span class=\"built_in\">Math</span>.round(<span class=\"number\">100</span>*e.loaded/e.total) + <span class=\"string\">\"% Complete\"</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"Upload-progress-events\"><a href=\"#Upload-progress-events\" class=\"headerlink\" title=\"Upload progress events\"></a>Upload progress events</h4><p>In browsers that have implemented this feature, the XMLHttpRequest object will have an <code>upload</code> property is an object that defines an <code>addEventListener()</code> method and defines a full set of progress event properties, such as <code>onpregress</code> and <code>onload</code>. <br></p>\n<p>You can use the upload event handlers just as you would use the regular progress event handlers. For an XMLHttpRequest to object <code>x</code>, set <code>x.onprogress</code> to monitor the download progress of the resoponse. And set <code>x.upload.onprogress</code> to monitor the upload progress of the request. </p>\n<h3 id=\"Aborting-Requests-and-Timeouts\"><a href=\"#Aborting-Requests-and-Timeouts\" class=\"headerlink\" title=\"Aborting Requests and Timeouts\"></a>Aborting Requests and Timeouts</h3><p>You can cancel an HTTP request in process by calling the <code>abort()</code> method of the XMLHttpRequest object.  <br></p>\n<p>Suppose you’re using XMLHttpRequest to request auto-complete suggestions for a text input field. If the user types a new character into the field before the server’s suggestions can arrive, then the pending request is no longer interesting and can be aborted. <br></p>\n<p>XHR2 defines a <code>timeout</code> property that specifies a time in ms after which a request will automatically be aborted and also defines a timeout event that is supposed to be triggered when such a timeout occurs. <br></p>\n<h3 id=\"Cross-Origin-HTTP-Requests\"><a href=\"#Cross-Origin-HTTP-Requests\" class=\"headerlink\" title=\"Cross-Origin HTTP Requests\"></a>Cross-Origin HTTP Requests</h3><p>The XMLHttpRequest objectv can normally issue HTTP requests only to the server from which the document that uses it was downloaded. With XMLHttpRequest, document contents are always exposed through the <code>responseText</code> property, so the same-origin policy cannot allow XMLHttpRequest to make cross-origin requests. <br></p>\n<p>XHR2 allows cross-origin requests to websites that opt-in by sending appropriate CORS headers in their HTTP responses. <br></p>\n<p>Although there is nothing you have to do to make CORS-enabled cross-origin requests work, there are a few security details worth understanding. First, if you pass a username and password to the XMLHttpRequest <code>open()</code> method, they will never be sent with a cross-origin request (that would enable distributed password-cracking attempts). In addition, cross-origin requests do not normally include any other user credentials either: cookies and HTTP authentication tokens are not normally sent as part of the request and any cookies received as part of a cross-origin response are discarded. If your cross-origin request requires these kinds of credentials to succeed, you must set the <code>withCredentials</code> property of the XMLHttpRequest to <code>true</code> before you <code>send()</code> the request. It is uncommon to have to do this, but testing for the presence of the <code>withCredentials</code> property is a way to test for CORS support in your browser. <br></p>\n<h2 id=\"HTTP-by-lt-script-gt-JSONP\"><a href=\"#HTTP-by-lt-script-gt-JSONP\" class=\"headerlink\" title=\"HTTP by &lt;script&gt; : JSONP\"></a>HTTP by <code>&lt;script&gt;</code> : JSONP</h2><p>The introduction to this chapter methioned that a <code>&lt;script&gt;</code> element can be used as an Ajax transport mechanism: simply set the <code>src</code> attribute of a <code>&lt;script&gt;</code> and the browser will generate an HTTP request to download the URL you specify. <code>&lt;script&gt;</code> elements are useful Ajax transports for one primary reason: they are not subject to the same origin policy, so you can use them to request data from servers other than you own. A secondary reason to use <code>&lt;script&gt;</code> elements is that they automatically decode response bodies that consist of JSON-encoded data. <br></p>\n<p>The technique of using a <code>&lt;script&gt;</code> elements as an Ajax transport has come to be known as JSONP: it works when the response body of the HTTP request is JSON-encoded. The “P” stands for “padding” or “prefix”. <br></p>\n<p>If you enable CORS on your server, cross-origin documents in new browsers can also use your service with XMLHttpRequest. Cross-origin documents in older browsers that do not support CORS can only access your service with a <code>&lt;script&gt;</code> element, however.  <br></p>\n<h2 id=\"Comet-with-Server-Sent-Events\"><a href=\"#Comet-with-Server-Sent-Events\" class=\"headerlink\" title=\"Comet with Server-Sent Events\"></a>Comet with Server-Sent Events</h2><p>The Server-Sent Events draft standard defines an EventSource objectv that makes Comet applications trivial to write. Simply pass a URL to the <code>EventSource()</code> constructor and then listen for message events on the returned object: </p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> ticker = <span class=\"keyword\">new</span> EventSource(<span class=\"string\">'stockprices.php'</span>);</span><br><span class=\"line\">ticker.onmessage = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">e</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> type = e.type;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> data = e.data;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>The event object associated with a message event has a <code>data</code> property that holds whatever string the server sent as the payload for this event. The event object also has a <code>type</code> property like all event objects do. The default value is “message”, but the event source can specify a differrent string for the property. A single <code>onmessage</code> event handler receives all events from given server event source, and can dispatch them, if necessary, based on their <code>type</code> property. <br></p>\n<p>The Server-sent Event protocol is strightforward. The client initiates a connection to the server (when it creates the <code>EventSource</code> object) and the server keeps this connection open. When an event occurs, the server writes lines of text to the connection. <br></p>\n<p>There are some additional details to the protocol that allows events to be given IDs and allow a reconnecting client to tell the server that the ID of the last event it received was, so that a server can resend any events it missed. <br></p>\n<p>One obvious application for the Comet architecture is online chat: a chat client can post new messages to the chat room with XMLHttpRequest and can subsribe to the stream of chatter with an EventSource object. <br><br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\"><span class=\"built_in\">window</span>.onload = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// Take care of some UI details</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> nick = prompt(<span class=\"string\">\"Enter your nickname\"</span>);     <span class=\"comment\">// Get user's nickname</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> input = <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">\"input\"</span>); <span class=\"comment\">// Find the input field</span></span><br><span class=\"line\">    input.focus();                                <span class=\"comment\">// Set keyboard focus</span></span><br><span class=\"line\">    <span class=\"comment\">// Register for notification of new messages using EventSource</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> chat = <span class=\"keyword\">new</span> EventSource(<span class=\"string\">\"/chat\"</span>);</span><br><span class=\"line\">    chat.onmessage = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">event</span>) </span>&#123;            <span class=\"comment\">// When a new message arrives</span></span><br><span class=\"line\">        <span class=\"keyword\">var</span> msg = event.data;                     <span class=\"comment\">// Get text from event object</span></span><br><span class=\"line\">        <span class=\"keyword\">var</span> node = <span class=\"built_in\">document</span>.createTextNode(msg);  <span class=\"comment\">// Make it into a text node</span></span><br><span class=\"line\">        <span class=\"keyword\">var</span> div = <span class=\"built_in\">document</span>.createElement(<span class=\"string\">\"div\"</span>);  <span class=\"comment\">// Create a &lt;div&gt;</span></span><br><span class=\"line\">        div.appendChild(node);                    <span class=\"comment\">// Add text node to div</span></span><br><span class=\"line\">        <span class=\"built_in\">document</span>.body.insertBefore(div, input);   <span class=\"comment\">// And add div before input</span></span><br><span class=\"line\">        input.scrollIntoView();                   <span class=\"comment\">// Ensure input elt is visible</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// Post the user's messages to the server using XMLHttpRequest</span></span><br><span class=\"line\">    input.onchange = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;                 <span class=\"comment\">// When user strikes return</span></span><br><span class=\"line\">        <span class=\"keyword\">var</span> msg = nick + <span class=\"string\">\": \"</span> + input.value;      <span class=\"comment\">// Username plus user's input</span></span><br><span class=\"line\">        <span class=\"keyword\">var</span> xhr = <span class=\"keyword\">new</span> XMLHttpRequest();           <span class=\"comment\">// Create a new XHR</span></span><br><span class=\"line\">        xhr.open(<span class=\"string\">\"POST\"</span>, <span class=\"string\">\"/chat\"</span>);                <span class=\"comment\">// to POST to /chat.</span></span><br><span class=\"line\">        xhr.setRequestHeader(<span class=\"string\">\"Content-Type\"</span>,      <span class=\"comment\">// Specify plain UTF-8 text</span></span><br><span class=\"line\">                             <span class=\"string\">\"text/plain;charset=UTF-8\"</span>);</span><br><span class=\"line\">        xhr.send(msg);                            <span class=\"comment\">// Send the message</span></span><br><span class=\"line\">        input.value = <span class=\"string\">\"\"</span>;                         <span class=\"comment\">// Get ready for more input</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">&lt;<span class=\"regexp\">/script&gt;</span></span><br></pre></td></tr></table></figure></p>\n","prev":{"title":"Angular ViewChild","slug":"view-child"},"next":{"title":"CSS Specificity and Cascade","slug":"css-specificity"},"link":"https://whitefusion.github.io/post/js-scripted-http"}