{"title":"Javascript: Objects and variable Intro","date":"2018-07-02T14:54:01.000Z","excerpt":"","slug":"javascript-objects-variable-intro","comments":true,"tags":["note","javascript"],"categories":["language core"],"updated":"2018-07-04T16:24:55.599Z","content":"<blockquote>\n<p>This is the reading note for “Chapter 3 (3.5 to end): Types, values and variables, Javascript: The definitive guide 5th edition”. <br></p>\n</blockquote>\n<h2 id=\"The-global-object\"><a href=\"#The-global-object\" class=\"headerlink\" title=\"The global object\"></a>The global object</h2><p>Previous section has divided the JS types into primitive types and object types - objects, arrays and functions. <br></p>\n<p>Global object serves an important purpose: the properties of this object are the globally defined symbols that ar3e available to a JS program. When JS interpreter starts, it creates a new global object and gives it an initial set of properties that define:</p>\n<ul>\n<li>global properties like <code>undefiend</code>, <code>infinity</code>, <code>NaN</code> …</li>\n<li>global functions like <code>isNaN()</code>, <code>parseInt()</code>, <code>eval()</code> …</li>\n<li>constructor functions like <code>Date()</code>, <code>RegExp()</code>, <code>Object()</code>, <code>Array()</code> …</li>\n<li>global objects like <code>Math</code> and <code>JSON</code></li>\n</ul>\n<p>In top-level code - JS code that is not part of a function - you can use JS keyword <code>this</code> to refer to the global object:<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> global = <span class=\"keyword\">this</span>; <span class=\"comment\">// define a global variable to refer to the global object.</span></span><br></pre></td></tr></table></figure></p>\n<p>In client-side JS, the <code>Window</code> object serves as the global object for all JS code contained in the browser widnows it represents. This global <code>Window</code> has a self-referential <code>window</code> property that can be used insetad of <code>this</code> to refer to the global object. <br></p>\n<p>Actually, if your code declares a global variable, that variable is a property of the global object. <br></p>\n<h2 id=\"Wrapper-objects\"><a href=\"#Wrapper-objects\" class=\"headerlink\" title=\"Wrapper objects\"></a>Wrapper objects</h2><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// A primitive type string, not an object, could have properties!!</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> s = <span class=\"string\">'hello world'</span>; <span class=\"comment\">// a string</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> word = s.substring(s.indexOf(<span class=\"string\">\" \"</span>)+<span class=\"number\">1</span>, s.length); <span class=\"comment\">// Use string properties</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> s = <span class=\"string\">'test'</span>;</span><br><span class=\"line\">s.len = <span class=\"number\">4</span>; <span class=\"comment\">// create a new object but then discarded. </span></span><br><span class=\"line\"><span class=\"keyword\">var</span> t = s.len; <span class=\"comment\">// return undefined. This could be used to tell primitive type from object type.</span></span><br></pre></td></tr></table></figure>\n<p>Whenever you try to refer to a property of a string <code>s</code>, JS converts the string value to an object as if by calling <code>new String(s)</code>. Once the property has been resolved, the newly created object is discarded. <br></p>\n<p>The temporary objects created when you access a property of a string, number, or boolean are known as <strong>wrapper objects</strong>. And it may occasionally be necessary to distinguish a string value from a String object or a number of boolean value from a Number or Boolean object. The <code>typeof</code> operator will aslo show the difference.  <br></p>\n<h2 id=\"Immutable-Primitive-Values-and-Mutable-Object-References\"><a href=\"#Immutable-Primitive-Values-and-Mutable-Object-References\" class=\"headerlink\" title=\"Immutable Primitive Values and Mutable Object References\"></a>Immutable Primitive Values and Mutable Object References</h2><p>There is a fundamental difference in JS between primitive values and objects (arrays, objects and functions). Primitives are immutable and are also compared by <em>value</em>. Meanwhile, objects are different than primitives. They are <em>mutable</em> and they are compared by reference. Two object values are the same if and only if they refer to the same underlying object. <br></p>\n<p>Assigning an object(or array) to a variable simply assigns the reference: it does not create a new copy of the object. If you want to make a new copy of an object or array, you must explicitly copy the properties of the object or the element like using a <code>for</code> loop or something equivalent. <br></p>\n<h2 id=\"Type-Conversions\"><a href=\"#Type-Conversions\" class=\"headerlink\" title=\"Type Conversions\"></a>Type Conversions</h2><p><img src=\"../images/type_conversion.png\" alt=\"type_conversion\"><br>The primitive-to-primitive conversions are relatively straightforward. The primitive-to-object conversions are straightforward: primitive values convert to their wrapper object. <br></p>\n<p>The <code>==</code> equality operator is flexible with its notion of equality.<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"literal\">null</span> == <span class=\"literal\">undefined</span> <span class=\"comment\">// equal.</span></span><br><span class=\"line\"><span class=\"string\">\"0\"</span> == <span class=\"literal\">false</span></span><br></pre></td></tr></table></figure></p>\n<p>Keep in mind that convertibility of one value to antoher does not imply equality of those two values. If <code>undefined</code> is used where a boolean value is expected, for example, it will convert to <code>false</code>. But this does not mean that <code>undefined == false</code>. </p>\n<h2 id=\"Explicit-Conversions\"><a href=\"#Explicit-Conversions\" class=\"headerlink\" title=\"Explicit Conversions\"></a>Explicit Conversions</h2><p>The simplest way to perform an explicit type conversion is to use the <code>Boolean(), Number(), String(), Object()</code> functions. Note that any value other than <code>null</code> or <code>undefined</code> has a <code>toString()</code> method and the result of this method is usually the same as that return by the <code>String()</code> function. <br></p>\n<p>Cretain JS operators perform implicit type conversions, and are sometimes fused for the purposes of type conversion. The unary <code>+</code> operator converts its operand to a number. </p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">x + <span class=\"string\">\"\"</span> <span class=\"comment\">// same as String()</span></span><br><span class=\"line\">+x <span class=\"comment\">// same as Nubmer(x)</span></span><br><span class=\"line\">!!x <span class=\"comment\">// same as Boolean(x)</span></span><br></pre></td></tr></table></figure>\n<p>The <code>toString()</code> method defined by the Number class accepts an optional argument that specifies a radix or base.<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> n = <span class=\"number\">17</span>;</span><br><span class=\"line\">binary_string = n.toString(<span class=\"number\">2</span>); <span class=\"comment\">// evaluates to '10001'</span></span><br><span class=\"line\">octal_string = <span class=\"string\">'0'</span>+n.toString(<span class=\"number\">8</span>); <span class=\"comment\">// evaluates to '021'</span></span><br><span class=\"line\">hex_string = <span class=\"string\">'0x'</span> + n.toString(<span class=\"number\">16</span>); <span class=\"comment\">// evaluates to '0x11'</span></span><br></pre></td></tr></table></figure></p>\n<p>To get a better control when working with financial or scientific data, there other number-to-string classes may help here. <code>toFixed()</code> converts a number to a string with a specified number of digits after the decimal point. <code>toExponential()</code> converts a number to a string using exponential notation, with one digit before the decimal point and a specified number of digits after the decimal point. <code>toPrecision()</code> converts a number to a string with the number of significant digits you specify. </p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> n =<span class=\"number\">123456.789</span>;</span><br><span class=\"line\">n.toFixed(<span class=\"number\">2</span>); <span class=\"comment\">// '123456.79'</span></span><br><span class=\"line\">n.toExponential(<span class=\"number\">3</span>);<span class=\"comment\">// '1.235e+5'</span></span><br><span class=\"line\">n.toPrecision(<span class=\"number\">4</span>); <span class=\"comment\">// '1.235e+5'</span></span><br></pre></td></tr></table></figure>\n<p>We also have <code>parseInt()</code> and <code>parseFloat()</code> functions to convert string to number. If a string begins with “0x” or “0X”, <code>parseInt()</code> interprets it as a hexadecimal number. It also accepts a second argument specifying the radix. <br><br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">parseInt</span>(<span class=\"string\">\"3 blind mice\"</span>) <span class=\"comment\">// =&gt; 3</span></span><br><span class=\"line\"><span class=\"built_in\">parseFloat</span>(<span class=\"string\">\" 3.14 meters\"</span>) <span class=\"comment\">// =&gt; 3.14</span></span><br><span class=\"line\"><span class=\"built_in\">parseInt</span>(<span class=\"string\">\"0xFF\"</span>) <span class=\"comment\">// =&gt; 255</span></span><br><span class=\"line\"><span class=\"built_in\">parseInt</span>(<span class=\"string\">\"-0xFF\"</span>) <span class=\"comment\">// =&gt; -255</span></span><br><span class=\"line\"><span class=\"built_in\">parseInt</span>(<span class=\"string\">\".1\"</span>) <span class=\"comment\">// =&gt; NaN</span></span><br><span class=\"line\">parseFlaot(<span class=\"string\">\"$72.47\"</span>) <span class=\"comment\">// =&gt; NaN</span></span><br><span class=\"line\"><span class=\"built_in\">parseInt</span>(<span class=\"string\">\"11\"</span>,<span class=\"number\">2</span>) <span class=\"comment\">// =&gt; 3</span></span><br><span class=\"line\"><span class=\"built_in\">parseInt</span>(<span class=\"string\">\"zz\"</span>, <span class=\"number\">36</span>); <span class=\"comment\">// =&gt; 1295</span></span><br></pre></td></tr></table></figure></p>\n<h2 id=\"Object-to-primitive-conversions\"><a href=\"#Object-to-primitive-conversions\" class=\"headerlink\" title=\"Object to primitive conversions\"></a>Object to primitive conversions</h2><p>All objects inherit two conversion methods. The first is <code>toString()</code> and the second is <code>valueOf()</code>. <br><br>Many classes define more specific versions of <code>toString()</code> method, like <code>Date(), RegExp</code> that convert object to a human-readable format. Similar things happened for <code>valueOf()</code>. <br><br>With those two functions, we can take a further look on object-to-string and object-to-number conversions. To convert an object to a string, JS takes to these steps:</p>\n<ul>\n<li>look at <code>toString()</code>, if not defined or no primitive returned,</li>\n<li>look at <code>valueOf()</code>, if no primitive returned.</li>\n<li><code>TypeError</code><br>To convert an object to a number, JS takes to these steps:</li>\n<li><code>valueOf()</code></li>\n<li><code>toString()</code></li>\n<li><code>TypeError</code></li>\n</ul>\n<h2 id=\"Variable-Declaration-and-Scope\"><a href=\"#Variable-Declaration-and-Scope\" class=\"headerlink\" title=\"Variable Declaration and Scope\"></a>Variable Declaration and Scope</h2><p>If the repeated declaration has an initializer, it acts as if it were simply an assignment statement, and a JS variable can hold a value of any type. <br></p>\n<p>The <em>scope</em> of a variable is the region of your program source code in which it is defined. A <em>global</em> variable has global scope; it is defined everywhere in your JS code. JS uses <em>function</em> scope: variables are visible within the function in which they are defined and within any functions that are nested within that function. <br><br>JS’s function scope means that all variables declared within a function are visible throughout the body of the function. This feature of JS is informally known as <strong>hoisting</strong>: JS code behaves as if all variable declarations in a function (but not any associated assignments) are ‘hoisted’ to the top of the function.<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> scope = <span class=\"string\">'global'</span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(scope); <span class=\"comment\">// undefined</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> scope = <span class=\"string\">'local'</span>;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(scope); <span class=\"comment\">// local</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>When you declare a global JS variable, what you are actually doing is defining a property of the global object. If you use <code>var</code> to declare the variable, the property that is created is nonconfigurable, which means that it cannot be deleted with the <code>delete</code> operator. <br><br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> truevar = <span class=\"number\">1</span>;</span><br><span class=\"line\"><span class=\"keyword\">delete</span> truevar; <span class=\"comment\">// =&gt; false</span></span><br><span class=\"line\"><span class=\"keyword\">this</span>.fakevar = <span class=\"number\">3</span>; </span><br><span class=\"line\"><span class=\"keyword\">delete</span> fakevar; <span class=\"comment\">// =&gt; true</span></span><br></pre></td></tr></table></figure></p>\n<p>JS is a <strong>lexically scoped</strong> language: the scope of a variable ca nbe thought of as the set of source code lines for which the variable is defined. Global variables are defined throughout the program. Local variables are defined throughout the function. Every chunk of JS code has a <strong>scope chain</strong> associated with it. This scope chain is a list or chain of objects that defines that variables that are ‘in scope’ for that code. When JS needs to look up the value of a variable <code>x</code>, it looks up the object in the chain one by one.<br><br>In top-level JS code, the scope chain consists of a single object, the global object. In a non-nested function, the scope chain consists of two objects. The first is the object that defines the functions’s parameters and local variables, and the second is global object. In a nested function, the scope chain has three or more objects. It is important to understand how this chain of objects is created. When a function is defined, it stores the scope chain then in effect. When that function is invoked, it creates a new object to store its local vars, and adds that new object to the stored scope chain to create a new, longer, chain that represetnts the scope for that function invocation. <br><br>It becomes more interesting for nested functions since each time the outer function is called, the inner function is defined again. A new scope object will be created for each invocation of the same function, even thoght the code are the same. </p>\n","next":{"title":"introducing-python-object-types","slug":"introducing-python-object-types"},"link":"https://whitefusion.github.io/post/javascript-objects-variable-intro"}