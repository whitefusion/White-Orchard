{"title":"Javascript: Number, String, Boolean, Null & Undefined","date":"2018-06-24T14:06:54.000Z","excerpt":"","slug":"Number-String-Boolean-Null-Undefined","comments":true,"tags":["note","javascript"],"categories":["language core"],"updated":"2018-06-25T14:28:58.877Z","content":"<blockquote>\n<p>This is the reading note for “ Chapter 3: Types, Values and Variables, Javascript: The definitive guide 5th edition”. <br></p>\n</blockquote>\n<h2 id=\"Numbers\"><a href=\"#Numbers\" class=\"headerlink\" title=\"Numbers\"></a>Numbers</h2><p>JS does not make a distinction between integer values and floating-point values. <strong>All numbers</strong> in JS are represented as a 64-bit floating-point values. <br></p>\n<p>When a number appears directly in a JS program, it’s called a <em>numeric literal</em>. </p>\n<h4 id=\"Integer-Literals\"><a href=\"#Integer-Literals\" class=\"headerlink\" title=\"Integer Literals\"></a>Integer Literals</h4><p>A hexadecimal literal begins with “0x” or “0X”, followed by a string of hexadecimal digits. A hexadecimal digit is one of the digits 0 through 9 or the letters a (or A) through f(or F), which represent values 10 through 15. <br></p>\n<p>Some implementations of JS allow you to specify integer literals in octal(base-8) format. An octal literal begins with the digit 0 and is followed by a sequence of digits, each between 0 and 7. <br></p>\n<h4 id=\"Arithmetic-in-JS\"><a href=\"#Arithmetic-in-JS\" class=\"headerlink\" title=\"Arithmetic in JS\"></a>Arithmetic in JS</h4><p>JS supports compolex mathematical opeartions through a set of functions and constants defined as properties of the <code>Math</code> object.<br></p>\n<p>Arithmetic in JS does not raise errors in case of overflow, underflow, or division by zero. The ‘overflow’ will have a return value <code>infinity</code> or <code>negative infinity</code>. The ‘underflow’ will have a return value <code>0</code> or <code>-0</code>. The ‘0/0’ will have a result as <code>NaN</code>. <code>NaN</code> also arises if you attempt to divide infinity by infinity, or take the square root of a negative number or use arithmetic operators with non-numeric operands that cannot be converted to numbers. <br></p>\n<p><code>NaN</code> has one unusual feature in JS: it does not compare equal to any other value, including itself. This means you can’t write <code>x == NaN</code> to determine whether the value of a variable x is <code>NaN</code>. Instead you should write <code>x!=x</code>. That expression will be true if, and only if, x is <code>NaN</code>. The function <code>isNaN()</code> is similar. <br></p>\n<p>The negative zero is also somewhat unusual. It compares equal to positive zero, which means that the two values are almost distiguishable, except when used as a divisor: <code>1/zero === 1/negz // =&gt; false: infinity and -infinity are not equal</code></p>\n<h4 id=\"Binary-floating-point-and-rounding-errors\"><a href=\"#Binary-floating-point-and-rounding-errors\" class=\"headerlink\" title=\"Binary floating-point and rounding errors\"></a>Binary floating-point and rounding errors</h4><p>The IEEE-754 floating point representation used by JS is a binary representation, which can exactly represent fractions like <code>1/2, 1/8 and 1/1024</code>. For example the decimal number 0.75 is represented as 0.11 in binary representation: 1x2^(-1)+1x2^(-2). Unfortunately, binary floating-point representations cannot exactly represent numbers as simple as 0.1 since it cannot be expanded as a base-2 Taylor series with finite addons.<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> x = <span class=\"number\">.3</span> - <span class=\"number\">.2</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> y = <span class=\"number\">.2</span> - <span class=\"number\">.1</span></span><br><span class=\"line\">x == y <span class=\"comment\">// false</span></span><br><span class=\"line\">x == <span class=\"number\">.1</span> <span class=\"comment\">// false</span></span><br><span class=\"line\">y == <span class=\"number\">.1</span> <span class=\"comment\">// true</span></span><br></pre></td></tr></table></figure></p>\n<p>It affects any programming language that uses binary floating-point numbers. The computed values are adequate for almost any purposes, the problem arises when we attempt to compare values for equality.  <br></p>\n<h4 id=\"Dates-and-Times\"><a href=\"#Dates-and-Times\" class=\"headerlink\" title=\"Dates and Times\"></a>Dates and Times</h4><p><code>Date()</code> constructor for creating objects that represent dates and times. It comes with a handy API which cannot be referred from docs.</p>\n<h2 id=\"Text\"><a href=\"#Text\" class=\"headerlink\" title=\"Text\"></a>Text</h2><p>A <em>string</em> is an immutable ordered sequence of 16-bit values, each of which typically represents a Unicode character. <br></p>\n<p>The most commonly used Unicode characters have codepoints that fit in 16 bits and can be represented by a single element of a string. Unicode characters whose codepoints do not fit in 16 bits are encoded following the rules of UTF-16 as a sequence (known as a ‘surrogate pair’) of two 16-bit values. This means that a JS string of length 2 (two 16-bit values) might represent only a single Unicode character:<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> e = <span class=\"string\">'\\ud835\\udc52'</span> <span class=\"comment\">// look like a length-1 string but it is length 2.</span></span><br></pre></td></tr></table></figure></p>\n<p>In short, we have a set of Unicode character. Each of them has a code point (<code>0Xxxxx or 0Xxxxxx</code>). Then we encode(map) them to UTF-16 encoding, but not all of them can fit in 16 bits.</p>\n<h4 id=\"Escape-sequences-in-string-literals\"><a href=\"#Escape-sequences-in-string-literals\" class=\"headerlink\" title=\"Escape sequences in string literals\"></a>Escape sequences in string literals</h4><p>The backslash character (<code>\\</code>) has a special purpose in JS strings. Combined with the character that follows it, it represents a character that is not otherwise representable within the string. <br></p>\n<p>the <code>\\&#39;</code> is the single quote character. Tqo escape sequences are generic and can be used to represent any character by sepcifying its Latin-1 or Unicode character code as a hexadecimal number. For Latin-1 encoding, the sequence <code>\\xA9</code> represents the copyright symbol, which has the Latin-1 encoding given by the hexadecimal number A9.</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">\\xXX: The Latin-1 character specified by the two hexadecimal digits XX</span><br><span class=\"line\">\\uXXXX The unicode character specified by the four hexadecimal digits XXXX</span><br></pre></td></tr></table></figure>\n<h4 id=\"Working-with-strings\"><a href=\"#Working-with-strings\" class=\"headerlink\" title=\"Working with strings\"></a>Working with strings</h4><p>Remember that strings are immutable in JS. Methods like <code>replace()</code> and <code>toUpperCase()</code> return new strings: they do not modify the string on which they are invoked. </p>\n<h4 id=\"Pattern-Matching\"><a href=\"#Pattern-Matching\" class=\"headerlink\" title=\"Pattern Matching\"></a>Pattern Matching</h4><p>JS defines a <code>RegExp()</code> constructor for creating objects that represent texual patterns. JS adopts Perl’s syntax for regular expressions. Like Dates, it’s simply a specialized kind of object, with a useful API. </p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> text = <span class=\"string\">\"testing: 1, 2, 3\"</span>;   <span class=\"comment\">// Sample text</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> pattern = <span class=\"regexp\">/\\d+/g</span>             <span class=\"comment\">// Matches all instances of one or more digits</span></span><br><span class=\"line\">pattern.test(text)               <span class=\"comment\">// =&gt; true: a match exists</span></span><br><span class=\"line\">text.search(pattern)             <span class=\"comment\">// =&gt; 9: position of first match</span></span><br><span class=\"line\">text.match(pattern)              <span class=\"comment\">// =&gt; [\"1\", \"2\", \"3\"]: array of all matches</span></span><br><span class=\"line\">text.replace(pattern, <span class=\"string\">\"#\"</span>);      <span class=\"comment\">// =&gt; \"testing: #, #, #\"</span></span><br><span class=\"line\">text.split(<span class=\"regexp\">/\\D+/</span>);               <span class=\"comment\">// =&gt; [\"\",\"1\",\"2\",\"3\"]: split on non-digits</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"Boolean\"><a href=\"#Boolean\" class=\"headerlink\" title=\"Boolean\"></a>Boolean</h2><p>Any JS value can be converted to a boolean value. The following values convert to, and therefore work like, <code>false</code>:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">undefined</span><br><span class=\"line\">null</span><br><span class=\"line\">0</span><br><span class=\"line\">-0</span><br><span class=\"line\">NaN</span><br><span class=\"line\">&quot;&quot; // empty string</span><br></pre></td></tr></table></figure></p>\n<p>All other values, including all objects (and arrays) convert to, and work like, <code>true</code>. </p>\n<h2 id=\"Null-and-undefined\"><a href=\"#Null-and-undefined\" class=\"headerlink\" title=\"Null and undefined\"></a>Null and undefined</h2><p><code>null</code> is the absence of a value. Using the <code>typeof</code> operator on <code>null</code> returns “object”, indicating that <code>null</code> can be thought of as a special object value that indicates “no objects”. <br></p>\n<p>The <code>undefined</code> value represents a deeper kind of absence. It is the value of variables that have not been initialized and the value you get when you query the value of an object property or array element that does not exist. The <code>undefined</code> value is also return by functions that have no return value, and the value of function parameters for which no argument is supplied. If you apply the <code>typeof</code> operator to the undefined value, it returns ‘undefined’, indicating this value is the sole member of a special type. Neither <code>null</code> or <code>undefined</code> have any properties or methods. <br></p>\n<p>You might consider <code>undefined</code> to represent a system-level, unexpected, or error-like absence of value and <code>null</code> to represent program-level, normal or expected absence of value. </p>\n","next":{"title":"Python: How do we run Python program","slug":"How-do-we-run-Python-program"},"link":"https://whitefusion.github.io/post/Number-String-Boolean-Null-Undefined"}