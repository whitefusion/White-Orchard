{"title":"The Window Object","date":"2018-09-15T08:14:52.000Z","excerpt":"","slug":"js-window-object","comments":true,"tags":["javascript","note"],"updated":"2018-09-15T12:22:42.339Z","content":"<blockquote>\n<p>This is the reading note for “Chapter 14: the Window Object, Javascript: The definitive guide 5th edition”. <br></p>\n</blockquote>\n<p>##Timers<br><code>setTimeout()</code> and <code>setInterval()</code> allow you to register a function to be invoked once or repeatedly after a specified amount of time has elapsed. <code>setTimeout()</code> returns a value that can be passed to <code>clearTimeout()</code> to cancel the execution of the scheduled function. Similary, <code>setInterval()</code> returns a value that can be passed to <code>clearInterval()</code> to cancel any future invocations of the scheduled function. </p>\n<p>##Browser Location and Navigation<br>The <code>location</code> property of the Window object refers to a Location object, which represents the current URL of the document displayed in the window, and which also defines methods for making the window a new document. <br></p>\n<p>The <code>location</code> property of the Document object also refers to be the Location object:<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">window</span>.location === <span class=\"built_in\">document</span>.location <span class=\"comment\">// always true</span></span><br></pre></td></tr></table></figure></p>\n<p>The Document object also has a <code>URL</code> property, which is a static string that holds the URL of the document when it was first loaded. If you navigate to fragment idetifiers within the document, the Location object is updated to reflect this, but the <code>document.URL</code> property remains unchanged. </p>\n<h3 id=\"Parsing-URLs\"><a href=\"#Parsing-URLs\" class=\"headerlink\" title=\"Parsing URLs\"></a>Parsing URLs</h3><p>The <code>href</code> property of the Location object is a string that contains the complete text of the URL. The <code>toString()</code> method of the Location object returns the value of the <code>href</code> property, so in contexts that will implicitly invoke <code>toString()</code>, you can just write <code>location</code> rather than <code>location.href</code>.<br></p>\n<p>Other properties of this object - <code>protocol</code>, <code>host</code>, <code>hostname</code>, <code>pathname</code>, <code>port</code>, <code>search</code>, and <code>hash</code> - specify the various individual parts of the URL. They are known as ‘URL decomposition’ properties. The <code>hash</code> property returns the ‘fragment identifier’ portion of the URL, if there is one: a hash mark followed by an element ID. The <code>search</code> property is similar. It returns the portion of the URL that starts with a question mark: often some sort of query string. </p>\n<h3 id=\"Loading-New-documents\"><a href=\"#Loading-New-documents\" class=\"headerlink\" title=\"Loading New documents\"></a>Loading New documents</h3><p>The <code>assign()</code> method of the Location object makes the window load and display the document at the URL you specify. The <code>replace()</code> method is similar, but it removes the current document from the browsing history before loading the new document. When a script unconditionally loads a new document, the <code>replace()</code> method is often a better choice than <code>assign()</code>. Otherwise, the Back button would take the browser back to the original document, adn the same script would again load the new document. <br></p>\n<p>Notice that the URL passed to <code>replace()</code> is a relative one. Relative URLs are interpreted relative to the page in which they appear, just as they would be if they were used in a hyperlink. <br></p>\n<p>In addition to the <code>assign()</code> and <code>replace()</code> methods, the Location object also defines <code>reload()</code>, which makes the browser reload the document. <br></p>\n<p>A more traditional way to make the browser navigate to a new page is to simply assign the new URL directly to the location property.<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// direct full </span></span><br><span class=\"line\">location = <span class=\"string\">'http://www.google.com'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// relative</span></span><br><span class=\"line\">location = <span class=\"string\">'page2.html'</span>;</span><br></pre></td></tr></table></figure></p>\n<p>A bare fragment identifier is a special kind of relative URL that does not cause the browser to load a new document but simply scroll to display a new section of the document. The identifier <code>#top</code> is a special case: if no document element has the ID “top”, it makes the browser jump to the start of the document. The URL decomposition properties of the Location object are writable, and setting them changes the location URL and also causes the browser to load a new document. </p>\n<h2 id=\"Browsing-History\"><a href=\"#Browsing-History\" class=\"headerlink\" title=\"Browsing History\"></a>Browsing History</h2><p>The <code>history</code> property of the Window object refers to the History object for the window. The History object models the browsing history of a window as a list of documents and document state.  The <code>length</code> property of the History object specifies the number of elements in the browsing history list, but for security reasons scripts are not allowed to access the stored URLs. (If they could, any scripts could snoop through your browsing history) <br></p>\n<p>The History object has <code>back()</code> and <code>forward()</code> methods that behave like the browser’s Back and Forward buttons do: they make the browser go backward or forward one step in tis browsing history. A thrid method, <code>go()</code>, takes an integer argument and can skip any number of pages forward (for positive arguments) or backward (for negative arguments) in history list <code>history.go(-2)</code>.<br><br></p>\n<p>If a window contains child windows, the browsing histories of the child windows are chronologically interleaved with the history of the main window. This means that calling <code>history.back()</code> on the main window may cause one of the child windows to navigate back to a previously displayed document but leave the main window in its current state. Modern web applications can dynamically alter their own content without loading a new document. <br></p>\n<h2 id=\"Browser-and-Screen-Information\"><a href=\"#Browser-and-Screen-Information\" class=\"headerlink\" title=\"Browser and Screen Information\"></a>Browser and Screen Information</h2><p>Scripts sometimes need to obtain information about the web browser in which they are running or the desktop on which the browser appears. The <code>navigator</code> and <code>screen</code> properties of the Window object contain these information. Those properties refer toe Navigator and Screen objects, respectively, and these objects provide information that allows a script to customize its behavior based on its environment. <br></p>\n<h3 id=\"The-Navigator-Object\"><a href=\"#The-Navigator-Object\" class=\"headerlink\" title=\"The Navigator Object\"></a>The Navigator Object</h3><p>The <code>navigator</code> property of a Window object refers to a Navigator object that contains browser vendor and version number information. <br></p>\n<p>In the past, the Navigator object was commonly used by scripts to determine if they were running in Internet Explorer or Netscape. This ‘browser-sniffing’ approach is problematic because it requires constant tweaking as new browsers and new versions of existing browsers are introduced. Today, feature testing is preferred: rather than making assumptions about particular browser versions and their features, you simply test for the feature you need. <br></p>\n<p>Browser sniffing is sometimes still valuable, however, such as when you need to work around a specific bug that exists in a specific version of a specific browser. The Navigator object has four properties that provide information about the browser that is running:</p>\n<ul>\n<li><code>appName</code>: The full name of the web browser. In IE, this is ‘Microsoft Internet Explorer’. In Firefox, this property is ‘Netscape’.</li>\n<li><code>appVersion</code>: This property typically begins with a number and follows that with a detailed string that contains browser vendor and version information. This number at the start of the string is often 4.0 or 5.0 to indicate generic compatibility with fourth- and fifth- generation browsers.</li>\n<li><code>userAgent</code>: The string that the browser sends in its <code>USER-AGENT</code> HTTP header. This property typically contains all the information in <code>appVersion</code> and may contain additional details as well. </li>\n<li><code>platform</code>: A string that identifies the operating system (and possibly the hardware) on which the browser is running. </li>\n</ul>\n<h3 id=\"The-Screen-Object\"><a href=\"#The-Screen-Object\" class=\"headerlink\" title=\"The Screen Object\"></a>The Screen Object</h3><p>The <code>screen</code> object property of a Window object refers to a Screen object that provides information about the size of the user’s display and the number of colors available on it. The <code>width</code> and <code>height</code> properties specify the size of the display in pixels. The <code>availWidth</code> and <code>availHeight</code> properties specify the displaysize that is actually available.<br></p>\n<p>The <code>window.screen</code> property and the Screen object to which it refers are both nonstandard but widely implemented. You might use Screen object to determine whether your web app is running in a small form factor device such as a notebook computer. </p>\n<h2 id=\"Dialog-Boxes\"><a href=\"#Dialog-Boxes\" class=\"headerlink\" title=\"Dialog Boxes\"></a>Dialog Boxes</h2><p><code>alert()</code> displays a message to the user and waits for the user to dismiss the dialog. <code>confirm()</code> displays a message, waits for the user to click an OK or Cancel button and returns a boolean value. And <code>prompt()</code> displays a message, waits for the user to enter a string, and returns that string.<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">do</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> name = prompt(<span class=\"string\">\"waht is your name?\"</span>); <span class=\"comment\">// get a string</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> correct = confirm(<span class=\"string\">\"You entered '\"</span> + name + <span class=\"string\">\"'.\\n\"</span> + <span class=\"string\">\"Click Okay to proceed or Cancel to re-enter\"</span> ); <span class=\"comment\">// get boolean</span></span><br><span class=\"line\">&#125; <span class=\"keyword\">while</span>(!correct)</span><br><span class=\"line\">alert(<span class=\"string\">\"Hello, \"</span> + name); <span class=\"comment\">// Display a plain message</span></span><br></pre></td></tr></table></figure></p>\n<p>Although they are easy to use, good design dictates that you use them sparingly. The only common use for these methods today is debugging. <br></p>\n<p>The <code>confirm()</code> and <code>prompt()</code> methods <em>block</em> - that is, these methods do not return until the user dismisses the dialog boxes they display. This means that when you pop up one of these boxes, your code stop running, and the currently loading document, if any, stops loading until the user responds with the requested input. <br></p>\n<p>A more complicated method, <code>showModalDialog()</code>, displays a modal dialog box containing HTML formatted content and allows arguments to be passed to, and a value returned from, the dialog. <code>showModalDialog()</code> displays a modal dialog in a browser window of its own. The first argument is the URL that specifies the HTML content of the dialog box. The second argument is an arbitrary value that will be made available to scripts in the dialog as the value of the <code>window.dialogArguments</code> property. The third arugment is a nonstandard list of semicolon-separated name=value pairs that, if supported, may configure the size or other attributes of the dialog. <br></p>\n<p>The window displayed by this method is modal, and the call to <code>showModalDialog()</code> does not return until the window is closed. When the window closes, the value of the <code>window.returnValue</code> property becomes the return value of the method call. The HTML content of the dialog must typically include an OK button that sets <code>returnValue</code>, if desired, and calls <code>window.close()</code>.</p>\n<h2 id=\"Error-Handling\"><a href=\"#Error-Handling\" class=\"headerlink\" title=\"Error Handling\"></a>Error Handling</h2><p>The <code>onerror</code> property of a Window object is an event handler that is invoked when an uncaught exception propagates all the way up the call stack and an error message is about to be displayed in the browser’s JS console. If you assign a function to this property, the function is invoked whenever a JS error occurs in that widnow: the function you assign becomes an error handler for the window. <br></p>\n<p>The first argument to <code>window.onerror</code> is a message describing the error. The second argument is a string that contains the URL of the JS code that caused the error. The third argument is the line number within the document where the error occurred. <br></p>\n<p>If the <code>onerror</code> handler returns <code>false</code>,  it tells the browser that the handler has handled the error and that no further action is necessary - in other words, the browser should not display its own error message. Unfortunately, for historical reasons, an error handler in Firefox must return <code>true</code> to indicate that it has handled the error. <br><br>This property is rarely used in modern code, use <code>try/catch</code> instead.</p>\n<h2 id=\"Document-Elements-As-Window-Properties\"><a href=\"#Document-Elements-As-Window-Properties\" class=\"headerlink\" title=\"Document Elements As Window Properties\"></a>Document Elements As Window Properties</h2><p>If you name an element in your HTML document using the <code>id</code> attribute, and if the Window object does not already have a property by that name, the Window object is given a nonenumerable property whose name is the value of the <code>id</code> attribute and whose value is the HTMLElement object that represents that document element. This means that the <code>id</code> attributes you use in your HTML documents become global variables accessible to your scripts. If your document includes the element <code>&lt;button id ==&quot;okay&quot;&gt;</code>, you can refer to that element using the global variable <code>okay</code>. <br></p>\n<p>Similarly, if your HTML document includes an element whose <code>id</code> is “x” and you also declare and assign a value to the global variable <code>x</code> in your code, the explicitly declared variable will hide the implicit element variable. If the variable is declared in a script that appears before the named element, its existence will prevent the element from getting a window property of its own. And if the variable is declared in a script that appears after the named element, you explicit assignment to the variable overwrites the implicit value of the property. <br></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> ui = [<span class=\"string\">'input'</span>, <span class=\"string\">'prompt'</span>, <span class=\"string\">'heading'</span>];</span><br><span class=\"line\">ui.forEach( <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">id</span>) </span>&#123;</span><br><span class=\"line\">    ui[id] = <span class=\"built_in\">document</span>.getElementById(id);</span><br><span class=\"line\">&#125; )</span><br></pre></td></tr></table></figure>\n<p>After running the code above, <code>ui.input, ui.prompt</code> and <code>ui.heading</code> refer to document elements. A script could use the global variables <code>input</code> and <code>heading</code> instead of <code>ui.input</code> and <code>ui.heading</code>. But the Window object has a method named <code>prompt()</code>, so a script cannot use the global variable <code>prompt</code> instead of <code>ui.prompt</code>. <br></p>\n<p>The implicit use of element IDs as global variables is a historical quirk of web browser evolution. It is required for backward compatibility with existing web pages, but its use is not recommended. <br><br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> $ = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">id</span>) </span>&#123; <span class=\"keyword\">return</span> <span class=\"built_in\">document</span>.getElementById(id); &#125;;</span><br><span class=\"line\">ui.prompt = $(<span class=\"string\">\"prompt\"</span>);</span><br></pre></td></tr></table></figure></p>\n<p>Any HTML element with an <code>id</code> attribute will become the value of a global variable, assuming the ID is not already used by Window object. The followoing HTML elements also behave this way when given a <code>name</code> attribute: <code>&lt;a&gt; &lt;applet&gt; &lt;area&gt; &lt;embed&gt; &lt;form&gt; &lt;frame&gt; &lt;frameset&gt; &lt;iframe&gt; &lt;img&gt; &lt;object&gt;</code>. <br></p>\n<p>The <code>id</code> element is required to be unique within a document: two elements cannot have the same <code>id</code>. This is not true for the <code>name</code> attribute, however. The implicit global variable with that name will refer to an array-like object that holds each of the named elements. <br></p>\n<p>There is a special case for <code>&lt;iframe&gt;</code> elements with a <code>name</code> or <code>id</code> attribute. The implicitly created variable for these elements refers not to the Element object that represents the element itself, but to the Window object that represents the nested browser frame created by the <code>&lt;iframe&gt; element</code>.</p>\n","next":{"title":"Javascript in Web Browsers","slug":"js-web-browser"},"link":"https://whitefusion.github.io/post/js-window-object"}