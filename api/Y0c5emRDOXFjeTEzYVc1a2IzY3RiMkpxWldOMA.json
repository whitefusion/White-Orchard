{"title":"The Window Object","date":"2018-09-15T08:14:52.000Z","excerpt":"","slug":"js-window-object","comments":true,"tags":["note","javascript"],"updated":"2018-09-22T09:42:26.794Z","content":"<blockquote>\n<p>This is the reading note for “Chapter 14: the Window Object, Javascript: The definitive guide 5th edition”. <br></p>\n</blockquote>\n<p>##Timers<br><code>setTimeout()</code> and <code>setInterval()</code> allow you to register a function to be invoked once or repeatedly after a specified amount of time has elapsed. <code>setTimeout()</code> returns a value that can be passed to <code>clearTimeout()</code> to cancel the execution of the scheduled function. Similary, <code>setInterval()</code> returns a value that can be passed to <code>clearInterval()</code> to cancel any future invocations of the scheduled function. </p>\n<p>##Browser Location and Navigation<br>The <code>location</code> property of the Window object refers to a Location object, which represents the current URL of the document displayed in the window, and which also defines methods for making the window a new document. <br></p>\n<p>The <code>location</code> property of the Document object also refers to be the Location object:<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">window</span>.location === <span class=\"built_in\">document</span>.location <span class=\"comment\">// always true</span></span><br></pre></td></tr></table></figure></p>\n<p>The Document object also has a <code>URL</code> property, which is a static string that holds the URL of the document when it was first loaded. If you navigate to fragment idetifiers within the document, the Location object is updated to reflect this, but the <code>document.URL</code> property remains unchanged. </p>\n<h3 id=\"Parsing-URLs\"><a href=\"#Parsing-URLs\" class=\"headerlink\" title=\"Parsing URLs\"></a>Parsing URLs</h3><p>The <code>href</code> property of the Location object is a string that contains the complete text of the URL. The <code>toString()</code> method of the Location object returns the value of the <code>href</code> property, so in contexts that will implicitly invoke <code>toString()</code>, you can just write <code>location</code> rather than <code>location.href</code>.<br></p>\n<p>Other properties of this object - <code>protocol</code>, <code>host</code>, <code>hostname</code>, <code>pathname</code>, <code>port</code>, <code>search</code>, and <code>hash</code> - specify the various individual parts of the URL. They are known as ‘URL decomposition’ properties. The <code>hash</code> property returns the ‘fragment identifier’ portion of the URL, if there is one: a hash mark followed by an element ID. The <code>search</code> property is similar. It returns the portion of the URL that starts with a question mark: often some sort of query string. </p>\n<h3 id=\"Loading-New-documents\"><a href=\"#Loading-New-documents\" class=\"headerlink\" title=\"Loading New documents\"></a>Loading New documents</h3><p>The <code>assign()</code> method of the Location object makes the window load and display the document at the URL you specify. The <code>replace()</code> method is similar, but it removes the current document from the browsing history before loading the new document. When a script unconditionally loads a new document, the <code>replace()</code> method is often a better choice than <code>assign()</code>. Otherwise, the Back button would take the browser back to the original document, adn the same script would again load the new document. <br></p>\n<p>Notice that the URL passed to <code>replace()</code> is a relative one. Relative URLs are interpreted relative to the page in which they appear, just as they would be if they were used in a hyperlink. <br></p>\n<p>In addition to the <code>assign()</code> and <code>replace()</code> methods, the Location object also defines <code>reload()</code>, which makes the browser reload the document. <br></p>\n<p>A more traditional way to make the browser navigate to a new page is to simply assign the new URL directly to the location property.<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// direct full </span></span><br><span class=\"line\">location = <span class=\"string\">'http://www.google.com'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// relative</span></span><br><span class=\"line\">location = <span class=\"string\">'page2.html'</span>;</span><br></pre></td></tr></table></figure></p>\n<p>A bare fragment identifier is a special kind of relative URL that does not cause the browser to load a new document but simply scroll to display a new section of the document. The identifier <code>#top</code> is a special case: if no document element has the ID “top”, it makes the browser jump to the start of the document. The URL decomposition properties of the Location object are writable, and setting them changes the location URL and also causes the browser to load a new document. </p>\n<h2 id=\"Browsing-History\"><a href=\"#Browsing-History\" class=\"headerlink\" title=\"Browsing History\"></a>Browsing History</h2><p>The <code>history</code> property of the Window object refers to the History object for the window. The History object models the browsing history of a window as a list of documents and document state.  The <code>length</code> property of the History object specifies the number of elements in the browsing history list, but for security reasons scripts are not allowed to access the stored URLs. (If they could, any scripts could snoop through your browsing history) <br></p>\n<p>The History object has <code>back()</code> and <code>forward()</code> methods that behave like the browser’s Back and Forward buttons do: they make the browser go backward or forward one step in tis browsing history. A thrid method, <code>go()</code>, takes an integer argument and can skip any number of pages forward (for positive arguments) or backward (for negative arguments) in history list <code>history.go(-2)</code>.<br><br></p>\n<p>If a window contains child windows, the browsing histories of the child windows are chronologically interleaved with the history of the main window. This means that calling <code>history.back()</code> on the main window may cause one of the child windows to navigate back to a previously displayed document but leave the main window in its current state. Modern web applications can dynamically alter their own content without loading a new document. <br></p>\n<h2 id=\"Browser-and-Screen-Information\"><a href=\"#Browser-and-Screen-Information\" class=\"headerlink\" title=\"Browser and Screen Information\"></a>Browser and Screen Information</h2><p>Scripts sometimes need to obtain information about the web browser in which they are running or the desktop on which the browser appears. The <code>navigator</code> and <code>screen</code> properties of the Window object contain these information. Those properties refer toe Navigator and Screen objects, respectively, and these objects provide information that allows a script to customize its behavior based on its environment. <br></p>\n<h3 id=\"The-Navigator-Object\"><a href=\"#The-Navigator-Object\" class=\"headerlink\" title=\"The Navigator Object\"></a>The Navigator Object</h3><p>The <code>navigator</code> property of a Window object refers to a Navigator object that contains browser vendor and version number information. <br></p>\n<p>In the past, the Navigator object was commonly used by scripts to determine if they were running in Internet Explorer or Netscape. This ‘browser-sniffing’ approach is problematic because it requires constant tweaking as new browsers and new versions of existing browsers are introduced. Today, feature testing is preferred: rather than making assumptions about particular browser versions and their features, you simply test for the feature you need. <br></p>\n<p>Browser sniffing is sometimes still valuable, however, such as when you need to work around a specific bug that exists in a specific version of a specific browser. The Navigator object has four properties that provide information about the browser that is running:</p>\n<ul>\n<li><code>appName</code>: The full name of the web browser. In IE, this is ‘Microsoft Internet Explorer’. In Firefox, this property is ‘Netscape’.</li>\n<li><code>appVersion</code>: This property typically begins with a number and follows that with a detailed string that contains browser vendor and version information. This number at the start of the string is often 4.0 or 5.0 to indicate generic compatibility with fourth- and fifth- generation browsers.</li>\n<li><code>userAgent</code>: The string that the browser sends in its <code>USER-AGENT</code> HTTP header. This property typically contains all the information in <code>appVersion</code> and may contain additional details as well. </li>\n<li><code>platform</code>: A string that identifies the operating system (and possibly the hardware) on which the browser is running. </li>\n</ul>\n<h3 id=\"The-Screen-Object\"><a href=\"#The-Screen-Object\" class=\"headerlink\" title=\"The Screen Object\"></a>The Screen Object</h3><p>The <code>screen</code> object property of a Window object refers to a Screen object that provides information about the size of the user’s display and the number of colors available on it. The <code>width</code> and <code>height</code> properties specify the size of the display in pixels. The <code>availWidth</code> and <code>availHeight</code> properties specify the displaysize that is actually available.<br></p>\n<p>The <code>window.screen</code> property and the Screen object to which it refers are both nonstandard but widely implemented. You might use Screen object to determine whether your web app is running in a small form factor device such as a notebook computer. </p>\n<h2 id=\"Dialog-Boxes\"><a href=\"#Dialog-Boxes\" class=\"headerlink\" title=\"Dialog Boxes\"></a>Dialog Boxes</h2><p><code>alert()</code> displays a message to the user and waits for the user to dismiss the dialog. <code>confirm()</code> displays a message, waits for the user to click an OK or Cancel button and returns a boolean value. And <code>prompt()</code> displays a message, waits for the user to enter a string, and returns that string.<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">do</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> name = prompt(<span class=\"string\">\"waht is your name?\"</span>); <span class=\"comment\">// get a string</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> correct = confirm(<span class=\"string\">\"You entered '\"</span> + name + <span class=\"string\">\"'.\\n\"</span> + <span class=\"string\">\"Click Okay to proceed or Cancel to re-enter\"</span> ); <span class=\"comment\">// get boolean</span></span><br><span class=\"line\">&#125; <span class=\"keyword\">while</span>(!correct)</span><br><span class=\"line\">alert(<span class=\"string\">\"Hello, \"</span> + name); <span class=\"comment\">// Display a plain message</span></span><br></pre></td></tr></table></figure></p>\n<p>Although they are easy to use, good design dictates that you use them sparingly. The only common use for these methods today is debugging. <br></p>\n<p>The <code>confirm()</code> and <code>prompt()</code> methods <em>block</em> - that is, these methods do not return until the user dismisses the dialog boxes they display. This means that when you pop up one of these boxes, your code stop running, and the currently loading document, if any, stops loading until the user responds with the requested input. <br></p>\n<p>A more complicated method, <code>showModalDialog()</code>, displays a modal dialog box containing HTML formatted content and allows arguments to be passed to, and a value returned from, the dialog. <code>showModalDialog()</code> displays a modal dialog in a browser window of its own. The first argument is the URL that specifies the HTML content of the dialog box. The second argument is an arbitrary value that will be made available to scripts in the dialog as the value of the <code>window.dialogArguments</code> property. The third arugment is a nonstandard list of semicolon-separated name=value pairs that, if supported, may configure the size or other attributes of the dialog. <br></p>\n<p>The window displayed by this method is modal, and the call to <code>showModalDialog()</code> does not return until the window is closed. When the window closes, the value of the <code>window.returnValue</code> property becomes the return value of the method call. The HTML content of the dialog must typically include an OK button that sets <code>returnValue</code>, if desired, and calls <code>window.close()</code>.</p>\n<h2 id=\"Error-Handling\"><a href=\"#Error-Handling\" class=\"headerlink\" title=\"Error Handling\"></a>Error Handling</h2><p>The <code>onerror</code> property of a Window object is an event handler that is invoked when an uncaught exception propagates all the way up the call stack and an error message is about to be displayed in the browser’s JS console. If you assign a function to this property, the function is invoked whenever a JS error occurs in that widnow: the function you assign becomes an error handler for the window. <br></p>\n<p>The first argument to <code>window.onerror</code> is a message describing the error. The second argument is a string that contains the URL of the JS code that caused the error. The third argument is the line number within the document where the error occurred. <br></p>\n<p>If the <code>onerror</code> handler returns <code>false</code>,  it tells the browser that the handler has handled the error and that no further action is necessary - in other words, the browser should not display its own error message. Unfortunately, for historical reasons, an error handler in Firefox must return <code>true</code> to indicate that it has handled the error. <br><br>This property is rarely used in modern code, use <code>try/catch</code> instead.</p>\n<h2 id=\"Document-Elements-As-Window-Properties\"><a href=\"#Document-Elements-As-Window-Properties\" class=\"headerlink\" title=\"Document Elements As Window Properties\"></a>Document Elements As Window Properties</h2><p>If you name an element in your HTML document using the <code>id</code> attribute, and if the Window object does not already have a property by that name, the Window object is given a nonenumerable property whose name is the value of the <code>id</code> attribute and whose value is the HTMLElement object that represents that document element. This means that the <code>id</code> attributes you use in your HTML documents become global variables accessible to your scripts. If your document includes the element <code>&lt;button id ==&quot;okay&quot;&gt;</code>, you can refer to that element using the global variable <code>okay</code>. <br></p>\n<p>Similarly, if your HTML document includes an element whose <code>id</code> is “x” and you also declare and assign a value to the global variable <code>x</code> in your code, the explicitly declared variable will hide the implicit element variable. If the variable is declared in a script that appears before the named element, its existence will prevent the element from getting a window property of its own. And if the variable is declared in a script that appears after the named element, you explicit assignment to the variable overwrites the implicit value of the property. <br></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> ui = [<span class=\"string\">'input'</span>, <span class=\"string\">'prompt'</span>, <span class=\"string\">'heading'</span>];</span><br><span class=\"line\">ui.forEach( <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">id</span>) </span>&#123;</span><br><span class=\"line\">    ui[id] = <span class=\"built_in\">document</span>.getElementById(id);</span><br><span class=\"line\">&#125; )</span><br></pre></td></tr></table></figure>\n<p>After running the code above, <code>ui.input, ui.prompt</code> and <code>ui.heading</code> refer to document elements. A script could use the global variables <code>input</code> and <code>heading</code> instead of <code>ui.input</code> and <code>ui.heading</code>. But the Window object has a method named <code>prompt()</code>, so a script cannot use the global variable <code>prompt</code> instead of <code>ui.prompt</code>. <br></p>\n<p>The implicit use of element IDs as global variables is a historical quirk of web browser evolution. It is required for backward compatibility with existing web pages, but its use is not recommended. <br><br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> $ = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">id</span>) </span>&#123; <span class=\"keyword\">return</span> <span class=\"built_in\">document</span>.getElementById(id); &#125;;</span><br><span class=\"line\">ui.prompt = $(<span class=\"string\">\"prompt\"</span>);</span><br></pre></td></tr></table></figure></p>\n<p>Any HTML element with an <code>id</code> attribute will become the value of a global variable, assuming the ID is not already used by Window object. The followoing HTML elements also behave this way when given a <code>name</code> attribute: <code>&lt;a&gt; &lt;applet&gt; &lt;area&gt; &lt;embed&gt; &lt;form&gt; &lt;frame&gt; &lt;frameset&gt; &lt;iframe&gt; &lt;img&gt; &lt;object&gt;</code>. <br></p>\n<p>The <code>id</code> element is required to be unique within a document: two elements cannot have the same <code>id</code>. This is not true for the <code>name</code> attribute, however. The implicit global variable with that name will refer to an array-like object that holds each of the named elements. <br></p>\n<p>There is a special case for <code>&lt;iframe&gt;</code> elements with a <code>name</code> or <code>id</code> attribute. The implicitly created variable for these elements refers not to the Element object that represents the element itself, but to the Window object that represents the nested browser frame created by the <code>&lt;iframe&gt; element</code>.</p>\n<h2 id=\"Multiple-Windows-and-Frames\"><a href=\"#Multiple-Windows-and-Frames\" class=\"headerlink\" title=\"Multiple Windows and Frames\"></a>Multiple Windows and Frames</h2><p>A single web browser window on your desktop may contain several tabs. Each tab is an independent <em>browsing context</em>. Each has its own Window object, and each is isolated from all the others. <br><br>But windows are not always isoslated from one another. A script in one window or tab can open new windows or tabs, and when a script does this, the windows can interact with one another and with one another’s documents.(subject to the constraints of the same-origin policy) <br></p>\n<p>HTML documents may contain nested documents using an <code>&lt;iframe&gt;</code> element. An <code>&lt;iframe&gt;</code> creates a nested browsing context represented by a Window object of its own. Client-side JS makes very little distinction between window, tabs, iframes and frames: they are all browsing contexts, and to JS, they are all Window objects. Nested browsing contexts are not isolated from one another the way independent tabs usually are. A script running in one frame can always see its ancestor and descent frames, though the same-origin policy may prevent the script from inspecting the documents in those frames. <br><br>Nevertheless, JS code in one window can, subject to same-origin constraints, use the objects, properties, and methods defined in other windows. </p>\n<h3 id=\"Opening-and-Closing-Windows\"><a href=\"#Opening-and-Closing-Windows\" class=\"headerlink\" title=\"Opening and Closing Windows\"></a>Opening and Closing Windows</h3><p>You can open a new web browser window ( or tab; this is usually a browser configuration option) with the <code>open()</code> method of the Window object. <code>Window.open()</code> loads a specified URL into a new or existing window and returns the Window object that represetns that window. <br></p>\n<p>The first argument to <code>open()</code> is the URL of the document to display in the new window. If this argument is omitted (or is the empty string), the special blank-page URL <code>about:blank</code> is used. <br></p>\n<p>The second argument to <code>open()</code> is a string that specifies a window name. If a window by that name already exists (and if the script is allowed to navigate that window), that existing window is used. Otherwise a new window is created and is assigned the specified file name. If this argument is omitted, the special name “_blank” is used: it opens a new, unnamed window. <br></p>\n<p>Loosely, a script can specify an existing window by name only if that window contains a document from the same origin or if the script opened that window. Also, if one window is a frame nested within the other, a script in either one can navigate the other. In this case, the reserved names “_top” ( the top-level ancestor window ) and “_parent” (the immediate parent window) can be useful. <br>.</p>\n<p>The name of a window is important because it allows the <code>open()</code> method to refer to existing windows, and also because it can be used as the value of the HTML <code>target</code> attribute on <code>&lt;a&gt;</code> and <code>&lt;form&gt;</code> element to indicate that the linked document ( or the result of submitting the form ) should be displayed in the named window. The <code>target</code> attribute on these elements can also be set to “_blank” , “_parent”, “_top” to direct the linked document into a new blank window, the parent window or frame, or the top-level window. <br></p>\n<p>The third optional argument to <code>open()</code> is a comma-separated list of size and features attributes for the new window to be opend. </p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> w = <span class=\"built_in\">window</span>.open(<span class=\"string\">\"smallwin.html\"</span>, <span class=\"string\">\"smallwin\"</span>, </span><br><span class=\"line\">                    <span class=\"string\">\"width=400, height=350, status=yes, resizable=yes\"</span>);</span><br></pre></td></tr></table></figure>\n<p>For various security reasons, browsers include restrictions on the features you can specify. You are typically not allowed to specify a window that is too small or is positioned offscreen. <br></p>\n<p>The fourth argument to <code>open()</code> is useful only when the second argument names an existing window. This fourth argument is a boolean value that indicates whether the URL specified as the first argument should replace the current entry in the window’s history(<code>true</code>) or create a new entry in the window’s browsing history (<code>false</code>). The default is <code>false</code>.</p>\n<p>The <code>name</code> property of a Window object holds its name, if it has one. This property is writable, and scripts can set it as desired. If a name (other than “_blank”) is passed to <code>Window.open()</code>, the window created by that call will have the specified name as the initial value of its <code>name</code> property. If an <code>&lt;iframe&gt;</code> element has a <code>name</code> attribute, the Window object that represents that frame will use that <code>name</code> attribute as the initial value of the <code>name</code> property. <br></p>\n<p>In window created with the <code>window.open()</code> method, the <code>opener</code> property refers back to the Window object of the script that opend it.<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">w.opener !== <span class=\"literal\">null</span>; <span class=\"comment\">// true for any window w created by open()</span></span><br><span class=\"line\">w.open().opener === w; <span class=\"comment\">// true for any window w</span></span><br></pre></td></tr></table></figure></p>\n<p><code>Window.open()</code> is the method by which advertisements are made to “pop up” or “pop under” while you browser the Web. Because of this flood of annoying pop ups, most web browsers have noe instituted some kind of pop up-blocking system. Typically, calls to the <code>open()</code> method are successful only if they occur in response to a user action suc as clicking on a button or a link. JS code that tries to open a pop-up window when the browser first loads a page will usually fail. Testing the lines of code shown above by pasting them into the JS console of your browser may also fail for the same reason.  <br></p>\n<p>The <code>close()</code> method closes one. If you create a Window object <code>w</code>, you can close it with: <code>w.close()</code>. JS code running within that window itself can close it with: <code>window.close()</code>.<br>Note the explicit use of the <code>window</code> identifier to distinguish the <code>close()</code> method of the Window object from the <code>close()</code> method of the Document object.  Most browsers allow you to automatically close only those windows that your own JS code has created. A Window object continues to exist after the Window it represents has been closed. A window that has been closed will have a <code>closed</code> property of <code>true</code>, its <code>document</code> will be null, and its methods will typically no longer work. </p>\n<h3 id=\"Relationships-Between-Frames\"><a href=\"#Relationships-Between-Frames\" class=\"headerlink\" title=\"Relationships Between Frames\"></a>Relationships Between Frames</h3><p>As we saw above, the <code>open()</code> method of a Window object returns a new Window object that has an <code>opener</code> property that refers back to the original window. In this way, the two windows can refer to each other, and each can read properties and invoke methods of the other. Code running in a window or frame can refer to the contianing window or frame and to nested child frames using the properties described below. <br></p>\n<p>You already know that the JS code in any window or frame can refer to its own Window object as <code>window</code> or as <code>self</code>. A frame can refer to the Window object of the window or frame that contains it using the <code>parent</code> property: <code>parent.history.back()</code>.  A Window object that represents a top-level window or tab has no container, and its <code>parent</code> property simply refers to the window itself: <code>parent == self;</code> If a frame is contained within another frame that is contained within a top-level window, that fram can be referred with <code>top</code> property. <br><br>The <code>parent</code> and <code>top</code> properties allow a script to refer to its frame’s ancestors. There is more than one way to refer to the descendant frames of a window or frame. Suppose your document contains <code>&lt;iframe id=&#39;f1&#39;&gt;</code>. Then the Element object that represents this iframe is: <code>var  iframeElement = document.getElementById(&#39;f1&#39;)</code>. <code>&lt;iframe&gt;</code> elements have a <code>contentWindow</code> property that refers to the Window object of the frame, so the Window object for this frame is <code>var childFrame = document.getElementById(&#39;f1&#39;).contentWindow;</code> You can go in reverse direction - from the window that represents a frame to the <code>&lt;iframe&gt;</code> Element that contains the frame - with the <code>frameElement</code> property of the Window.<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> elt = <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">'f1'</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> win = elt.contentWindow;</span><br><span class=\"line\">win.frameElement === elt; <span class=\"comment\">// always true for frames</span></span><br><span class=\"line\"><span class=\"built_in\">window</span>.frameElement === <span class=\"literal\">null</span>;  <span class=\"comment\">// for toplevel windows</span></span><br></pre></td></tr></table></figure></p>\n<p>It is not usually necessary to use the <code>getElementById()</code> method and the <code>contentWindow</code> property to obtain references to the child frames of a window, however. Every Window object has a <code>frames</code> object that refers to the child frames contained within the window or frame.<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">frames[<span class=\"number\">0</span>]</span><br><span class=\"line\">frames[<span class=\"number\">1</span>].frames[<span class=\"number\">2</span>]</span><br><span class=\"line\">parent.frames[<span class=\"number\">1</span>]</span><br></pre></td></tr></table></figure></p>\n<p>Note that the elements of the <code>frames</code> are Window objects, not <code>&lt;iframe&gt;</code>  elements. <br><br>the names or IDs of <iframe> and other elements are automat-<br>ically used as properties of the Window object, and that <iframe> elements are treated<br>differently than other elements: for frames, the value of these automatically created<br>properties refer to a Window object rather than an Element object.<br>HTML5 specifies that the <code>frames</code> property is a self-referential property, just like <code>window</code> and <code>self</code>, and that it is the Window object itself that acts like an array of frames. This means that we can refer to the first child frame as <code>window[0]</code> and we can query the number of frames with <code>window.length</code> or just <code>length</code>.<br><br>If you use the <code>name</code> attribute, however, the name you specify also becomes the value of the <code>name</code> property of the Window that represents the frame. A name specified in this way can be used as the <code>target</code> attribute of a link, and it can be used as the second argument to <code>window.open()</code>.</iframe></iframe></p>\n<h3 id=\"JS-in-Interacting-Windows\"><a href=\"#JS-in-Interacting-Windows\" class=\"headerlink\" title=\"JS in Interacting Windows\"></a>JS in Interacting Windows</h3><p>Each window or frame is its own JS execution context with a Window as its global object. But if code in one window or frame can refer to another window or frame, the scripts in one or frame can interact with the scripts in the other. <br><br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> i = <span class=\"number\">3</span>;</span><br><span class=\"line\"><span class=\"built_in\">window</span>.i;</span><br><span class=\"line\">parent.A.i = <span class=\"number\">4</span>;<span class=\"comment\">// change the value of a variable in frame A</span></span><br><span class=\"line\">parent.B.f(); <span class=\"comment\">// invoke a function defined in frame B</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> f = parent.B.f;</span><br></pre></td></tr></table></figure></p>\n<p>If the function <code>f</code> above refers to global variables, these variables are looked up as properties of frame B, even when the function is invoked from frame A. <br><br>Remember that constructors are also functions, so when you define a class with a constructor function and an associated prototype object, that class is defined only within a single window. Scripts in either of the child frames must explicitly refer to the <code>Set()</code> constructor as a property of the parent window:<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> s = <span class=\"keyword\">new</span> parent.Set();</span><br><span class=\"line\"><span class=\"keyword\">var</span> <span class=\"built_in\">Set</span> = top.Set();</span><br><span class=\"line\"><span class=\"keyword\">var</span> s = <span class=\"keyword\">new</span> <span class=\"built_in\">Set</span>();</span><br></pre></td></tr></table></figure></p>\n<p>This means, however, that each window has an independent copy of the constructor and an independent copy of the prototype object. Each window has its own copy of the <code>String()</code> constructor  and the <code>String.prototype</code> object. So if you write a new method for manipulating JS strings and then make it a method of the String class by assigning it to the <code>String.prototype</code> object in the current window, all strings created by code in that window can use the new method. however, the new method is not accessible to strings created in other windows. <br></p>\n<p>The fact that each Window has its own prototype objects means that the <code>instanceof</code> operator does not work across windows. <code>instanceof</code> will evaluate to <code>false</code>, for example, when used to compare a string from frame B to the <code>String()</code> constructor from frame A. </p>\n","next":{"title":"Javascript in Web Browsers","slug":"js-web-browser"},"link":"https://whitefusion.github.io/post/js-window-object"}