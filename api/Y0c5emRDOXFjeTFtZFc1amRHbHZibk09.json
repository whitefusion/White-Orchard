{"title":"Javascript: Functions","date":"2018-08-10T13:17:23.000Z","excerpt":"","slug":"js-functions","comments":true,"tags":["javascript","note"],"categories":["language core"],"updated":"2018-08-11T15:43:31.325Z","content":"<blockquote>\n<p>This is the reading note for “Chapter 8: Funtions, Javascript: The definitive guide 5th edition”. <br></p>\n</blockquote>\n<p>A function is a block of JS code that is defined once but may be executed, or invoked, any number of times. JS are <em>parameterized</em>: a function definition may include a list of identifiers, known as <em>parameters</em>, that work as local variables for the body of the function. In addition to the arguments, each invocation has another value – the <em>invocation context</em> – that is the value of the <code>this</code> keyword. <br></p>\n<p>If a function is assigned to the property of an object, it is known as a <em>method</em> of that object. When a function is invoked on or through an object, that object is the invocation context or <code>this</code> value for the function.Functions designed to initialize a newly created object are called <em>constructors</em>. <br></p>\n<p>JS can assign functions to variables and pass them to other functions, for example, Since functions are objects, you can set properties on them, and even invoke methods on them. <br></p>\n<p>JS function definitions can be nested within other functions, and they have access to any variables that are in scope where they are defined. This means that JS functions are <em>closures</em>. </p>\n<h4 id=\"Defining-Functions\"><a href=\"#Defining-Functions\" class=\"headerlink\" title=\"Defining Functions\"></a>Defining Functions</h4><p>Function definitions begin with the keyword <code>function</code> followed by these components: </p>\n<ul>\n<li>An identifier that names the function. The name is a required part of function declaration statements, for function definition expressions, the name is optional.</li>\n<li>A pair of parenthese around a comma-separated list of zero or more identifiers. </li>\n<li>A pair of curly braces with zero or more JS statements inside.</li>\n</ul>\n<p>Notice that a function defined as expression is only useful if it is part of a larger expression. <br><br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Function expressions are sometimes defined and immediately invoked.</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> tensquared = (<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">x</span>)</span>&#123;<span class=\"keyword\">return</span> x*x;&#125;(<span class=\"number\">10</span>));</span><br></pre></td></tr></table></figure></p>\n<p>Note that the function name is optional for functions defined as expressions. A function declaration statement actually declares a variable and assigns a function object to it. A function definition expression, on the other hand, does not declare a variable. <br><br>Function declaration statements are hoisted to the top of the enclosing script or the enclosing function, so that functions declared in this way may be invoked from code that appears before they are defined. But this is not true for functions defined as expressions. <br></p>\n<h3 id=\"Invoking-Functions\"><a href=\"#Invoking-Functions\" class=\"headerlink\" title=\"Invoking Functions\"></a>Invoking Functions</h3><p>The JS code that makes up the body of a function is not executed when the function is defined byt when it is invoked. There are four ways to invoke: </p>\n<ul>\n<li>as functions</li>\n<li>as methods</li>\n<li>as constructors</li>\n<li>indirectly throught their <code>call()</code> and <code>apply()</code> methods.</li>\n</ul>\n<p>An invocation expression consists of a function expression that evaluates to a function object followed by an open parenthesis, a comma-separated list of zero or more argument expression, and a close parenthesis. <br><br>A <em>method</em> is nothing more than a JS function that is stored in a property of an object. Method invocations differ from function invocations in one important way, however: the invocation context. <br><br>When method return objects, you can use the return value of one method invocation as part of a subsequence invocation. This results in a series (or ‘chain’ or ‘cascade’) of method invocations as a single expression. When you write a method that does not have a return value of its own, consider having the method return <code>this</code>.<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">shape.setX(<span class=\"number\">100</span>).setY(<span class=\"number\">100</span>).setSize(<span class=\"number\">50</span>).setOutline(<span class=\"string\">'red'</span>).draw();</span><br></pre></td></tr></table></figure></p>\n<p>Note that <code>this</code> is a keyword, not a variable or property name. JS syntax does not allow you to assign a value to <code>this</code>. <br><br>Unlike variables, the <code>this</code> keyword does not have a scope, and nested functions do not inherit the <code>this</code> value of their caller.<br>If a nested function is invoked as a function then its <code>this</code> value will be either the global object or <code>undefined</code>. It is a common mistake to assume that a nest function invoked as a function can <code>this</code> to obtain the invocation context of the outer function. If you want to access the <code>this</code> value of the outer function, you need to store that value into a variable that is in scope for the inner function. It is common to use <code>self</code> for this purpose.  <br><br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> o = &#123;</span><br><span class=\"line\">    m: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> self = <span class=\"keyword\">this</span>;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span> === o); <span class=\"comment\">// true</span></span><br><span class=\"line\">        f();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">            <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span> === o); <span class=\"comment\">// false </span></span><br><span class=\"line\">            <span class=\"built_in\">console</span>.log(self === o); <span class=\"comment\">// true </span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">o.m();</span><br></pre></td></tr></table></figure></p>\n<p>If a function or method invocation is prceded by the keyword <code>new</code>, then it is a constructor invocation. Constructor invocations differ from regular function and method invocations in their handling of arguments, invocation context and return value. <br><br>A constructor invocation creates a new, empty object that inherits from the <code>prototype</code> property of the constructor. Constructor functions are intended to initialize objects and this newly created object is used as the invocation context, so the constructor function can refer to it with the <code>this</code> keyword. Note that the new object is used as the invocation context even if the constructor invocation looks like a method invocation. That is, in the expression <code>new o.m()</code>, <code>o</code> is not used as the invocation context. <br><br>If, however, a constructor explicitly used the <code>return</code> statement to return an object, then that object becomes the value of the invocation expression. If the constructor uses <code>return</code> with no value, or if it is returns a primitive value, that return value is ignored and the new object is used as the value of the invocation. <br><br>Both <code>call()</code> and <code>apply()</code> allow you to explicitly specify the <code>this</code> value for the invocation,  which means you can invoke any function as a method of any object, even if it is not actually a method of that object. The <code>call()</code> method uses its own arguement list as arguments. The <code>apply()</code> method expects an array of values to be used as arguments. </p>\n<h3 id=\"Function-Arguments-and-Parameters\"><a href=\"#Function-Arguments-and-Parameters\" class=\"headerlink\" title=\"Function Arguments and Parameters\"></a>Function Arguments and Parameters</h3><p>When a function is invoked with fewer arguments than declared parameters, the additional parameters are set to the <code>undefined</code> value. The programmer who calls your function cannot omit the first argument and pass the second: he would have to explicitly pass the <code>undefined</code> to the first argument. <br><br>When a function is invoked with more argument values than there are parameter names, there is no way to directly refer to the unnamed values. Within the body of a function, the identifier <code>arguments</code> refers to the Arguments object for that invocation. The Arguments object is an array-like object that allows the argument values passed to the function to be retrieved by number, rather than by name. <br><br>Suppose you define a function <code>f</code> that expects to be passed one argument, <code>x</code>. If you invoke this function with two arguments, the first argument is accessible within the function by the parameter name <code>x</code> or as <code>arguments[0]</code>. The second argument is accessible only as <code>arguments[1]</code>. <br><br>The missing arguments are <code>undefined</code> and extra arguemnt simply ingnored. This is default behavior in JS. One important use of the Arguements object is to write functions that operate on any number of arguments. <br><br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">max</span>(<span class=\"params\"><span class=\"regexp\">/*...*/</span></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> max = <span class=\"built_in\">Number</span>.NEGATIVE_INFINITY;</span><br><span class=\"line\">    <span class=\"comment\">// Loop through the arguments</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"built_in\">arguments</span>.length; i++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"built_in\">arguments</span>[i] &gt; max) max = <span class=\"built_in\">arguments</span>[i];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> max;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> largest = max(<span class=\"number\">1</span>,<span class=\"number\">10</span>,<span class=\"number\">2</span>,<span class=\"number\">5</span>,<span class=\"number\">76</span>);</span><br></pre></td></tr></table></figure></p>\n<p>Functions like this one that can accept any number of arguments are called <code>varargs functions</code>.  Note that varargs functions need not allow invocations with zero arguments. Note that changing the variable in <code>arguments</code> also changes the value referred by the identifier.<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f</span>(<span class=\"params\">x</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(x);</span><br><span class=\"line\">    <span class=\"built_in\">arguments</span>[<span class=\"number\">0</span>] = <span class=\"literal\">null</span>;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(x);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>The Arguments object defines <code>callee</code> and <code>caller</code> property.<br>Outside of strict mode, the ECMAScript standard says that the <code>callee</code> property refers to the currently running function. <code>caller</code> is a nonstandard but commonly implemented property that refers to the function that called this one. The <code>caller</code> property gives access to the call stack, and the <code>callee</code> property is occasionally useful to allow unamed functions to call themselves recursively:<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> factorial = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">x</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (x &lt; =<span class=\"number\">1</span> ) <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> x * <span class=\"built_in\">arguments</span>.callee(x<span class=\"number\">-1</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>When a function has more than three parameters, it becomes difficult for the programmer who invokes the function to remember the correct order in which to pass arguments. You can define your function to expect a single object as its argument and then have users of the function pass an object that defines the required name/value pairs.<br><br>It is better for a function to fail immediately and predictably when passed bad values than to begin executing and fail later with an error message that is likely to be unclear. </p>\n<h3 id=\"Functions-As-Values\"><a href=\"#Functions-As-Values\" class=\"headerlink\" title=\"Functions As Values\"></a>Functions As Values</h3><p>Function are not only syntax but also values, which means they can be assigned to variables, stored in the properties of objects or the elements of arrays, passed as arguments to functions and so on. The name of a function is really immaterial.<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> s = square;</span><br><span class=\"line\">square(<span class=\"number\">4</span>);</span><br><span class=\"line\">s(<span class=\"number\">4</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> o = &#123; <span class=\"attr\">square</span>: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">x</span>) </span>&#123;<span class=\"keyword\">return</span> x*x;&#125; &#125;;</span><br><span class=\"line\"><span class=\"keyword\">var</span> y = o.square(<span class=\"number\">16</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> a = [<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">x</span>) </span>&#123;<span class=\"keyword\">return</span> x*x;&#125;, <span class=\"number\">20</span>];</span><br><span class=\"line\">a[<span class=\"number\">0</span>](a[<span class=\"number\">1</span>]);</span><br></pre></td></tr></table></figure></p>\n<p>Functions are not primitive values in JS, but a specialized kind of object, which means that functions can have properties. When a function needs a <code>static</code>  variable whose value persists across invocations, it is often convenient to use a property of the function, instead of cluttering up the namespace by defining a global variable. Suppose you want to write a function that returns a unique integer whenever it is invoked. The function must never return the same value twice. You could store this information in a global variable, but that is unnecessary, because the information is used only by the function itself. It is better to store the information in a property of the Function object.<br><br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Do this assignment before the function declaration</span></span><br><span class=\"line\">uniqueInteger.counter = <span class=\"number\">0</span>;</span><br><span class=\"line\"><span class=\"comment\">// This function returns a different integer each time it is called.</span></span><br><span class=\"line\"><span class=\"comment\">// It uses a property of itself to remember the next value to be returned.</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">uniqueInteger</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> uniqueInteger.counter++;  <span class=\"comment\">// Increment and return counter property</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// compute the factorials and cache results as properties of the function itself</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">factorial</span>(<span class=\"params\">n</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"built_in\">isFinite</span>(n) &amp;&amp; n &gt; <span class=\"number\">0</span> &amp;&amp; n == <span class=\"built_in\">Math</span>.round(n)) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!(n <span class=\"keyword\">in</span> factorial))</span><br><span class=\"line\">            factorial[n] = n * factorial(n<span class=\"number\">-1</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> factorial[n];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">return</span> <span class=\"literal\">NaN</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">factorial[<span class=\"number\">1</span>] = <span class=\"number\">1</span>;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"Functions-As-Namespaces\"><a href=\"#Functions-As-Namespaces\" class=\"headerlink\" title=\"Functions As Namespaces\"></a>Functions As Namespaces</h3><p>JS has function scope: variables declared within a function are visible throughout the function but do not exist outside the function. It is sometimes useful to define a function simply to act as a temporary namespace in which you can define variables without polluting the global namespace.  <br><br>If defining even a single property is too much, you can define and invoke an anonymous function in a single expression.<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//module code goes here</span></span><br><span class=\"line\">&#125;())</span><br></pre></td></tr></table></figure></p>\n<p>The open parenthesis before <code>function</code> is required because without it, the JS interpreter tries to parse the <code>function</code> keyword as a function declaration statement. With the parenthesis, the interpreter correctly recognizes this as a function definition expression. </p>\n<h3 id=\"Closures\"><a href=\"#Closures\" class=\"headerlink\" title=\"Closures\"></a>Closures</h3><p>JS uses lexical scoping. This means that functions are executed using the variable scope that was in effect when they were defined, not the variable scope that is in effect when they are invoked.<br>In order to implement lexical scoping, the internal state of a JS function object must include not only the code of the function but also a reference to the current scope chain. The combination of a function object and a scope ( a set of variable bindings ) in which the function’s variables are resolved is called a <em>closure</em> in the computer science literature. <br><br>Closures become interesting when they are invoked under a different scope chain than the one that was in effect when they were defined. This happens most commonly when a nested function object is returned from the function within which it was defined.<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> scope = <span class=\"string\">'global scope'</span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">checkscope</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> scope = <span class=\"string\">'local scope'</span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f</span>(<span class=\"params\"></span>) </span>&#123; <span class=\"keyword\">return</span> scope; &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> f();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">checkscope();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/* dash line */</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> scope = <span class=\"string\">'global scope'</span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">checkscope</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> scope = <span class=\"string\">'local scope'</span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f</span>(<span class=\"params\"></span>) </span>&#123; <span class=\"keyword\">return</span> scope; &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> f;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">checkscope()();</span><br></pre></td></tr></table></figure></p>\n<p>In this code, a pair of parentheses has moved from inside <code>checkscope()</code> to outside of it. Remember the fundamental rule of lexical scoping: JS functions are executed using the scope chain that was in effect when they were defined.  That binding is still in effect when <code>f</code> is executed, wherever it is executed from. So the last line returns ‘local scope’. The nature of closures is that they capture the local variable (and parameter) bindings of the outer function within which they are defined. <br><br>A shortcoming of using a property of function itself is that buggy or malicious code could reset the counter or set it to a noninteger, causing the <code>uniqueInteger()</code> function to violate the ‘unique’ or the ‘integer’ part of its contract. Closures capture the local variables of a single function invocation and can use those variables as private state.<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> uniqueInteger = (<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123; <span class=\"comment\">// Define and invoke</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> counter = <span class=\"number\">0</span>; <span class=\"comment\">// private state of function below</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;<span class=\"keyword\">return</span> counter++;&#125; </span><br><span class=\"line\">&#125;());</span><br></pre></td></tr></table></figure></p>\n<p>In fact, the code is defining and invoking a function, so it is the return value of the function that is being assigned to <code>uniqueInteger</code>. The nested function has access to the variables in scope, and can use the <code>counter</code> variable defined in the outer function. Once that outer function returns, no other code can see the <code>counter</code> variable: the inner function has exclusive access to it. Private variables like <code>counter</code> need not be exclusive: it is perfectly possible for two or more nested functions to be defined within the same outer function and share the same scope chain.<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">counter</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> n = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">        count: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;<span class=\"keyword\">return</span> n++&#125;;</span><br><span class=\"line\">        reset: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;n=<span class=\"number\">0</span>;&#125;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> c = counter(), d= counter();</span><br><span class=\"line\">c.count() <span class=\"comment\">// 0</span></span><br><span class=\"line\">d.count() <span class=\"comment\">// 1</span></span><br><span class=\"line\">c.reset() <span class=\"comment\">// 0</span></span><br><span class=\"line\">c.count() <span class=\"comment\">// 0</span></span><br><span class=\"line\">d.count() <span class=\"comment\">// 1</span></span><br></pre></td></tr></table></figure></p>\n<p>The first thing to understand is that the two methods share access to the private variable <code>n</code>. The second thing to understand is that each invocation of <code>counter()</code> creates a new scope chain and a new private variable. <br><br>You can also combine the closure technique with property getters and setters. It uses closures for private state rather than relying on a regular object property:<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">counter</span>(<span class=\"params\">n</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">        get count() &#123;<span class=\"keyword\">return</span> n++;&#125;,</span><br><span class=\"line\">        set count(m) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (m &gt;= n) n = m;</span><br><span class=\"line\">            <span class=\"keyword\">else</span> <span class=\"keyword\">throw</span> <span class=\"built_in\">Error</span>(<span class=\"string\">'count can only be  set to a larger value'</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> c = counter(<span class=\"number\">1000</span>);</span><br><span class=\"line\">c.count <span class=\"comment\">// 1000</span></span><br><span class=\"line\">c.count <span class=\"comment\">// 1001</span></span><br><span class=\"line\">c.count = <span class=\"number\">2000</span></span><br><span class=\"line\">c.count <span class=\"comment\">// 2000</span></span><br></pre></td></tr></table></figure></p>\n<p>Note that this version of the <code>counter()</code> function does not declare a local variable, but just uses its parameter <code>n</code> to hold the private state shared by the property accessor methods. <br><br>It is just as important to recognize when closures inadvertentlyu share access to a variable that they should not share.<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">constfuncs</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> funcs = [];</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">10</span>; i++)</span><br><span class=\"line\">        funcs[i] = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123; <span class=\"keyword\">return</span> i&#125;;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> funcs</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> funcs = constfuncs();</span><br><span class=\"line\">funcs[<span class=\"number\">5</span>]() <span class=\"comment\">// return 10</span></span><br></pre></td></tr></table></figure></p>\n<p>Another thing to remember when writing closures is that <code>this</code> is a JS keyword, not a variable. Every function invocation has a <code>this</code> value, and a closure cannot access the <code>this</code> value of its outer function unless the outer function has saved that value into a variable. Since a closure has its own binding for <code>arguments</code>, it cannot access the outer function’s arguments array unless the outer fucntion has saved it into a variable by a different name. </p>\n<h3 id=\"Function-Properties-Methods-and-Constructor\"><a href=\"#Function-Properties-Methods-and-Constructor\" class=\"headerlink\" title=\"Function Properties, Methods and Constructor\"></a>Function Properties, Methods and Constructor</h3><p>We’ve seen that functions are values in JS programs. The <code>typeof</code> operator returns the string ‘function’ when applied to a function, but functions are really a specialized kind of JS object. There is even a <code>Function()</code> constructor to create new function objects.  <br><br>Within the body of a function, <code>arguments.length</code> specifies the number of arguments that were passed to the function. The <code>length</code> property of a function itself is read-only and returns the <em>arity</em> of the function – the number of parameters it declares in its parameter list, which is usually the number of arguments that the function expects. <br><br>Every function has a <code>prototype</code> property that refers to an object known as the <code>prototype object</code>.<br><br><code>call()</code> and <code>apply()</code> allow you to indirectly invoke a function as if it were a method of some other object. The first argument to both <code>call()</code> and <code>apply()</code> is the object on which the function is to be invoked; this argument is the invocation context and becomes the value of the <code>this</code> keyword within the body of the function. To invoke the function <code>f()</code> as a method of the object <code>o</code>, you could use either <code>call()</code> or <code>apply()</code>:<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">f.call(o);</span><br><span class=\"line\">f.apply(o);</span><br></pre></td></tr></table></figure></p>\n<p>Either of the lines of code above are similar to the following:<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">o.m = f; <span class=\"comment\">// make f a temporary method of o</span></span><br><span class=\"line\">o.m(); <span class=\"comment\">// invoke it, passing no arguments</span></span><br><span class=\"line\"><span class=\"keyword\">delete</span> o.m; <span class=\"comment\">// remove the temporary method</span></span><br></pre></td></tr></table></figure></p>\n<p>In ECMAScript5 strict mode the first argument to <code>call()</code> or <code>apply()</code> becomes the value of <code>this</code>, even if it is a primitive value or <code>null</code> or <code>undefined</code>. <br><br>Any arguments to <code>call()</code> after the first invocation context argument are the values that are passed to the function that is invoked. <br><br>The <code>apply()</code> method is like the <code>call()</code> method, except that the arguments to be passed to the function are specified as an array.<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">f.call(o, <span class=\"number\">1</span>, <span class=\"number\">2</span>);</span><br><span class=\"line\">f.apply(o, [<span class=\"number\">1</span>,<span class=\"number\">2</span>]);</span><br></pre></td></tr></table></figure></p>\n<p>If a function is defined to accept an arbitrary number of arguments, the <code>apply()</code> method allows you to invoke that function on the contents of an array of arbitrary length.<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Replace the method named m of the object o with a version that logs</span></span><br><span class=\"line\"><span class=\"comment\">// messages before and after invoking the original method.</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">trace</span>(<span class=\"params\">o, m</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> original = o[m]; <span class=\"comment\">// remember original method in the closure</span></span><br><span class=\"line\">    o[m] = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123; <span class=\"comment\">// define the new method </span></span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>(), <span class=\"string\">'entering:'</span>, m);</span><br><span class=\"line\">        <span class=\"keyword\">var</span> result = original.apply(<span class=\"keyword\">this</span>, <span class=\"built_in\">arguments</span>); <span class=\"comment\">// invoke original</span></span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>(), <span class=\"string\">'existing:'</span>, m); </span><br><span class=\"line\">        <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>This <code>trace()</code> function is passed an object and a method name. It replaces the specified method with a new method that ‘wraps’ additional functionality around the original method. This kind of dynamic alteration of existing methods is sometimes called ‘monkey-patching’. <br></p>\n<p>The primary purpose of <code>bind()</code> is to bind a function to an object. When you invoke the <code>bind()</code> method on a function <code>f</code> and pass an object <code>o</code>, the method returns a new function. Invoking the new function (as a function) invokes the original function <code>f</code> as a method of <code>o</code>. <br><br>The ECMAScript 5 <code>bind()</code> method does more than just bind a function to an object. It also performs partial application: any arguments you pass to <code>bind()</code> after the first are bound along with the <code>this</code> value. Partial application is a common technique in functional programming and is sometimes called <em>currying</em>.<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> sum = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">x,y</span>) </span>&#123; <span class=\"keyword\">return</span> x + y &#125;;</span><br><span class=\"line\"><span class=\"keyword\">var</span> succ = sum.bind(<span class=\"literal\">null</span>, <span class=\"number\">1</span>); </span><br><span class=\"line\">succ(<span class=\"number\">2</span>); <span class=\"comment\">// =&gt; 3: x is bound to 1, and we pass 2 for the y argument</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f</span>(<span class=\"params\">y, z</span>) </span>&#123; <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.x + y + z &#125;;</span><br><span class=\"line\"><span class=\"keyword\">var</span> g = f.bind( &#123;<span class=\"attr\">x</span>: <span class=\"number\">1</span>&#125;, <span class=\"number\">2</span>  );  <span class=\"comment\">// bind this and y</span></span><br><span class=\"line\">g(<span class=\"number\">3</span>) <span class=\"comment\">// return 6, x is 1, y is 2, z is 3</span></span><br></pre></td></tr></table></figure></p>\n<p>Functions returned by the bind() method do not have a <code>prototype</code> property. <br></p>\n<p>In practice most implementations of <code>toString()</code> method return the complete source code for the function. <br></p>\n<p>Functions can also be defined with <code>Function()</code> constructor.<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> f = <span class=\"keyword\">new</span> <span class=\"built_in\">Function</span>(<span class=\"string\">'x'</span>, <span class=\"string\">'y'</span>, <span class=\"string\">'return x*y;'</span>);</span><br></pre></td></tr></table></figure></p>\n<p>functions created by <code>Function()</code> constructor do not use lexical scoping. Instead, they are always compiled as if they were top-level functions.<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> scope = <span class=\"string\">'global'</span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">constructorFunction</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> scope = <span class=\"string\">'local'</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Function</span>(<span class=\"string\">\"return scope\"</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">constructFunction()();</span><br></pre></td></tr></table></figure></p>\n<p>The <code>Function()</code> constructor is best thought of as a globally-scoped version of <code>eval()</code> that defines new variables and functions in its own private scope. This constructor should rarely need to use in your code. <br><br>There are ‘array-like’ objects that are not true arrays but can be treated like arrays for most purposes. A similar stiuation exists for functions. A <em>callable object</em> is any object that can be invoked in a function invocation expression. All functions are callable, but not all callable objects are functions, such as client side methods <code>Window.alert()</code> and <code>Document.getElementById()</code>. <br></p>\n<h3 id=\"Functional-Programming\"><a href=\"#Functional-Programming\" class=\"headerlink\" title=\"Functional Programming\"></a>Functional Programming</h3><p>A <em>higher order function</em> is a function operates on functions, taking one or more function as arguments and returning a new function.<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">mapper</span>(<span class=\"params\">f</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">a</span>) </span>&#123; <span class=\"keyword\">return</span> map(a,f); &#125;; <span class=\"comment\">// Array.prototype.map</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> increment = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">x</span>) </span>&#123; <span class=\"keyword\">return</span> x+<span class=\"number\">1</span>; &#125;;</span><br><span class=\"line\"><span class=\"keyword\">var</span> incrementer = mapper(increment);</span><br><span class=\"line\">incrementer([<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>]) <span class=\"comment\">// =&gt; [2,3,4]</span></span><br></pre></td></tr></table></figure></p>\n<p>More general, we can also take two function <code>f</code> and <code>g</code> and returns a new function that computes <code>f(g())</code><br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* Compose function */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">compose</span>(<span class=\"params\">f, g</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> f.call(<span class=\"keyword\">this</span>, g.apply(<span class=\"keyword\">this</span>,<span class=\"built_in\">arguments</span>));</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> square = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">x</span>) </span>&#123;<span class=\"keyword\">return</span> x*x&#125;;</span><br><span class=\"line\"><span class=\"keyword\">var</span> sum = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">x,y</span>) </span>&#123;<span class=\"keyword\">return</span> x+y;&#125;;</span><br><span class=\"line\"><span class=\"keyword\">var</span> squareofsum = compose(square, sum);</span><br><span class=\"line\">squareofsum(<span class=\"number\">2</span>,<span class=\"number\">3</span>) <span class=\"comment\">// =&gt; 25</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/* Partial function */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">partial</span>(<span class=\"params\">f <span class=\"regexp\">/*, ... */</span></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> args = <span class=\"built_in\">arguments</span>;  <span class=\"comment\">// Save the outer arguments array</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> a = array(args, <span class=\"number\">1</span>);   <span class=\"comment\">// Start with an array of outer args</span></span><br><span class=\"line\">        <span class=\"keyword\">var</span> i=<span class=\"number\">0</span>, j=<span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"comment\">// Loop through those args, filling in undefined values from inner</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span>(; i &lt; a.length; i++)</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (a[i] === <span class=\"literal\">undefined</span>) a[i] = <span class=\"built_in\">arguments</span>[j++];</span><br><span class=\"line\">        <span class=\"comment\">// Now append any remaining inner arguments</span></span><br><span class=\"line\">        a = a.concat(array(<span class=\"built_in\">arguments</span>, j))</span><br><span class=\"line\">        <span class=\"keyword\">return</span> f.apply(<span class=\"keyword\">this</span>, a);</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> f = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">x,y,z</span>) </span>&#123; <span class=\"keyword\">return</span> x * (y - z); &#125;;</span><br><span class=\"line\">partial(f, <span class=\"literal\">undefined</span>, <span class=\"number\">2</span>)(<span class=\"number\">3</span>, <span class=\"number\">4</span>) <span class=\"comment\">// Bind middle arguments =&gt;  -6</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/* Memoization */</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// The factorial function defined before caches its previously computed result</span></span><br><span class=\"line\"><span class=\"comment\">// this kind of caching is called memoization.</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// return a memoized version of f</span></span><br><span class=\"line\"><span class=\"comment\">// it only works if arguments to f all have distinct string representations</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">memoize</span>(<span class=\"params\">f</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> cache = &#123;&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> key = <span class=\"built_in\">arguments</span>.length + <span class=\"built_in\">Array</span>.prototype.join.call(<span class=\"built_in\">arguments</span>, <span class=\"string\">\",\"</span>);</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(key <span class=\"keyword\">in</span> cache) <span class=\"keyword\">return</span> cache[key];</span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">return</span> cache[key] = f.apply(<span class=\"keyword\">this</span>, <span class=\"built_in\">arguments</span>);</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">gcd</span>(<span class=\"params\">a, b</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> t;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(a &lt; b) t = b, b = a, a = t;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> ( b != <span class=\"number\">0</span>) t = b, b = a%b, a = t;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> a;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> gcdmemo = memoize(gcd);</span><br><span class=\"line\">gcdmemo = (<span class=\"number\">85</span>,<span class=\"number\">187</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> factorial = memoize(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">n</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ( n &lt;= <span class=\"number\">1</span>) ? <span class=\"number\">1</span> : n*factorial(n<span class=\"number\">-1</span>);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">factorial(<span class=\"number\">5</span>) <span class=\"comment\">// =&gt; 120</span></span><br></pre></td></tr></table></figure></p>\n","prev":{"title":"Javascript: Class (1)","slug":"js-class-1"},"next":{"title":"Javascript: Array","slug":"JS-array"},"link":"https://whitefusion.github.io/post/js-functions"}