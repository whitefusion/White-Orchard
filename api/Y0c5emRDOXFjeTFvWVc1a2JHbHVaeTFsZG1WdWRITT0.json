{"title":"Javascript: Handling Events","date":"2018-11-16T14:03:21.000Z","excerpt":"","slug":"js-handling-events","comments":true,"tags":["note","javascript"],"categories":["language core"],"updated":"2018-11-24T03:51:04.635Z","content":"<blockquote>\n<p>This is the reading note for “Chapter 17: Handling Events, Javascript: The definitive guide 5th edition”. <br></p>\n</blockquote>\n<p>Client-side JS programs use an asynchronous event-driven programming model. In this style of programming, the web browser generates an event whenever something interesting happens to the document or browser or to some element or object associated with it. <br></p>\n<p>The <em>event type</em> is a string that specifies what kind of event occurred. The <em>event target</em> is the object on which the event occurred or with which the event is associated. When we speak of an event, we must specify both the type and the target. Window, Document, and Element objects are the most common event targets in client-side JS applications. <br></p>\n<p>All <em>event handler</em> or <em>event listener</em> is a function that handles or responds to an evnet. Applications register their event handler functions with the web browser, specifying an event type and an event target. When an event of the specified type occurs on the specified target, the browser invokes the handler. When event handlers are invoked for an object, we sometimes say that the browser has ‘fired’, ‘triggered’, or ‘dispatched’ the event. <br></p>\n<p>An <em>event object</em> is an object that is associated with a particular event and contains details about that event. Event objects are passed as an argument to the event handler function. All event objects have a <code>type</code> property that specifies the event type and a <code>target</code> property that specifies the event target. <br></p>\n<p><em>Event propagation</em> is the process by which the browser decides which objects to trigger event handlers on. For events that are specific to a single object (such as the load e vent on the Window object), no propagation is required. When certain kinds of events occur on document elements, however, they propagate or “bubble” up the document tree. An event handler can stop the propagation of an event, so that it will not continue to bubble and will not trigger handlers on containing elements. Handlers do this by invoking a method or setting a property of the event object. <br></p>\n<p>In another form of event propagation, known as <em>event capturing</em>, handlers specially registered on container elements have the opportunity to intercept events before they are delivered to their actual target. <br></p>\n<p>Some events have <em>default actions</em> associated with them. When a click event occurs on a hyperlink, for example, the default action is for the browser to follow the link and load a new page. Event handlers can prevent this default action by returning an appropriate value, invoking a method of the event object, or by setting a property of the event object. This is sometimes called “cancelling” the event. <br></p>\n<p>These event-type-specific sections cover:</p>\n<ul>\n<li>Document loading and readiness events</li>\n<li>Mouse events</li>\n<li>Mouse wheel events</li>\n<li>Drag-and-drop events</li>\n<li>Key events</li>\n<li>Text input events</li>\n</ul>\n<h2 id=\"Types-of-Events\"><a href=\"#Types-of-Events\" class=\"headerlink\" title=\"Types of Events\"></a>Types of Events</h2><h3 id=\"Legacy-Event-Types\"><a href=\"#Legacy-Event-Types\" class=\"headerlink\" title=\"Legacy Event Types\"></a>Legacy Event Types</h3><h4 id=\"Form-events\"><a href=\"#Form-events\" class=\"headerlink\" title=\"Form events\"></a>Form events</h4><p><code>&lt;form&gt;</code> elements fire submit events when the form is submitted and reset events when the form is reset. Button-like form elements (including radio buttons and checkboxes) fire click events when the user interacts with them. Form elements that maintain some kind of state generally fire change events when the user changes their state by entering text, selecting an item, or checking a box. For text input fields, a change event is not fired  until the user has finished interacting a form element and has tabbed or cliked to move focus to another element. Form elements respond to keyboard focus changes by firing focus and blur events. <br></p>\n<p>The submit and reset events have default actions that can be canceled by event handlers. The focus and blur events do not bubble, but all the other form events do. <br></p>\n<p>Note that browsers other than IE trigger an input event on <code>&lt;textarea&gt;</code> and other text-input form elements whenever the user enters text into the element. Unlike the change event, these input events are triggered for each insertion. Unfortunately, the event object of an input event does not specify what text has been input. <br></p>\n<h4 id=\"Window-events\"><a href=\"#Window-events\" class=\"headerlink\" title=\"Window events\"></a>Window events</h4><p>Window events represent occurences related to the browser window itself, rather than any specific document content displayed inside the window. <br></p>\n<p>The load event is the most important of these events: it is fired when a document and all of its external resources are fully loaded and displayed to the user. DOMContentLoaded and readystatechange are alternatives to the load events: they are triggered sooner, when the document its elements are ready to manipulate, but before external resources are fully loaded. <br></p>\n<p>The unload event is the opposite of load, it is triggered when the user is navigating away from a document. An unload event handler might be used to save the user’s state, but it cannot be used to cancel navigation. The beforeunload is similar to unload but gives you the opportunity to ask the user to confirm that they really want to navigate away from your web page. If a handler for beforeunload returns a string, that string will be displayed to the user in a confirmation dialog before the new page is loaded, and the user will have the opportunity to cancel her navigation and remain at your page. <br></p>\n<p>The <code>onerror</code> property of the Window object is something like an event handler, and it is triggered in response to Javascript errors. Some browsers also support an abort event, which is triggered when an image fails to load because the user stopped the loading process. <br></p>\n<p>The focus and blur events described above for form elements are also used as Window events: they are triggered on a window when that browser window receives or loses keyboard focus from the operating system. <br></p>\n<p>Finally, the resize and scroll events are fired on a Window when the user resizes or scrolls the browser window. Scroll events can also be fired on any scrollable document element, such as those with the CSS <code>overflow</code> property set. The event object passed to resize and scroll event handlers is just an ordinary Event object and does not have properties that specify how much resizing or scrolling occurred. </p>\n<h3 id=\"Mouse-events\"><a href=\"#Mouse-events\" class=\"headerlink\" title=\"Mouse events\"></a>Mouse events</h3><p>Mouse events are generated when the user moves or clicks the mouse over a document. These events are triggered on the most deeply nested element that the mouse pointer is over, but they bubble up through the document. The event object passed to mouse event handlers has properties set that describe the position and button state of the mouse and also specify whether any modifier keys were held down when the event occurred. The <code>clientX</code> and <code>clientY</code> properties specify the position of the mouse in window coordinates. The <code>button</code> and <code>which</code> properties specify which mouse button was pressed. The <code>altKey</code>, <code>ctrlKey</code>, <code>metaKey</code> and <code>shiftKey</code> properties are set to <code>true</code> when the corresponding keyboard modifier keys are held down. And for click events, the <code>detail</code> property specifies whether this was a single, double, or triple click. <br></p>\n<p>The mousemove event is triggered any time the user moves or drags the mouse. These events occur frequently, so mousemove handlers must not trigger computationally intensive tasks. By registering a mousedown handler that registers a mousemove handler, you can detect and respond to mouse drags. Doing this properly involves being able to capture mouse events so that you continue to receive mousemove events even when the mouse has moved out of the element it started in. <br></p>\n<p>After a mousedown and mouseup event sequence, the browser also triggers a click event. The click event was described above as a device-independent form event, but it is actually triggered on any document element, not just form elements, and it is passed an event object with all of the extra mouse-related fields described above. If the user clicks a mouse button twice in a row (within a sufficiently short amount of time), the second click event will be followed by a dblclick event. Browsers often display a context menu when the right mouse button is clicked. They generally fire a contextmenu event before displaying the menu, and if you cancel the event, you can prevent the display of the menu. <br></p>\n<p>When the user moves the mouse so that it goes over a new element, the browser fires a mouseover event on that element. When the mouse moves so that it is no longer over an element, the browser fires a mouseout event on that element. For these events, the event object will have a <code>relatedTarget</code> property that specifies the other element involved in the transition. This is often inconvenient, because when a mouseout handler is triggered, you have to check whether the mouse actally left the element you are interested in or if it merely transitionaed from one child of the element to another. <br></p>\n<p>When the user rotates the mouse wheel, browsers trigger a mousewheel event. The event object passed with these events includes properties that specify how much, and in which direction, the wheel was rotated. <br></p>\n<h3 id=\"Key-events\"><a href=\"#Key-events\" class=\"headerlink\" title=\"Key events\"></a>Key events</h3><p>Keyboard shortcuts that have meaning to the operating system or to the browser itself are often “eaten” by the OS or browser and may not be visible to JS event handlers, however. Keyboards events are  triggered on whatever document element has keyboard focus, and they bubble up to the document and window. If no element has the focus, the events are triggered directly on the document. Keyboard event handlers are passed an event object with a <code>keyCode</code> field that specifies what key was pressed or released. In addition to <code>keyCode</code>, the event object for key events also has <code>altKey</code>, <code>ctrlkey</code>, <code>metaKey</code>, and <code>shiftKey</code> that describe the state of the keyboard modifier keys. <br></p>\n<p>The keydown and keyup events are low-level keyboard events: they are triggered whenever a key is pressed or released. When a keydown event generateds a printable character, an additional keypress event is triggered after the keydown but before the keyup. (In the case of a key that is held down until it repeats, there may be many keypress events before the keyup event.) The keypress event is a higher-level text event, and its event object specifies the character that was generated, not the key that was pressed. </p>\n<h2 id=\"DOM-Events\"><a href=\"#DOM-Events\" class=\"headerlink\" title=\"DOM Events\"></a>DOM Events</h2>","next":{"title":"HTML notes","slug":"html-note"},"link":"https://whitefusion.github.io/post/js-handling-events"}