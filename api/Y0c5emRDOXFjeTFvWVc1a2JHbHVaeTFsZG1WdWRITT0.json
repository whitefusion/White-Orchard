{"title":"Javascript: Handling Events","date":"2018-11-16T14:03:21.000Z","excerpt":"","slug":"js-handling-events","comments":true,"tags":["javascript","note"],"categories":["language core"],"updated":"2018-12-09T03:01:57.503Z","content":"<blockquote>\n<p>This is the reading note for “Chapter 17: Handling Events, Javascript: The definitive guide 5th edition”. <br></p>\n</blockquote>\n<p>Client-side JS programs use an asynchronous event-driven programming model. In this style of programming, the web browser generates an event whenever something interesting happens to the document or browser or to some element or object associated with it. <br></p>\n<p>The <em>event type</em> is a string that specifies what kind of event occurred. The <em>event target</em> is the object on which the event occurred or with which the event is associated. When we speak of an event, we must specify both the type and the target. Window, Document, and Element objects are the most common event targets in client-side JS applications. <br></p>\n<p>All <em>event handler</em> or <em>event listener</em> is a function that handles or responds to an evnet. Applications register their event handler functions with the web browser, specifying an event type and an event target. When an event of the specified type occurs on the specified target, the browser invokes the handler. When event handlers are invoked for an object, we sometimes say that the browser has ‘fired’, ‘triggered’, or ‘dispatched’ the event. <br></p>\n<p>An <em>event object</em> is an object that is associated with a particular event and contains details about that event. Event objects are passed as an argument to the event handler function. All event objects have a <code>type</code> property that specifies the event type and a <code>target</code> property that specifies the event target. <br></p>\n<p><em>Event propagation</em> is the process by which the browser decides which objects to trigger event handlers on. For events that are specific to a single object (such as the load e vent on the Window object), no propagation is required. When certain kinds of events occur on document elements, however, they propagate or “bubble” up the document tree. An event handler can stop the propagation of an event, so that it will not continue to bubble and will not trigger handlers on containing elements. Handlers do this by invoking a method or setting a property of the event object. <br></p>\n<p>In another form of event propagation, known as <em>event capturing</em>, handlers specially registered on container elements have the opportunity to intercept events before they are delivered to their actual target. <br></p>\n<p>Some events have <em>default actions</em> associated with them. When a click event occurs on a hyperlink, for example, the default action is for the browser to follow the link and load a new page. Event handlers can prevent this default action by returning an appropriate value, invoking a method of the event object, or by setting a property of the event object. This is sometimes called “cancelling” the event. <br></p>\n<p>These event-type-specific sections cover:</p>\n<ul>\n<li>Document loading and readiness events</li>\n<li>Mouse events</li>\n<li>Mouse wheel events</li>\n<li>Drag-and-drop events</li>\n<li>Key events</li>\n<li>Text input events</li>\n</ul>\n<h2 id=\"Types-of-Events\"><a href=\"#Types-of-Events\" class=\"headerlink\" title=\"Types of Events\"></a>Types of Events</h2><h3 id=\"Legacy-Event-Types\"><a href=\"#Legacy-Event-Types\" class=\"headerlink\" title=\"Legacy Event Types\"></a>Legacy Event Types</h3><h4 id=\"Form-events\"><a href=\"#Form-events\" class=\"headerlink\" title=\"Form events\"></a>Form events</h4><p><code>&lt;form&gt;</code> elements fire submit events when the form is submitted and reset events when the form is reset. Button-like form elements (including radio buttons and checkboxes) fire click events when the user interacts with them. Form elements that maintain some kind of state generally fire change events when the user changes their state by entering text, selecting an item, or checking a box. For text input fields, a change event is not fired  until the user has finished interacting a form element and has tabbed or cliked to move focus to another element. Form elements respond to keyboard focus changes by firing focus and blur events. <br></p>\n<p>The submit and reset events have default actions that can be canceled by event handlers. The focus and blur events do not bubble, but all the other form events do. <br></p>\n<p>Note that browsers other than IE trigger an input event on <code>&lt;textarea&gt;</code> and other text-input form elements whenever the user enters text into the element. Unlike the change event, these input events are triggered for each insertion. Unfortunately, the event object of an input event does not specify what text has been input. <br></p>\n<h4 id=\"Window-events\"><a href=\"#Window-events\" class=\"headerlink\" title=\"Window events\"></a>Window events</h4><p>Window events represent occurences related to the browser window itself, rather than any specific document content displayed inside the window. <br></p>\n<p>The load event is the most important of these events: it is fired when a document and all of its external resources are fully loaded and displayed to the user. DOMContentLoaded and readystatechange are alternatives to the load events: they are triggered sooner, when the document its elements are ready to manipulate, but before external resources are fully loaded. <br></p>\n<p>The unload event is the opposite of load, it is triggered when the user is navigating away from a document. An unload event handler might be used to save the user’s state, but it cannot be used to cancel navigation. The beforeunload is similar to unload but gives you the opportunity to ask the user to confirm that they really want to navigate away from your web page. If a handler for beforeunload returns a string, that string will be displayed to the user in a confirmation dialog before the new page is loaded, and the user will have the opportunity to cancel her navigation and remain at your page. <br></p>\n<p>The <code>onerror</code> property of the Window object is something like an event handler, and it is triggered in response to Javascript errors. Some browsers also support an abort event, which is triggered when an image fails to load because the user stopped the loading process. <br></p>\n<p>The focus and blur events described above for form elements are also used as Window events: they are triggered on a window when that browser window receives or loses keyboard focus from the operating system. <br></p>\n<p>Finally, the resize and scroll events are fired on a Window when the user resizes or scrolls the browser window. Scroll events can also be fired on any scrollable document element, such as those with the CSS <code>overflow</code> property set. The event object passed to resize and scroll event handlers is just an ordinary Event object and does not have properties that specify how much resizing or scrolling occurred. </p>\n<h3 id=\"Mouse-events\"><a href=\"#Mouse-events\" class=\"headerlink\" title=\"Mouse events\"></a>Mouse events</h3><p>Mouse events are generated when the user moves or clicks the mouse over a document. These events are triggered on the most deeply nested element that the mouse pointer is over, but they bubble up through the document. The event object passed to mouse event handlers has properties set that describe the position and button state of the mouse and also specify whether any modifier keys were held down when the event occurred. The <code>clientX</code> and <code>clientY</code> properties specify the position of the mouse in window coordinates. The <code>button</code> and <code>which</code> properties specify which mouse button was pressed. The <code>altKey</code>, <code>ctrlKey</code>, <code>metaKey</code> and <code>shiftKey</code> properties are set to <code>true</code> when the corresponding keyboard modifier keys are held down. And for click events, the <code>detail</code> property specifies whether this was a single, double, or triple click. <br></p>\n<p>The mousemove event is triggered any time the user moves or drags the mouse. These events occur frequently, so mousemove handlers must not trigger computationally intensive tasks. By registering a mousedown handler that registers a mousemove handler, you can detect and respond to mouse drags. Doing this properly involves being able to capture mouse events so that you continue to receive mousemove events even when the mouse has moved out of the element it started in. <br></p>\n<p>After a mousedown and mouseup event sequence, the browser also triggers a click event. The click event was described above as a device-independent form event, but it is actually triggered on any document element, not just form elements, and it is passed an event object with all of the extra mouse-related fields described above. If the user clicks a mouse button twice in a row (within a sufficiently short amount of time), the second click event will be followed by a dblclick event. Browsers often display a context menu when the right mouse button is clicked. They generally fire a contextmenu event before displaying the menu, and if you cancel the event, you can prevent the display of the menu. <br></p>\n<p>When the user moves the mouse so that it goes over a new element, the browser fires a mouseover event on that element. When the mouse moves so that it is no longer over an element, the browser fires a mouseout event on that element. For these events, the event object will have a <code>relatedTarget</code> property that specifies the other element involved in the transition. This is often inconvenient, because when a mouseout handler is triggered, you have to check whether the mouse actally left the element you are interested in or if it merely transitionaed from one child of the element to another. <br></p>\n<p>When the user rotates the mouse wheel, browsers trigger a mousewheel event. The event object passed with these events includes properties that specify how much, and in which direction, the wheel was rotated. <br></p>\n<h3 id=\"Key-events\"><a href=\"#Key-events\" class=\"headerlink\" title=\"Key events\"></a>Key events</h3><p>Keyboard shortcuts that have meaning to the operating system or to the browser itself are often “eaten” by the OS or browser and may not be visible to JS event handlers, however. Keyboards events are  triggered on whatever document element has keyboard focus, and they bubble up to the document and window. If no element has the focus, the events are triggered directly on the document. Keyboard event handlers are passed an event object with a <code>keyCode</code> field that specifies what key was pressed or released. In addition to <code>keyCode</code>, the event object for key events also has <code>altKey</code>, <code>ctrlkey</code>, <code>metaKey</code>, and <code>shiftKey</code> that describe the state of the keyboard modifier keys. <br></p>\n<p>The keydown and keyup events are low-level keyboard events: they are triggered whenever a key is pressed or released. When a keydown event generateds a printable character, an additional keypress event is triggered after the keydown but before the keyup. (In the case of a key that is held down until it repeats, there may be many keypress events before the keyup event.) The keypress event is a higher-level text event, and its event object specifies the character that was generated, not the key that was pressed. </p>\n<h2 id=\"DOM-Events\"><a href=\"#DOM-Events\" class=\"headerlink\" title=\"DOM Events\"></a>DOM Events</h2><p>The DOM level 3 events specification standardizes the focusin and focusout events as bubbling alternatives to the focus and blur events and standardizes the mouseenter and mouseleave events as nonbubbling alternatives to mouseover and mouseout. <br></p>\n<p>What is new in the DOM level 3 events specification is standardized support for two-dimensional mouse wheels via the wheel event and better support for text input events with a textinput event and with a new KeyboardEvent object that is passed as the argument to handlers for keydown, keyup, and keypress events. <br></p>\n<p>A handler for a wheel event receievs an event object with all the usual mouse event properties, and also <code>deltaX</code>, <code>deltaY</code>, and <code>deltaZ</code> properties that report rotation around three different mouse wheel axes. <br></p>\n<p>Rather than a hard-to-use numeric <code>keyCode</code> value, the event object passed to a textinput event handler has a <code>data</code> property that specifies the string of text that as was entered. The textinput event is not a keyboard-specific event: it is triggered whenever text input occurs, whether via the keyboard, cut-and-parse, drag-and-drop, and so on. <br></p>\n<p>This new DOM standard also simplifies keydown, keyup, and keypress events by adding new <code>key</code> and <code>char</code> properties to the event object. Both of these properties are strings. For key events that generate printable characters, <code>key</code> and <code>char</code> will be equal to the generated text. For control keys, the <code>key</code> property will be a string like “Enter”, “Delete”, or “Left” that identifies the key. The <code>char</code> will either be <code>null</code> or, for control keys like Tab that have a character code, it will be the string generated by the key. <br> </p>\n<h2 id=\"HTML5-Events\"><a href=\"#HTML5-Events\" class=\"headerlink\" title=\"HTML5 Events\"></a>HTML5 Events</h2><p>One of the widely advertised features of HTML is inclusion of <code>&lt;audio&gt;</code> and <code>&lt;video&gt;</code> elements for playing sound and video. <br></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">canplay         loadeddata       playing          stalled</span><br><span class=\"line\">canplaythrough  loadedmetadata   progress         suspend</span><br><span class=\"line\">durationchange  loadstart        ratechange       timeupdate</span><br><span class=\"line\">emptied         pause            seeked           volumechange</span><br><span class=\"line\">ended           play             seeking          waiting</span><br></pre></td></tr></table></figure>\n<p>These media events are passed an ordinary event object with no special properties. The <code>target</code> property identifies the <code>&lt;audio&gt;</code> or <code>&lt;video&gt;</code> element, however, and that element has many relevant properties and methods. <br></p>\n<p>The HTML5 drag-and-drop API allows JS applications to participate in OS-based drap-and-drop operations, transferring data between web applications and native applications.<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">dragstart    drag        dragend</span><br><span class=\"line\">dragenter    dragover    dragleave</span><br><span class=\"line\">drop</span><br></pre></td></tr></table></figure></p>\n<p>The drag-and-drop events are triggered with an event object like those sent with mouse events. One additional property, <code>dataTransfer</code>, holds a DataTransfer object that contains information about the data being transferred and the formats in which it is available. <br></p>\n<p>HTML5 defines history management mechanism that allows web applications to interact with the browser’s Back and Forward buttons. This mechanism involves events named hashchange and popstate. These events are lifecycle notification events like load and unload and are fired at the Window object rather than any individual document element. <br></p>\n<p>HTML5 also defines a form validation mechanism, which includes an invalid event fired on form elements that have failed validation. <br></p>\n<p>HTML5 includes support for offline web applications that can be installed locally in an application cache so that they can run even when the browser is offline. The two most important events associated with this are the offline and online events: they are triggered on the Window object whenever the browser loses or gains a network connection. A number of additional events are defined to provide notification of application download progress and application cache updates:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cached      checking      downloading    error</span><br><span class=\"line\">noupdate    obsolete      progress       updateready</span><br></pre></td></tr></table></figure></p>\n<p>HTML5 and related standards define some events that are triggered on objects other than windows, documents, and document elements. Version 2 of the XMLHttpRequest specification, as well as the File API specification, define a series of events that track the progress of asynchronous I/O. They trigger events on an XMLHttpRequest or FileReader object. Each read operation begins with a loadstart event, followed by progress events and a loadend event. <br></p>\n<h3 id=\"Touchscreen-and-Mobile-Events\"><a href=\"#Touchscreen-and-Mobile-Events\" class=\"headerlink\" title=\"Touchscreen and Mobile Events\"></a>Touchscreen and Mobile Events</h3><p>In many cases, touchscreen events are mapped to traditional event types such as click and scroll. The orientation change event generated when the user rotates the device. Safari generates gesture events for two-finger scalling and rotation gestures. Gesture events are high-level events that notify you of a gesture that has already been interpreted. <br></p>\n<h1 id=\"Registering-Event-Handlers\"><a href=\"#Registering-Event-Handlers\" class=\"headerlink\" title=\"Registering Event Handlers\"></a>Registering Event Handlers</h1><p>There are two basic ways to register event handlers. The first is to set a property on the object or document element that is the event target. The second is to pass the handler to a method of the object or element. To complicate matters, there are two versions of each technique. You can set an event handler property in JS code, or for document elements, you can set the corresponding attribute directly in HTML. For handler registration by method invocation, there is a standard method, named <code>addEventListener()</code>, that is supported by all browsers except IE8 and before, and a different method, named <code>attachEvent()</code>, for all versions of IE before IE9. </p>\n<h3 id=\"Setting-Event-Handler-Properties\"><a href=\"#Setting-Event-Handler-Properties\" class=\"headerlink\" title=\"Setting Event Handler Properties\"></a>Setting Event Handler Properties</h3><p>The simplest way to register an event handler is by setting a property of the event target to the desired event handler function. By connvention, event handler properties have names that consist of the word ‘on’ followed by the event name: <code>onclick</code>, <code>onchange</code>, <code>onload</code>, <code>onmouseover</code>, and so on. Note that these property names are case sensitive and are written in all lowercase, even when the event type(such as ‘readystatechange’) consists of multiple words. </p>\n<p>###js<br>window.onload = function() { … };</p>\n<p>###</p>\n<p>The shortcoming of event handler properties is that they are designed around the assumption that event targets will have at most one handler for each type of event. If you are writing library code for use in arbitrary documents, it is better to register event handlers using a technique(such as <code>addEventListener()</code>) that will not modify or overwrite any previously registered handlers.  <br></p>\n<h3 id=\"Setting-Event-Handler-Attributes\"><a href=\"#Setting-Event-Handler-Attributes\" class=\"headerlink\" title=\"Setting Event Handler Attributes\"></a>Setting Event Handler Attributes</h3><p>The event handler properties of a document element can also be set as attributes on the corresponding HTML tag. If you do this, the attribute value should be a string of JS code.<br>That code should be the <code>body</code> of the event handler function, not a complete function declaration. </p>\n<p>###html</p>\n<p><button onclick=\"alert('Thank you');\">Click</button></p>\n<p>###<br>Some event types are directed at the browser as a whole, rather than at any particular document element. In JS, handlers for these events are registered on the Window object. In HTML, we place them on the <code>&lt;body&gt;</code> tag, but the browser registers them on the Window. The following is the complete list of such event handlers as defined by the draft HTML5 specification:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">onafterprint    onfocus         ononline        onresize       </span><br><span class=\"line\">onbeforeprint   onhashchange    onpagehide      onstorage      </span><br><span class=\"line\">onbeforeunload  onload          onpageshow      onundo</span><br><span class=\"line\">onblur          onmessage       onpopstate      onunload</span><br><span class=\"line\">onerror         onoffline       onredo</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"addEventListener\"><a href=\"#addEventListener\" class=\"headerlink\" title=\"addEventListener()\"></a>addEventListener()</h3><p>In the standard event model supported by all browsers other than ID8 and earlier, any object that can be an event target-this includes the Window and Document objects and all document Elements-defines a method named <code>addEventListener()</code> that you can use to regiseter an event handler for that target. <code>addEventListener()</code> takes three arguments. The first is the event type for which the handler is being registered. The event type (or name) is a string and it should not include the “on” prefix that is used when setting event handler properties. The second argument to <code>addEventListener</code> is the function that should be invoked when the specified type of event occurs. The final argument to <code>addEventListener()</code> is a boolean value. Normally, you’ll pass <code>false</code> for this argument. If you pass <code>true</code> instead, your function is registered as a <code>capturing</code> event handler and is invoked at a different phase of event dispatch. <br></p>\n<p>###html</p>\n<p><button id=\"mybutton\"> Click me </button></p>\n<p><script><br>var b = document.getElementById(“mybutton”);<br>b.onclick = function(){alert(“thank you for clicking me”);};<br>b.addEventListener(“click”, function(){alert(“thank you again”);},false);<br></script></p>\n<p>###<br>Calling <code>addEventListener()</code> with “click” as its first argument does not affect the value of the <code>onclick</code> property. In the code above, a button click will generate two <code>alert()</code> dialog boxes. More importantly, you can call <code>addEventListener()</code> multiple times to register more than one handler function for the same event type on the same object. <br></p>\n<p><code>addEventLisenter()</code> is paired with a <code>removeEventListener()</code> method that expects the same three arguments but removes an event handler function from an object rather than addint it. <br></p>\n<h2 id=\"Event-Handler-Invocation\"><a href=\"#Event-Handler-Invocation\" class=\"headerlink\" title=\"Event Handler Invocation\"></a>Event Handler Invocation</h2>","next":{"title":"HTML notes","slug":"html-note"},"link":"https://whitefusion.github.io/post/js-handling-events"}